/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


void php_wxLogWindow_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLogWindow_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxLogWindow_php* object = static_cast<wxLogWindow_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxLogWindow done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxLogWindow, GetFrame)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogWindow::GetFrame\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogWindow::GetFrame\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogWindow){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogWindow::GetFrame() to return object pointer\n\n");
				#endif
				wxFrame_php* value_to_return0;
				value_to_return0 = (wxFrame_php*) ((wxLogWindow_php*)_this)->GetFrame();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFrame_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxFrame));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
bool wxLogWindow_php::OnFrameClose(wxFrame* frame)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxLogWindow::OnFrameClose\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnFrameClose", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFrame_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)frame, le_wxFrame));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxLogWindow::OnFrameClose(frame);

}
void wxLogWindow_php::OnFrameCreate(wxFrame* frame)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxLogWindow::OnFrameCreate\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnFrameCreate", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFrame_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)frame, le_wxFrame));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxLogWindow::OnFrameCreate(frame);

}
void wxLogWindow_php::OnFrameDelete(wxFrame* frame)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxLogWindow::OnFrameDelete\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnFrameDelete", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFrame_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)frame, le_wxFrame));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxLogWindow::OnFrameDelete(frame);

}
PHP_METHOD(php_wxLogWindow, Show)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogWindow::Show\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogWindow::Show\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogWindow){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogWindow::Show()\n\n");
				#endif
				((wxLogWindow_php*)_this)->Show();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogWindow::Show(show0)\n\n");
				#endif
				((wxLogWindow_php*)_this)->Show(show0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogWindow, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogWindow::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* pParent0 = 0;
	void* object_pointer0_0 = 0;
	char* szTitle0;
	long szTitle_len0;
	bool show0;
	bool passToOld0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zs|bb' (&pParent0, &szTitle0, &szTitle_len0, &show0, &passToOld0)\n");
		#endif
		char parse_parameters_string[] = "zs|bb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pParent0, &szTitle0, &szTitle_len0, &show0, &passToOld0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pParent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pParent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pParent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, wxString(szTitle0, wxConvUTF8))\n");
				#endif
				_this = new wxLogWindow_php((wxWindow*) object_pointer0_0, wxString(szTitle0, wxConvUTF8));

				((wxLogWindow_php*) _this)->references.Initialize();
				((wxLogWindow_php*) _this)->references.AddReference(pParent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, wxString(szTitle0, wxConvUTF8), show0)\n");
				#endif
				_this = new wxLogWindow_php((wxWindow*) object_pointer0_0, wxString(szTitle0, wxConvUTF8), show0);

				((wxLogWindow_php*) _this)->references.Initialize();
				((wxLogWindow_php*) _this)->references.AddReference(pParent0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, wxString(szTitle0, wxConvUTF8), show0, passToOld0)\n");
				#endif
				_this = new wxLogWindow_php((wxWindow*) object_pointer0_0, wxString(szTitle0, wxConvUTF8), show0, passToOld0);

				((wxLogWindow_php*) _this)->references.Initialize();
				((wxLogWindow_php*) _this)->references.AddReference(pParent0);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxLogWindow);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxLogWindow_php*) _this)->evnArray);
		
		array_init(((wxLogWindow_php*) _this)->evnArray);
		
		((wxLogWindow_php*) _this)->phpObj = getThis();
		
		((wxLogWindow_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxLogWindow_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxLogChain_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLogChain_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxLogChain_php* object = static_cast<wxLogChain_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxLogChain done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxLogChain, DetachOldLog)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogChain::DetachOldLog\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogChain::DetachOldLog\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogChain){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogChain::DetachOldLog()\n\n");
				#endif
				((wxLogChain_php*)_this)->DetachOldLog();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogChain, GetOldLog)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogChain::GetOldLog\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogChain::GetOldLog\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogChain){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogChain::GetOldLog() to return object pointer\n\n");
				#endif
				wxLog_php* value_to_return0;
				value_to_return0 = (wxLog_php*) ((wxLogChain_php*)_this)->GetOldLog();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxLog_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxLog));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogChain, IsPassingMessages)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogChain::IsPassingMessages\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogChain::IsPassingMessages\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogChain){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxLogChain::IsPassingMessages())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxLogChain_php*)_this)->IsPassingMessages());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogChain, PassMessages)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogChain::PassMessages\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogChain::PassMessages\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogChain){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool passMessages0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&passMessages0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &passMessages0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogChain::PassMessages(passMessages0)\n\n");
				#endif
				((wxLogChain_php*)_this)->PassMessages(passMessages0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogChain, SetLog)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogChain::SetLog\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogChain::SetLog\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogChain){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* logger0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&logger0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &logger0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(logger0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(logger0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxLogBuffer && rsrc_type != le_wxLogChain && rsrc_type != le_wxLogInterposer && rsrc_type != le_wxLogWindow && rsrc_type != le_wxLogGui && rsrc_type != le_wxLogTextCtrl))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(logger0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogChain::SetLog((wxLog*) object_pointer0_0)\n\n");
				#endif
				((wxLogChain_php*)_this)->SetLog((wxLog*) object_pointer0_0);

				references->AddReference(logger0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogChain, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogChain::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* logger0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&logger0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &logger0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(logger0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(logger0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxLogBuffer && rsrc_type != le_wxLogChain && rsrc_type != le_wxLogInterposer && rsrc_type != le_wxLogWindow && rsrc_type != le_wxLogGui && rsrc_type != le_wxLogTextCtrl))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(logger0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxLog*) object_pointer0_0)\n");
				#endif
				_this = new wxLogChain_php((wxLog*) object_pointer0_0);

				((wxLogChain_php*) _this)->references.Initialize();
				((wxLogChain_php*) _this)->references.AddReference(logger0);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxLogChain);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxLogChain_php*) _this)->evnArray);
		
		array_init(((wxLogChain_php*) _this)->evnArray);
		
		((wxLogChain_php*) _this)->phpObj = getThis();
		
		((wxLogChain_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxLogChain_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxLogGui_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLogGui_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxLogGui_php* object = static_cast<wxLogGui_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxLogGui done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxLogGui, Flush)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogGui::Flush\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogGui::Flush\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogGui){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogGui::Flush()\n\n");
				#endif
				((wxLogGui_php*)_this)->Flush();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogGui, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogGui::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxLogGui_php();

				((wxLogGui_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxLogGui);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxLogGui_php*) _this)->evnArray);
		
		array_init(((wxLogGui_php*) _this)->evnArray);
		
		((wxLogGui_php*) _this)->phpObj = getThis();
		
		((wxLogGui_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxLogGui_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxLogGui, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogGui::__get\n");
	php_printf("===========================================\n");
	#endif
	
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	
	char* name;
	int name_len;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogGui::wxLogGui\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("m_aMessages", name) == 0)
	{
	}
	else if(strcmp("m_aSeverity", name) == 0)
	{
	}
	else if(strcmp("m_aTimes", name) == 0)
	{
	}
	else if(strcmp("m_bErrors", name) == 0)
	{
		RETVAL_BOOL(*((bool*)((wxLogGui_php*) _this)->properties[3]));
	}
	else if(strcmp("m_bWarnings", name) == 0)
	{
		RETVAL_BOOL(*((bool*)((wxLogGui_php*) _this)->properties[4]));
	}
	else if(strcmp("m_bHasMessages", name) == 0)
	{
		RETVAL_BOOL(*((bool*)((wxLogGui_php*) _this)->properties[5]));
	}
	else
	{
		RETVAL_NULL();
	}
	
}
void php_wxLogBuffer_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLogBuffer_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxLogBuffer_php* object = static_cast<wxLogBuffer_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxLogBuffer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxLogBuffer, Flush)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogBuffer::Flush\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogBuffer::Flush\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogBuffer){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLogBuffer::Flush()\n\n");
				#endif
				((wxLogBuffer_php*)_this)->Flush();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogBuffer, GetBuffer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogBuffer::GetBuffer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLogBuffer::GetBuffer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLogBuffer){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxLogBuffer::GetBuffer().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxLogBuffer_php*)_this)->GetBuffer();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLogBuffer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogBuffer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxLogBuffer_php();

				((wxLogBuffer_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxLogBuffer);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxLogBuffer_php*) _this)->evnArray);
		
		array_init(((wxLogBuffer_php*) _this)->evnArray);
		
		((wxLogBuffer_php*) _this)->phpObj = getThis();
		
		((wxLogBuffer_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxLogBuffer_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxLogInterposer_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLogInterposer_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxLogInterposer_php* object = static_cast<wxLogInterposer_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxLogInterposer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxLogInterposer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogInterposer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxLogInterposer_php();

				((wxLogInterposer_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxLogInterposer);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxLogInterposer_php*) _this)->evnArray);
		
		array_init(((wxLogInterposer_php*) _this)->evnArray);
		
		((wxLogInterposer_php*) _this)->phpObj = getThis();
		
		((wxLogInterposer_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxLogInterposer_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxLogTextCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLogTextCtrl_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxLogTextCtrl_php* object = static_cast<wxLogTextCtrl_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxLogTextCtrl done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxLogTextCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLogTextCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* pTextCtrl0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&pTextCtrl0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pTextCtrl0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pTextCtrl0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pTextCtrl0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxSearchCtrl))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pTextCtrl0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxTextCtrl*) object_pointer0_0)\n");
				#endif
				_this = new wxLogTextCtrl_php((wxTextCtrl*) object_pointer0_0);

				((wxLogTextCtrl_php*) _this)->references.Initialize();
				((wxLogTextCtrl_php*) _this)->references.AddReference(pTextCtrl0);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxLogTextCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxLogTextCtrl_php*) _this)->evnArray);
		
		array_init(((wxLogTextCtrl_php*) _this)->evnArray);
		
		((wxLogTextCtrl_php*) _this)->phpObj = getThis();
		
		((wxLogTextCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxLogTextCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxLog_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLog_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxLog_php* object = static_cast<wxLog_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxLog done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxLog, AddTraceMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::AddTraceMask\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::AddTraceMask\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* mask0;
	long mask_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&mask0, &mask_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mask0, &mask_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::AddTraceMask(wxString(mask0, wxConvUTF8))\n\n");
				#endif
				wxLog::AddTraceMask(wxString(mask0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, ClearTraceMasks)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::ClearTraceMasks\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::ClearTraceMasks\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::ClearTraceMasks()\n\n");
				#endif
				wxLog::ClearTraceMasks();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, DisableTimestamp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::DisableTimestamp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::DisableTimestamp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::DisableTimestamp()\n\n");
				#endif
				wxLog::DisableTimestamp();


				return;
				break;
			}
		}
	}

		
}
void wxLog_php::DoLogText(const wxString& msg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxLog::DoLogText\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DoLogText", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	temp_string = (char*)malloc(sizeof(wxChar)*(msg.size()+1));
	strcpy(temp_string, (const char *) msg.char_str());
	ZVAL_STRING(arguments[0], temp_string, 1);
	free(temp_string);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxLog::DoLogText(msg);

}
void wxLog_php::DoLogTextAtLevel(wxLogLevel level, const wxString& msg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxLog::DoLogTextAtLevel\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DoLogTextAtLevel", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], level);
	temp_string = (char*)malloc(sizeof(wxChar)*(msg.size()+1));
	strcpy(temp_string, (const char *) msg.char_str());
	ZVAL_STRING(arguments[1], temp_string, 1);
	free(temp_string);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxLog::DoLogTextAtLevel(level, msg);

}
PHP_METHOD(php_wxLog, DontCreateOnDemand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::DontCreateOnDemand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::DontCreateOnDemand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::DontCreateOnDemand()\n\n");
				#endif
				wxLog::DontCreateOnDemand();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, EnableLogging)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::EnableLogging\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::EnableLogging\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxLog::EnableLogging())\n\n");
				#endif
				ZVAL_BOOL(return_value, wxLog::EnableLogging());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxLog::EnableLogging(enable0))\n\n");
				#endif
				ZVAL_BOOL(return_value, wxLog::EnableLogging(enable0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, Flush)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::Flush\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::Flush\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxLog::Flush()\n\n");
				#endif
				if(parent_rsrc_type == le_wxLogChain)
				{
					((wxLogChain_php*)_this)->Flush();
				}
				else if(parent_rsrc_type == le_wxLogInterposer)
				{
					((wxLogInterposer_php*)_this)->Flush();
				}
				else if(parent_rsrc_type == le_wxLogWindow)
				{
					((wxLogWindow_php*)_this)->Flush();
				}
				else if(parent_rsrc_type == le_wxLogTextCtrl)
				{
					((wxLogTextCtrl_php*)_this)->Flush();
				}
				else if(parent_rsrc_type == le_wxLog)
				{
					((wxLog_php*)_this)->Flush();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, FlushActive)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::FlushActive\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::FlushActive\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::FlushActive()\n\n");
				#endif
				wxLog::FlushActive();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, GetActiveTarget)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::GetActiveTarget\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::GetActiveTarget\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::GetActiveTarget() to return object pointer\n\n");
				#endif
				wxLog_php* value_to_return0;
				value_to_return0 = (wxLog_php*) wxLog::GetActiveTarget();
				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxLog_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxLog));
				}



				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, GetLogLevel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::GetLogLevel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::GetLogLevel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxLog::GetLogLevel())\n\n");
				#endif
				ZVAL_LONG(return_value, wxLog::GetLogLevel());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, GetRepetitionCounting)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::GetRepetitionCounting\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::GetRepetitionCounting\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxLog::GetRepetitionCounting())\n\n");
				#endif
				ZVAL_BOOL(return_value, wxLog::GetRepetitionCounting());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, GetTimestamp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::GetTimestamp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::GetTimestamp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxLog::GetTimestamp().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = wxLog::GetTimestamp();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, GetTraceMasks)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::GetTraceMasks\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::GetTraceMasks\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::GetTraceMasks() to return strings array\n\n");
				#endif
				wxArrayString value_to_return0;
				value_to_return0 = wxLog::GetTraceMasks();
				char* temp_string0;
				array_init(return_value);
				for(size_t i=0; i<value_to_return0.GetCount(); i++)
				{
					temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0[i].size()+1));
					strcpy (temp_string0, (const char *) value_to_return0[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string0, 1);
					free(temp_string0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, GetVerbose)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::GetVerbose\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::GetVerbose\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxLog::GetVerbose())\n\n");
				#endif
				ZVAL_BOOL(return_value, wxLog::GetVerbose());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, IsAllowedTraceMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::IsAllowedTraceMask\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::IsAllowedTraceMask\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* mask0;
	long mask_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&mask0, &mask_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mask0, &mask_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxLog::IsAllowedTraceMask(wxString(mask0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, wxLog::IsAllowedTraceMask(wxString(mask0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, IsEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::IsEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::IsEnabled\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxLog::IsEnabled())\n\n");
				#endif
				ZVAL_BOOL(return_value, wxLog::IsEnabled());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, IsLevelEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::IsLevelEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::IsLevelEnabled\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long level0;
	char* component0;
	long component_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&level0, &component0, &component_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &level0, &component0, &component_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxLog::IsLevelEnabled((wxLogLevel) level0, wxString(component0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, wxLog::IsLevelEnabled((wxLogLevel) level0, wxString(component0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, RemoveTraceMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::RemoveTraceMask\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::RemoveTraceMask\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* mask0;
	long mask_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&mask0, &mask_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mask0, &mask_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::RemoveTraceMask(wxString(mask0, wxConvUTF8))\n\n");
				#endif
				wxLog::RemoveTraceMask(wxString(mask0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, Resume)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::Resume\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::Resume\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::Resume()\n\n");
				#endif
				wxLog::Resume();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, SetActiveTarget)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::SetActiveTarget\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::SetActiveTarget\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* logtarget0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&logtarget0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &logtarget0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(logtarget0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(logtarget0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxLogBuffer && rsrc_type != le_wxLogChain && rsrc_type != le_wxLogInterposer && rsrc_type != le_wxLogWindow && rsrc_type != le_wxLogGui && rsrc_type != le_wxLogTextCtrl))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(logtarget0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetActiveTarget((wxLog*) object_pointer0_0) to return object pointer\n\n");
				#endif
				wxLog_php* value_to_return1;
				value_to_return1 = (wxLog_php*) wxLog::SetActiveTarget((wxLog*) object_pointer0_0);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxLog_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxLog));
				}



				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, SetComponentLevel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::SetComponentLevel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::SetComponentLevel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* component0;
	long component_len0;
	long level0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl' (&component0, &component_len0, &level0)\n");
		#endif
		char parse_parameters_string[] = "sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &component0, &component_len0, &level0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetComponentLevel(wxString(component0, wxConvUTF8), (wxLogLevel) level0)\n\n");
				#endif
				wxLog::SetComponentLevel(wxString(component0, wxConvUTF8), (wxLogLevel) level0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, SetLogLevel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::SetLogLevel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::SetLogLevel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long logLevel0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&logLevel0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &logLevel0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetLogLevel((wxLogLevel) logLevel0)\n\n");
				#endif
				wxLog::SetLogLevel((wxLogLevel) logLevel0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, SetRepetitionCounting)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::SetRepetitionCounting\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::SetRepetitionCounting\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool repetCounting0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&repetCounting0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &repetCounting0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetRepetitionCounting()\n\n");
				#endif
				wxLog::SetRepetitionCounting();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetRepetitionCounting(repetCounting0)\n\n");
				#endif
				wxLog::SetRepetitionCounting(repetCounting0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, SetThreadActiveTarget)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::SetThreadActiveTarget\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::SetThreadActiveTarget\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* logger0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&logger0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &logger0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(logger0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(logger0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxLogBuffer && rsrc_type != le_wxLogChain && rsrc_type != le_wxLogInterposer && rsrc_type != le_wxLogWindow && rsrc_type != le_wxLogGui && rsrc_type != le_wxLogTextCtrl))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(logger0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetThreadActiveTarget((wxLog*) object_pointer0_0) to return object pointer\n\n");
				#endif
				wxLog_php* value_to_return1;
				value_to_return1 = (wxLog_php*) wxLog::SetThreadActiveTarget((wxLog*) object_pointer0_0);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxLog_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxLog));
				}



				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, SetTimestamp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::SetTimestamp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::SetTimestamp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* format0;
	long format_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&format0, &format_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, &format_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetTimestamp(wxString(format0, wxConvUTF8))\n\n");
				#endif
				wxLog::SetTimestamp(wxString(format0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, SetVerbose)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::SetVerbose\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::SetVerbose\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool verbose0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&verbose0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &verbose0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetVerbose()\n\n");
				#endif
				wxLog::SetVerbose();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::SetVerbose(verbose0)\n\n");
				#endif
				wxLog::SetVerbose(verbose0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxLog, Suspend)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLog::Suspend\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxLog::Suspend\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxLog){
				references = &((wxLog_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogBuffer) && (!reference_type_found)){
				references = &((wxLogBuffer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogChain) && (!reference_type_found)){
				references = &((wxLogChain_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogInterposer) && (!reference_type_found)){
				references = &((wxLogInterposer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogWindow) && (!reference_type_found)){
				references = &((wxLogWindow_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogGui) && (!reference_type_found)){
				references = &((wxLogGui_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxLogTextCtrl) && (!reference_type_found)){
				references = &((wxLogTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxLog::Suspend()\n\n");
				#endif
				wxLog::Suspend();


				return;
				break;
			}
		}
	}

		
}
