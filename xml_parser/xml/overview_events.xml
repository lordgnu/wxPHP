<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.4">
  <compounddef id="overview_events" kind="page">
    <compoundname>overview_events</compoundname>
    <title>Events and Event Handling</title>
    <detaileddescription>
<para>Related classes: <ref refid="classwx_evt_handler" kindref="compound">wxEvtHandler</ref>, <ref refid="classwx_window" kindref="compound">wxWindow</ref>, <ref refid="classwx_event" kindref="compound">wxEvent</ref></para><para><itemizedlist>
<listitem><para><ref refid="overview_events_1overview_events_introduction" kindref="member">Introduction to Events</ref> </para></listitem>
<listitem><para><ref refid="overview_events_1overview_events_eventhandling" kindref="member">Event Handling</ref> </para></listitem>
<listitem><para><ref refid="overview_events_1overview_events_processing" kindref="member">How Events are Processed</ref> </para></listitem>
<listitem><para><ref refid="overview_events_1overview_events_custom" kindref="member">Custom Event Summary</ref> </para></listitem>
<listitem><para><ref refid="overview_events_1overview_events_misc" kindref="member">Miscellaneous Notes</ref></para></listitem>
</itemizedlist>
<hruler/>
</para><sect1 id="overview_events_1overview_events_introduction">
<title>Introduction to Events</title>
<para>Like with all the other GUI frameworks, the control of flow in wxWidgets applications is event-based: the program normally performs most of its actions in response to the events generated by the user. These events can be triggered by using the input devices (such as keyboard, mouse, joystick) directly or, more commonly, by a standard control which synthesizes such input events into higher level events: for example, a <ref refid="classwx_button" kindref="compound">wxButton</ref> can generate a click event when the user presses the left mouse button on it and then releases it without pressing <computeroutput>Esc</computeroutput> in the meanwhile. There are also events which don&apos;t directly correspond to the user actions, such as <ref refid="classwx_timer_event" kindref="compound">wxTimerEvent</ref> or <ref refid="classwx_socket_event" kindref="compound">wxSocketEvent</ref>.</para><para>But in all cases wxWidgets represents these events in a uniform way and allows you to handle them in the same way wherever they originate from. And while the events are normally generated by wxWidgets itself, you can also do this, which is especially useful when using custom events (see <ref refid="overview_events_1overview_events_custom" kindref="member">Custom Event Summary</ref>).</para><para>To be more precise, each event is described by:<itemizedlist>
<listitem><para><emphasis>Event type</emphasis>: this is simply a value of type wxEventType which uniquely identifies the type of the event. For example, clicking on a button, selecting an item from a list box and pressing a key on the keyboard all generate events with different event types.</para></listitem><listitem><para><emphasis>Event class</emphasis> carried by the event: each event has some information associated with it and this data is represented by an object of a class derived from <ref refid="classwx_event" kindref="compound">wxEvent</ref>. Events of different types can use the same event class, for example both button click and listbox selection events use <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref> class (as do all the other simple control events), but the key press event uses <ref refid="classwx_key_event" kindref="compound">wxKeyEvent</ref> as the information associated with it is different.</para></listitem><listitem><para><emphasis>Event source</emphasis>: <ref refid="classwx_event" kindref="compound">wxEvent</ref> stores the object which generated the event and, for windows, its identifier (see <ref refid="overview_events_1overview_events_winid" kindref="member">Window Identifiers</ref>). As it is common to have more than one object generating events of the same type (e.g. a typical window contains several buttons, all generating the same button click event), checking the event source object or its id allows to distinguish between them.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="overview_events_1overview_events_eventhandling">
<title>Event Handling</title>
<para>There are two principal ways to handle events in wxWidgets. One of them uses <emphasis>event table</emphasis> macros and allows you to define the binding between events and their handlers only statically, i.e., during program compilation. The other one uses <ref refid="classwx_evt_handler_1a84b1e446053bda8f76f13336839e8b64" kindref="member">wxEvtHandler::Bind&lt;&gt;()</ref> call and can be used to bind and unbind, the handlers dynamically, i.e. during run-time depending on some conditions. It also allows the direct binding of events to: <itemizedlist>
<listitem><para>A handler method in another object. </para></listitem>
<listitem><para>An ordinary function like a static method or a global function. </para></listitem>
<listitem><para>An arbitrary functor like boost::function&lt;&gt;.</para></listitem>
</itemizedlist>
The static event tables can only handle events in the object where they are defined so using Bind&lt;&gt;() is more flexible than using the event tables. On the other hand, event tables are more succinct and centralize all event handler bindings in one place. You can either choose a single approach that you find preferable or freely combine both methods in your program in different classes or even in one and the same class, although this is probably sufficiently confusing to be a bad idea.</para><para>Also notice that most of the existing wxWidgets tutorials and discussions use the event tables because they historically preceded the apparition of dynamic event handling in wxWidgets. But this absolutely doesn&apos;t mean that using the event tables is the preferred way: handling events dynamically is better in several aspects and you should strongly consider doing it if you are just starting with wxWidgets. On the other hand, you still need to know about the event tables if only because you are going to see them in many samples and examples.</para><para>So before you make the choice between static event tables and dynamically connecting the event handlers, let us discuss these two ways in more detail. In the next section we provide a short introduction to handling the events using the event tables. Please see <ref refid="overview_events_1overview_events_bind" kindref="member">Dynamic Event Handling</ref> for the discussion of Bind&lt;&gt;().</para><sect2 id="overview_events_1overview_events_eventtables">
<title>Event Handling with Event Tables</title>
<para>To use an <emphasis>event table</emphasis> you must first decide in which class you wish to handle the events. The only requirement imposed by wxWidgets is that this class must derive from <ref refid="classwx_evt_handler" kindref="compound">wxEvtHandler</ref> and so, considering that <ref refid="classwx_window" kindref="compound">wxWindow</ref> derives from it, any classes representing windows can handle events. Simple events such as menu commands are usually processed at the level of a top-level window containing the menu, so let&apos;s suppose that you need to handle some events in <computeroutput>MyFrame</computeroutput> class deriving from <ref refid="classwx_frame" kindref="compound">wxFrame</ref>.</para><para>First define one or more <emphasis>event handlers</emphasis>. They are just simple methods of the class that take as a parameter a reference to an object of a wxEvent-derived class and have no return value (any return information is passed via the argument, which is why it is non-const). You also need to insert a macro</para><para><programlisting><codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1gab6eca03fad44ec10b75d3cb82e9219e3" kindref="member" tooltip="Use this macro inside a class declaration to declare a static event table for that class...">wxDECLARE_EVENT_TABLE</ref>()</highlight></codeline>
</programlisting></para><para>somewhere in the class declaration. It doesn&apos;t matter where it appears but it&apos;s customary to put it at the end because the macro changes the access type internally so it&apos;s safest if nothing follows it. The full class declaration might look like this:</para><para><programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyFrame<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classwx_frame" kindref="compound" tooltip="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</ref></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MyFrame(...)<sp/>:<sp/><ref refid="classwx_frame" kindref="compound" tooltip="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</ref>(...)<sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>m_whatever;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Notice<sp/>that<sp/>as<sp/>the<sp/>event<sp/>handlers<sp/>normally<sp/>are<sp/>not<sp/>called<sp/>from<sp/>outside</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>class,<sp/>they<sp/>normally<sp/>are<sp/>private.<sp/>In<sp/>particular<sp/>they<sp/>don&apos;t<sp/>need</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>to<sp/>be<sp/>public.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnExit(<ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref>&amp;<sp/>event);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnButton1(<ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref>&amp;<sp/>event);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnSize(<ref refid="classwx_size_event" kindref="compound" tooltip="A size event holds information about size change events of wxWindow.">wxSizeEvent</ref>&amp;<sp/>event);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>it&apos;s<sp/>common<sp/>to<sp/>call<sp/>the<sp/>event<sp/>handlers<sp/>OnSomething()<sp/>but<sp/>there<sp/>is<sp/>no</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>obligation<sp/>to<sp/>do<sp/>that;<sp/>this<sp/>one<sp/>is<sp/>an<sp/>event<sp/>handler<sp/>too:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DoTest(<ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref>&amp;<sp/>event);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1gab6eca03fad44ec10b75d3cb82e9219e3" kindref="member" tooltip="Use this macro inside a class declaration to declare a static event table for that class...">wxDECLARE_EVENT_TABLE</ref>()</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>Next the event table must be defined and, as with any definition, it must be placed in an implementation file. The event table tells wxWidgets how to map events to member functions and in our example it could look like this:</para><para><programlisting><codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga736930efaab4d7e445e9e8e520c7b74d" kindref="member" tooltip="Use this macro in a source file to start listing static event handlers for a specific class...">wxBEGIN_EVENT_TABLE</ref>(MyFrame,<sp/><ref refid="classwx_frame" kindref="compound" tooltip="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EVT_MENU(<ref refid="defs_8h_1ac66d0a09761e7d86b2ac0b2e0c6a8cbba37f548d1211c664ede962e943baad4e5" kindref="member">wxID_EXIT</ref>,<sp/>MyFrame::OnExit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EVT_MENU(DO_TEST,<sp/>MyFrame::DoTest)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EVT_SIZE(MyFrame::OnSize)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EVT_BUTTON(BUTTON1,<sp/>MyFrame::OnButton1)</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga383fad2a46e1d6c220fbe03ecfbc9c17" kindref="member" tooltip="Use this macro in a source file to end listing static event handlers for a specific class...">wxEND_EVENT_TABLE</ref>()</highlight></codeline>
</programlisting></para><para>Notice that you must mention a method you want to use for the event handling in the event table definition; just defining it in MyFrame class is <emphasis>not</emphasis> enough.</para><para>Let us now look at the details of this definition: the first line means that we are defining the event table for MyFrame class and that its base class is <ref refid="classwx_frame" kindref="compound">wxFrame</ref>, so events not processed by MyFrame will, by default, be handled by <ref refid="classwx_frame" kindref="compound">wxFrame</ref>. The next four lines define bindings of individual events to their handlers: the first two of them map menu commands from the items with the identifiers specified as the first macro parameter to two different member functions. In the next one, <computeroutput>EVT_SIZE</computeroutput> means that any changes in the size of the frame will result in calling OnSize() method. Note that this macro doesn&apos;t need a window identifier, since normally you are only interested in the current window&apos;s size events.</para><para>The <computeroutput>EVT_BUTTON</computeroutput> macro demonstrates that the originating event does not have to come from the window class implementing the event table -- if the event source is a button within a panel within a frame, this will still work, because event tables are searched up through the hierarchy of windows for the command events. (But only command events, so you can&apos;t catch mouse move events in a child control in the parent window in the same way because <ref refid="classwx_mouse_event" kindref="compound">wxMouseEvent</ref> doesn&apos;t derive from <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref>. See below for how you can do it.) In this case, the button&apos;s event table will be searched, then the parent panel&apos;s, then the frame&apos;s.</para><para>Finally, you need to implement the event handlers. As mentioned before, all event handlers take a wxEvent-derived argument whose exact class differs according to the type of event and the class of the originating window. For size events, <ref refid="classwx_size_event" kindref="compound">wxSizeEvent</ref> is used. For menu commands and most control commands (such as button presses), <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref> is used. When controls get more complicated, more specific wxCommandEvent-derived event classes providing additional control-specific information can be used, such as <ref refid="classwx_tree_event" kindref="compound">wxTreeEvent</ref> for events from <ref refid="classwx_tree_ctrl" kindref="compound">wxTreeCtrl</ref> windows.</para><para>In the simplest possible case an event handler may not use the <computeroutput>event</computeroutput> parameter at all. For example,</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::OnExit(<ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref>&amp;<sp/>WXUNUSED(event))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>when<sp/>the<sp/>user<sp/>selects<sp/>&quot;Exit&quot;<sp/>from<sp/>the<sp/>menu<sp/>we<sp/>should<sp/>close</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Close(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>In other cases you may need some information carried by the <computeroutput>event</computeroutput> argument, as in:</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::OnSize(<ref refid="classwx_size_event" kindref="compound" tooltip="A size event holds information about size change events of wxWindow.">wxSizeEvent</ref>&amp;<sp/>event)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_size" kindref="compound" tooltip="A wxSize is a useful data structure for graphics operations.">wxSize</ref><sp/>size<sp/>=<sp/></highlight><highlight class="keyword">event</highlight><highlight class="normal">.GetSize();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...<sp/>update<sp/>the<sp/>frame<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>the<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>size<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>You will find the details about the event table macros and the corresponding wxEvent-derived classes in the discussion of each control generating these events.</para></sect2>
<sect2 id="overview_events_1overview_events_bind">
<title>Dynamic Event Handling</title>
<para><simplesect kind="see"><para><ref refid="overview_cpp_rtti_disabled" kindref="compound">Caveats When Not Using C++ RTTI</ref></para></simplesect>
The possibilities of handling events in this way are rather different. Let us start by looking at the syntax: the first obvious difference is that you need not use <ref refid="group__group__funcmacro__events_1gab6eca03fad44ec10b75d3cb82e9219e3" kindref="member">wxDECLARE_EVENT_TABLE()</ref> nor <ref refid="group__group__funcmacro__events_1ga736930efaab4d7e445e9e8e520c7b74d" kindref="member">wxBEGIN_EVENT_TABLE()</ref> and the associated macros. Instead, in any place in your code, but usually in the code of the class defining the handler itself (and definitely not in the global scope as with the event tables), call its Bind&lt;&gt;() method like this:</para><para><programlisting><codeline><highlight class="normal">MyFrame::MyFrame(...)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Bind(<ref refid="group__group__funcmacro__events_1ga5705afbf2885acba094565982b5f6407" kindref="member">wxEVT_COMMAND_MENU_SELECTED</ref>,<sp/>&amp;MyFrame::OnExit,<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>wxID_EXIT);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Note that <computeroutput>this</computeroutput> pointer must be specified here.</para><para>Now let us describe the semantic differences: <itemizedlist>
<listitem>
<para>Event handlers can be bound at any moment. For example, it&apos;s possible to do some initialization first and only bind the handlers if and when it succeeds. This can avoid the need to test that the object was properly initialized in the event handlers themselves. With Bind&lt;&gt;() they simply won&apos;t be called if it wasn&apos;t correctly initialized. </para><para></para></listitem>
<listitem>
<para>As a slight extension of the above, the handlers can also be unbound at any time with Unbind&lt;&gt;() (and maybe rebound later). Of course, it&apos;s also possible to emulate this behaviour with the classic static (i.e., bound via event tables) handlers by using an internal flag indicating whether the handler is currently enabled and returning from it if it isn&apos;t, but using dynamically bind handlers requires less code and is also usually more clear. </para><para></para></listitem>
<listitem>
<para>Almost last but very, very far from least is the increased flexibility which allows to bind an event to: <itemizedlist>
<listitem><para>A method in another object. </para></listitem>
<listitem><para>An ordinary function like a static method or a global function. </para></listitem>
<listitem><para>An arbitrary functor like boost::function&lt;&gt;.</para></listitem>
</itemizedlist>
This is impossible to do with the event tables because it is not possible to specify these handlers to dispatch the event to, so it necessarily needs to be sent to the same object which generated the event. Not so with Bind&lt;&gt;() which can be used to specify these handlers which will handle the event. To give a quick example, a common question is how to receive the mouse movement events happening when the mouse is in one of the frame children in the frame itself. Doing it in a naive way doesn&apos;t work: <itemizedlist>
<listitem>
<para>A <computeroutput>EVT_LEAVE_WINDOW(MyFrame::OnMouseLeave)</computeroutput> line in the frame event table has no effect as mouse move (including entering and leaving) events are not propagated up to the parent window (at least not by default). </para><para></para></listitem>
<listitem>
<para>Putting the same line in a child event table will crash during run-time because the MyFrame method will be called on a wrong object -- it&apos;s easy to convince oneself that the only object that can be used here is the pointer to the child, as wxWidgets has nothing else. But calling a frame method with the child window pointer instead of the pointer to the frame is, of course, disastrous.  </para></listitem>
</itemizedlist>
</para><para>However writing <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MyFrame::MyFrame(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_child-&gt;Bind(<ref refid="group__group__funcmacro__events_1ga51a2a26e560dade6d24f3f464a24fd73" kindref="member">wxEVT_LEAVE_WINDOW</ref>,<sp/>&amp;MyFrame::OnMouseLeave,<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting> will work exactly as expected. Note that you can get the object that generated the event -- and that is not the same as the frame -- via <ref refid="classwx_event_1abdc74e95c8c2f32f2cc2bd84b88985ee" kindref="member">wxEvent::GetEventObject()</ref> method of <computeroutput>event</computeroutput> argument passed to the event handler. </para><para></para></listitem>
<listitem>
<para>Really last point is the consequence of the previous one: because of increased flexibility of Bind(), it is also safer as it is impossible to accidentally use a method of another class. Instead of run-time crashes you will get compilation errors in this case when using Bind().  </para></listitem>
</itemizedlist>
</para><para>Let us now look at more examples of how to use different event handlers using the two overloads of Bind() function: first one for the object methods and the other one for arbitrary functors (callable objects, including simple functions):</para><para>In addition to using a method of the object generating the event itself, you can use a method from a completely different object as an event handler:</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrameHandler::OnFrameExit(<sp/><ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref><sp/>&amp;<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>something<sp/>useful.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFrameHandler<sp/>myFrameHandler;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFrame::MyFrame()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Bind(<sp/><ref refid="group__group__funcmacro__events_1ga5705afbf2885acba094565982b5f6407" kindref="member">wxEVT_COMMAND_MENU_SELECTED</ref>,<sp/>&amp;MyFrameHandler::OnFrameExit,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;myFrameHandler,<sp/>wxID_EXIT<sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Note that <computeroutput>MyFrameHandler</computeroutput> doesn&apos;t need to derive from <ref refid="classwx_evt_handler" kindref="compound">wxEvtHandler</ref>. But keep in mind that then the lifetime of <computeroutput>myFrameHandler</computeroutput> must be greater than that of <computeroutput>MyFrame</computeroutput> object -- or at least it needs to be unbound before being destroyed.</para><para>To use an ordinary function or a static method as an event handler you would write something like this:</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HandleExit(<sp/><ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref><sp/>&amp;<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>something<sp/>useful</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFrame::MyFrame()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bind(<sp/><ref refid="group__group__funcmacro__events_1ga5705afbf2885acba094565982b5f6407" kindref="member">wxEVT_COMMAND_MENU_SELECTED</ref>,<sp/>&amp;HandleExit,<sp/>wxID_EXIT<sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>And finally you can bind to an arbitrary functor and use it as an event handler:</para><para><programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MyFunctor</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(<sp/><ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref><sp/>&amp;<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>something<sp/>useful</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFunctor<sp/>myFunctor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFrame::MyFrame()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bind(<sp/><ref refid="group__group__funcmacro__events_1ga5705afbf2885acba094565982b5f6407" kindref="member">wxEVT_COMMAND_MENU_SELECTED</ref>,<sp/>&amp;myFunctor,<sp/>wxID_EXIT<sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>A common example of a functor is boost::function&lt;&gt;:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">boost;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyHandler::OnExit(<sp/><ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref><sp/>&amp;<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>something<sp/>useful</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyHandler<sp/>myHandler;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFrame::MyFrame()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>function&lt;<sp/>void<sp/>(<sp/>wxCommandEvent<sp/>&amp;<sp/>)<sp/>&gt;<sp/>exitHandler(<sp/>bind(<sp/>&amp;MyHandler::OnExit,<sp/>&amp;myHandler,<sp/>_1<sp/>));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bind(<sp/><ref refid="group__group__funcmacro__events_1ga5705afbf2885acba094565982b5f6407" kindref="member">wxEVT_COMMAND_MENU_SELECTED</ref>,<sp/>exitHandler,<sp/>wxID_EXIT<sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>With the aid of boost::bind&lt;&gt;() you can even use methods or functions which don&apos;t quite have the correct signature:</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyHandler::OnExit(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>exitCode,<sp/><ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref><sp/>&amp;,<sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>goodByeMessage<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>something<sp/>useful</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyHandler<sp/>myHandler;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFrame::MyFrame()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>function&lt;<sp/>void<sp/>(<sp/>wxCommandEvent<sp/>&amp;<sp/>)<sp/>&gt;<sp/>exitHandler(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bind(<sp/>&amp;MyHandler::OnExit,<sp/>&amp;myHandler,<sp/>EXIT_FAILURE,<sp/>_1,<sp/></highlight><highlight class="stringliteral">&quot;Bye&quot;</highlight><highlight class="normal"><sp/>));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bind(<sp/><ref refid="group__group__funcmacro__events_1ga5705afbf2885acba094565982b5f6407" kindref="member">wxEVT_COMMAND_MENU_SELECTED</ref>,<sp/>exitHandler,<sp/>wxID_EXIT<sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>To summarize, using Bind&lt;&gt;() requires slightly more typing but is much more flexible than using static event tables so don&apos;t hesitate to use it when you need this extra power. On the other hand, event tables are still perfectly fine in simple situations where this extra flexibility is not needed.</para></sect2>
</sect1>
<sect1 id="overview_events_1overview_events_processing">
<title>How Events are Processed</title>
<para>The previous sections explain how to define event handlers but don&apos;t address the question of how exactly wxWidgets finds the handler to call for the given event. This section describes the algorithm used in detail. Notice that you may want to run the <ref refid="page_samples_1page_samples_event" kindref="member">Event Sample</ref> while reading this section and look at its code and the output when the button which can be used to test the event handlers execution order is clicked to understand it better.</para><para>When an event is received from the windowing system, wxWidgets calls <ref refid="classwx_evt_handler_1a65968dd27f3aac7718f2dd6b2ddd5a08" kindref="member">wxEvtHandler::ProcessEvent()</ref> on the first event handler object belonging to the window generating the event. The normal order of event table searching by ProcessEvent() is as follows, with the event processing stopping as soon as a handler is found (unless the handler calls <ref refid="classwx_event_1a98eb20b76106f9a933c2eb3ee119f66c" kindref="member">wxEvent::Skip()</ref> in which case it doesn&apos;t count as having handled the event and the search continues): <orderedlist>
<listitem>
<para>Before anything else happens, <ref refid="classwx_app_console_1ada7ab606e014a10d46e4b3c6f602e20c" kindref="member">wxApp::FilterEvent()</ref> is called. If it returns anything but -1 (default), the event handling stops immediately. </para><para></para></listitem>
<listitem>
<para>If this event handler is disabled via a call to <ref refid="classwx_evt_handler_1a7388ae19c8657e5656471b658c320036" kindref="member">wxEvtHandler::SetEvtHandlerEnabled()</ref> the next three steps are skipped and the event handler resumes at step (5). </para><para></para></listitem>
<listitem>
<para>If the object is a <ref refid="classwx_window" kindref="compound">wxWindow</ref> and has an associated validator, <ref refid="classwx_validator" kindref="compound">wxValidator</ref> gets a chance to process the event. </para><para></para></listitem>
<listitem>
<para>The list of dynamically bound event handlers, i.e., those for which Bind&lt;&gt;() was called, is consulted. Notice that this is done before checking the static event table entries, so if both a dynamic and a static event handler match the same event, the static one is never going to be used unless <ref refid="classwx_event_1a98eb20b76106f9a933c2eb3ee119f66c" kindref="member">wxEvent::Skip()</ref> is called in the dynamic one. </para><para></para></listitem>
<listitem>
<para>The event table containing all the handlers defined using the event table macros in this class and its base classes is examined. Notice that this means that any event handler defined in a base class will be executed at this step. </para><para></para></listitem>
<listitem>
<para>The event is passed to the next event handler, if any, in the event handler chain, i.e., the steps (1) to (4) are done for it. Usually there is no next event handler so the control passes to the next step but see <ref refid="overview_events_1overview_events_nexthandler" kindref="member">Event Handlers Chain</ref> for how the next handler may be defined. </para><para></para></listitem>
<listitem>
<para>If the object is a <ref refid="classwx_window" kindref="compound">wxWindow</ref> and the event is set to propagate (by default only wxCommandEvent-derived events are set to propagate), then the processing restarts from the step (1) (and excluding the step (7)) for the parent window. If this object is not a window but the next handler exists, the event is passed to its parent if it is a window. This ensures that in a common case of (possibly several) non-window event handlers pushed on top of a window, the event eventually reaches the window parent. </para><para></para></listitem>
<listitem>
<para>Finally, i.e., if the event is still not processed, the <ref refid="classwx_app" kindref="compound">wxApp</ref> object itself (which derives from <ref refid="classwx_evt_handler" kindref="compound">wxEvtHandler</ref>) gets a last chance to process it.  </para></listitem>
</orderedlist>
</para><para><emphasis>Please pay close attention to step 6!</emphasis> People often overlook or get confused by this powerful feature of the wxWidgets event processing system. The details of event propagation up the window hierarchy are described in the next section.</para><para>Also please notice that there are additional steps in the event handling for the windows-making part of wxWidgets document-view framework, i.e., <ref refid="classwx_doc_parent_frame" kindref="compound">wxDocParentFrame</ref>, <ref refid="classwx_doc_child_frame" kindref="compound">wxDocChildFrame</ref> and their MDI equivalents <ref refid="classwx_doc_m_d_i_parent_frame" kindref="compound">wxDocMDIParentFrame</ref> and <ref refid="classwx_doc_m_d_i_child_frame" kindref="compound">wxDocMDIChildFrame</ref>. The parent frame classes modify step (2) above to send the events received by them to <ref refid="classwx_doc_manager" kindref="compound">wxDocManager</ref> object first. This object, in turn, sends the event to the current view and the view itself lets its associated document process the event first. The child frame classes send the event directly to the associated view which still forwards it to its document object. Notice that to avoid remembering the exact order in which the events are processed in the document-view frame, the simplest, and recommended, solution is to only handle the events at the view classes level, and not in the document or document manager classes</para><sect2 id="overview_events_1overview_events_propagation">
<title>How Events Propagate Upwards</title>
<para>As mentioned above, the events of the classes deriving from <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref> are propagated by default to the parent window if they are not processed in this window itself. But although by default only the command events are propagated like this, other events can be propagated as well because the event handling code uses <ref refid="classwx_event_1ad265ef226445cb6b72a2697dd9d3b406" kindref="member">wxEvent::ShouldPropagate()</ref> to check whether an event should be propagated. It is also possible to propagate the event only a limited number of times and not until it is processed (or a top level parent window is reached).</para><para>Finally, there is another additional complication (which, in fact, simplifies life of wxWidgets programmers significantly): when propagating the command events up to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don&apos;t risk getting unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn&apos;t care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be difficult, if not impossible, to track down all the dialogs that may be popped up in a complex program (remember that some are created automatically by wxWidgets). If you need to specify a different behaviour for some reason, you can use <computeroutput>wxWindow::SetExtraStyle(wxWS_EX_BLOCK_EVENTS)</computeroutput> explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs that have it on by default.</para><para>Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning or are generated by the window itself (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event. More precisely, as said above, all event classes <bold>not</bold> deriving from <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref> (see the <ref refid="classwx_event" kindref="compound">wxEvent</ref> inheritance map) do <bold>not</bold> propagate upward.</para><para>In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override ProcessEvent() in order to pass all events (or any selection of them) to the parent window.</para></sect2>
<sect2 id="overview_events_1overview_events_nexthandler">
<title>Event Handlers Chain</title>
<para>The step 4 of the event propagation algorithm checks for the next handler in the event handler chain. This chain can be formed using <ref refid="classwx_evt_handler_1a68e2ef2d2b7d68c4c9c18ca92933031b" kindref="member">wxEvtHandler::SetNextHandler()</ref>: <image type="html" name="overview_events_chain.png"></image>
 (referring to the image, if <computeroutput>A-&gt;ProcessEvent</computeroutput> is called and it doesn&apos;t handle the event, <computeroutput>B-&gt;ProcessEvent</computeroutput> will be called and so on...).</para><para>Additionally, in the case of <ref refid="classwx_window" kindref="compound">wxWindow</ref> you can build a stack (implemented using <ref refid="classwx_evt_handler" kindref="compound">wxEvtHandler</ref> double-linked list) using <ref refid="classwx_window_1a398c11ab9af7956067a964f560d1978c" kindref="member">wxWindow::PushEventHandler()</ref>: <image type="html" name="overview_events_winstack.png"></image>
 (referring to the image, if <computeroutput>W-&gt;ProcessEvent</computeroutput> is called, it immediately calls <computeroutput>A-&gt;ProcessEvent</computeroutput>; if nor <computeroutput>A</computeroutput> nor <computeroutput>B</computeroutput> handle the event, then the <ref refid="classwx_window" kindref="compound">wxWindow</ref> itself is used -- i.e. the dynamically bind event handlers and static event table entries of <ref refid="classwx_window" kindref="compound">wxWindow</ref> are looked as the last possibility, after all pushed event handlers were tested).</para><para>By default the chain is empty, i.e. there is no next handler.</para></sect2>
</sect1>
<sect1 id="overview_events_1overview_events_custom">
<title>Custom Event Summary</title>
<sect2 id="overview_events_1overview_events_custom_general">
<title>General approach</title>
<para>As each event is uniquely defined by its event type, defining a custom event starts with defining a new event type for it. This is done using <ref refid="group__group__funcmacro__events_1ga09ec1d095bee3085c1cb31459b46bc00" kindref="member">wxDEFINE_EVENT()</ref> macro. As an event type is a variable, it can also be declared using <ref refid="group__group__funcmacro__events_1ga767b12d37f7370bc5f6b3d62340f3ef8" kindref="member">wxDECLARE_EVENT()</ref> if necessary.</para><para>The next thing to do is to decide whether you need to define a custom event class for events of this type or if you can reuse an existing class, typically either <ref refid="classwx_event" kindref="compound">wxEvent</ref> (which doesn&apos;t provide any extra information) or <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref> (which contains several extra fields and also propagates upwards by default). Both strategies are described in details below. See also the <ref refid="page_samples_1page_samples_event" kindref="member">Event Sample</ref> for a complete example of code defining and working with the custom event types.</para><para>Finally, you will need to generate and post your custom events. Generation is as simple as instancing your custom event class and initializing its internal fields. For posting events to a certain event handler there are two possibilities: using <ref refid="classwx_evt_handler_1a0737c6d2cbcd5ded4b1ecdd53ed0def3" kindref="member">wxEvtHandler::AddPendingEvent</ref> or using <ref refid="classwx_evt_handler_1acffd03bf407a856166ea71ef0318b59a" kindref="member">wxEvtHandler::QueueEvent</ref>. Basically you will need to use the latter when doing inter-thread communication; when you use only the main thread you can also safely use the former. Last, note that there are also two simple global wrapper functions associated to the two <ref refid="classwx_evt_handler" kindref="compound">wxEvtHandler</ref> mentioned functions: <ref refid="group__group__funcmacro__events_1ga0cf60a1ad3a5f1e659f7ae591570f58d" kindref="member">wxPostEvent()</ref> and <ref refid="group__group__funcmacro__events_1gae921d7bd0e52fedbf3f253d2c408bce1" kindref="member">wxQueueEvent()</ref>.</para></sect2>
<sect2 id="overview_events_1overview_events_custom_existing">
<title>Using Existing Event Classes</title>
<para>If you just want to use a <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref> with a new event type, use one of the generic event table macros listed below, without having to define a new event class yourself.</para><para>Example:</para><para><programlisting><codeline><highlight class="comment">//<sp/>this<sp/>is<sp/>typically<sp/>in<sp/>a<sp/>header:<sp/>it<sp/>just<sp/>declares<sp/>MY_EVENT<sp/>event<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga767b12d37f7370bc5f6b3d62340f3ef8" kindref="member" tooltip="Declares a custom event type.">wxDECLARE_EVENT</ref>(MY_EVENT,<sp/><ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>a<sp/>definition<sp/>so<sp/>can&apos;t<sp/>be<sp/>in<sp/>a<sp/>header</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga09ec1d095bee3085c1cb31459b46bc00" kindref="member" tooltip="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</ref>(MY_EVENT,<sp/><ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>of<sp/>code<sp/>handling<sp/>the<sp/>event<sp/>with<sp/>event<sp/>tables</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga736930efaab4d7e445e9e8e520c7b74d" kindref="member" tooltip="Use this macro in a source file to start listing static event handlers for a specific class...">wxBEGIN_EVENT_TABLE</ref>(MyFrame,<sp/><ref refid="classwx_frame" kindref="compound" tooltip="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EVT_MENU<sp/><sp/><sp/><sp/>(wxID_EXIT,<sp/>MyFrame::OnExit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EVT_COMMAND<sp/>(ID_MY_WINDOW,<sp/>MY_EVENT,<sp/>MyFrame::OnMyEvent)</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga383fad2a46e1d6c220fbe03ecfbc9c17" kindref="member" tooltip="Use this macro in a source file to end listing static event handlers for a specific class...">wxEND_EVENT_TABLE</ref>()</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::OnMyEvent(<ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref>&amp;<sp/>event)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>text<sp/>=<sp/></highlight><highlight class="keyword">event</highlight><highlight class="normal">.GetString();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>of<sp/>code<sp/>handling<sp/>the<sp/>event<sp/>with<sp/>Bind&lt;&gt;():</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFrame::MyFrame()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bind(MY_EVENT,<sp/>&amp;MyFrame::OnMyEvent,<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>ID_MY_WINDOW);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>of<sp/>code<sp/>generating<sp/>the<sp/>event</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyWindow::SendEvent()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_command_event" kindref="compound" tooltip="This event class contains information about command events, which originate from a variety of simple ...">wxCommandEvent</ref><sp/>event(MY_EVENT,<sp/>GetId());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">event</highlight><highlight class="normal">.SetEventObject(</highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Give<sp/>it<sp/>some<sp/>contents</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">event</highlight><highlight class="normal">.SetString(</highlight><highlight class="stringliteral">&quot;Hello&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>send<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ProcessWindowEvent(event);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="overview_events_1overview_events_custom_ownclass">
<title>Defining Your Own Event Class</title>
<para>Under certain circumstances, you must define your own event class e.g., for sending more complex data from one place to another. Apart from defining your event class, you also need to define your own event table macro if you want to use event tables for handling events of this type.</para><para>Here is an example:</para><para><programlisting><codeline><highlight class="comment">//<sp/>define<sp/>a<sp/>new<sp/>event<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyPlotEvent:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classwx_event" kindref="compound" tooltip="An event is a structure holding information about an event passed to a callback or member function...">wxEvent</ref></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MyPlotEvent(<ref refid="group__group__funcmacro__events_1ga6a7fd172612c0d6d9029bfa3aa91aca0" kindref="member" tooltip="A value uniquely identifying the type of the event.">wxEventType</ref><sp/>eventType,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>winid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classwx_point" kindref="compound" tooltip="A wxPoint is a useful data structure for graphics operations.">wxPoint</ref>&amp;<sp/>pos)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><ref refid="classwx_event" kindref="compound" tooltip="An event is a structure holding information about an event passed to a callback or member function...">wxEvent</ref>(winid,<sp/>eventType),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pos(pos)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>accessors</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_point" kindref="compound" tooltip="A wxPoint is a useful data structure for graphics operations.">wxPoint</ref><sp/>GetPoint()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pos;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>implement<sp/>the<sp/>base<sp/>class<sp/>pure<sp/>virtual</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/><ref refid="classwx_event" kindref="compound" tooltip="An event is a structure holding information about an event passed to a callback or member function...">wxEvent</ref><sp/>*<ref refid="classwx_event_1a26878097a702e8d0368da150125d4158" kindref="member" tooltip="Returns a copy of the event.">Clone</ref>()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>MyPlotEvent(*</highlight><highlight class="keyword">this</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classwx_point" kindref="compound" tooltip="A wxPoint is a useful data structure for graphics operations.">wxPoint</ref><sp/>m_pos;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>we<sp/>define<sp/>a<sp/>single<sp/>MY_PLOT_CLICKED<sp/>event<sp/>type<sp/>associated<sp/>with<sp/>the<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>above<sp/>but<sp/>typically<sp/>you<sp/>are<sp/>going<sp/>to<sp/>have<sp/>more<sp/>than<sp/>one<sp/>event<sp/>type,<sp/>e.g.<sp/>you</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>could<sp/>also<sp/>have<sp/>MY_PLOT_ZOOMED<sp/>or<sp/>MY_PLOT_PANNED<sp/>&amp;c<sp/>--<sp/>in<sp/>which<sp/>case<sp/>you</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>would<sp/>just<sp/>add<sp/>more<sp/>similar<sp/>lines<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga09ec1d095bee3085c1cb31459b46bc00" kindref="member" tooltip="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</ref>(MY_PLOT_CLICKED,<sp/>MyPlotEvent);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>if<sp/>you<sp/>want<sp/>to<sp/>support<sp/>old<sp/>compilers<sp/>you<sp/>need<sp/>to<sp/>use<sp/>some<sp/>ugly<sp/>macros:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(<ref refid="classwx_evt_handler" kindref="compound" tooltip="A class that can handle events from the windowing system.">wxEvtHandler</ref>::*MyPlotEventFunction)(MyPlotEvent&amp;);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MyPlotEventHandler(func)<sp/>wxEVENT_HANDLER_CAST(MyPlotEventFunction,<sp/>func)</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>if<sp/>your<sp/>code<sp/>is<sp/>only<sp/>built<sp/>using<sp/>reasonably<sp/>modern<sp/>compilers,<sp/>you<sp/>could<sp/>just</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>this<sp/>instead:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MyPlotEventHandler(func)<sp/>(&amp;func)</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>finally<sp/>define<sp/>a<sp/>macro<sp/>for<sp/>creating<sp/>the<sp/>event<sp/>table<sp/>entries<sp/>for<sp/>the<sp/>new</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>event<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>remember<sp/>that<sp/>you<sp/>don&apos;t<sp/>need<sp/>this<sp/>at<sp/>all<sp/>if<sp/>you<sp/>only<sp/>use<sp/>Bind&lt;&gt;()<sp/>and<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>you<sp/>can<sp/>replace<sp/>MyPlotEventHandler(func)<sp/>with<sp/>just<sp/>&amp;func<sp/>unless<sp/>you<sp/>use<sp/>a</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>really<sp/>old<sp/>compiler</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MY_EVT_PLOT_CLICK(id,<sp/>func)<sp/>\</highlight></codeline>
<codeline><highlight class="preprocessor"><sp/><sp/><sp/><sp/>wx__DECLARE_EVT1(MY_PLOT_CLICKED,<sp/>id,<sp/>MyPlotEventHandler(func))</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>of<sp/>code<sp/>handling<sp/>the<sp/>event<sp/>(you<sp/>will<sp/>use<sp/>one<sp/>of<sp/>these<sp/>methods,<sp/>not</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>both,<sp/>of<sp/>course):</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga736930efaab4d7e445e9e8e520c7b74d" kindref="member" tooltip="Use this macro in a source file to start listing static event handlers for a specific class...">wxBEGIN_EVENT_TABLE</ref>(MyFrame,<sp/><ref refid="classwx_frame" kindref="compound" tooltip="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EVT_PLOT(ID_MY_WINDOW,<sp/>MyFrame::OnPlot)</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__funcmacro__events_1ga383fad2a46e1d6c220fbe03ecfbc9c17" kindref="member" tooltip="Use this macro in a source file to end listing static event handlers for a specific class...">wxEND_EVENT_TABLE</ref>()</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyFrame::MyFrame()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bind(MY_PLOT_CLICKED,<sp/>&amp;MyFrame::OnPlot,<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>ID_MY_WINDOW);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::OnPlot(MyPlotEvent&amp;<sp/>event)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...<sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>something<sp/>with<sp/></highlight><highlight class="keyword">event</highlight><highlight class="normal">.GetPoint()<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>of<sp/>code<sp/>generating<sp/>the<sp/>event:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyWindow::SendEvent()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MyPlotEvent<sp/>event(MY_PLOT_CLICKED,<sp/>GetId(),<sp/><ref refid="classwx_point" kindref="compound" tooltip="A wxPoint is a useful data structure for graphics operations.">wxPoint</ref>(...));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">event</highlight><highlight class="normal">.SetEventObject(</highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ProcessWindowEvent(event);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="overview_events_1overview_events_misc">
<title>Miscellaneous Notes</title>
<sect2 id="overview_events_1overview_events_virtual">
<title>Event Handlers vs Virtual Methods</title>
<para>It may be noted that wxWidgets&apos; event processing system implements something close to virtual methods in normal C++ in spirit: both of these mechanisms allow you to alter the behaviour of the base class by defining the event handling functions in the derived classes.</para><para>There is however an important difference between the two mechanisms when you want to invoke the default behaviour, as implemented by the base class, from a derived class handler. With the virtual functions, you need to call the base class function directly and you can do it either in the beginning of the derived class handler function (to post-process the event) or at its end (to pre-process the event). With the event handlers, you only have the option of pre-processing the events and in order to still let the default behaviour happen you must call <ref refid="classwx_event_1a98eb20b76106f9a933c2eb3ee119f66c" kindref="member">wxEvent::Skip()</ref> and <emphasis>not</emphasis> call the base class event handler directly. In fact, the event handler probably doesn&apos;t even exist in the base class as the default behaviour is often implemented in platform-specific code by the underlying toolkit or OS itself. But even if it does exist at wxWidgets level, it should never be called directly as the event handlers are not part of wxWidgets API and should never be called directly.</para></sect2>
<sect2 id="overview_events_1overview_events_prog">
<title>User Generated Events vs Programmatically Generated Events</title>
<para>While generically wxEvents can be generated both by user actions (e.g., resize of a <ref refid="classwx_window" kindref="compound">wxWindow</ref>) and by calls to functions (e.g., <ref refid="classwx_window_1a180312d5ad4a4a5ad805b8d52d67a74e" kindref="member">wxWindow::SetSize</ref>), wxWidgets controls normally send wxCommandEvent-derived events only for the user-generated events. The only <bold>exceptions</bold> to this rule are:</para><para><itemizedlist>
<listitem><para><ref refid="classwx_book_ctrl_base_1ab47f8935c3705a452fce7d292d8181dd" kindref="member">wxNotebook::AddPage</ref>: No event-free alternatives </para></listitem>
<listitem><para><ref refid="classwx_book_ctrl_base_1a8b5b18fbf0281e99d227e574b5ffc1ac" kindref="member">wxNotebook::AdvanceSelection</ref>: No event-free alternatives </para></listitem>
<listitem><para><ref refid="classwx_book_ctrl_base_1a7cbc19f60daf15af7019de20561b29f4" kindref="member">wxNotebook::DeletePage</ref>: No event-free alternatives </para></listitem>
<listitem><para><ref refid="classwx_notebook_1a140d1743bc93c3aff36fe2c9f1cb2bc8" kindref="member">wxNotebook::SetSelection</ref>: Use <ref refid="classwx_notebook_1a82c7c7a09de4f4ec17c92af0753235d6" kindref="member">wxNotebook::ChangeSelection</ref> instead, as <ref refid="classwx_notebook_1a140d1743bc93c3aff36fe2c9f1cb2bc8" kindref="member">wxNotebook::SetSelection</ref> is deprecated </para></listitem>
<listitem><para><ref refid="classwx_tree_ctrl_1a53a2292e2b7b6c13ba3e2d542d8bc1d2" kindref="member">wxTreeCtrl::Delete</ref>: No event-free alternatives </para></listitem>
<listitem><para><ref refid="classwx_tree_ctrl_1a76de2019d0fcc73f4c302dff5d392c66" kindref="member">wxTreeCtrl::DeleteAllItems</ref>: No event-free alternatives </para></listitem>
<listitem><para><ref refid="classwx_tree_ctrl_1a08d88a76e02f59001766bc90e20016b7" kindref="member">wxTreeCtrl::EditLabel</ref>: No event-free alternatives </para></listitem>
<listitem><para>All <ref refid="classwx_text_ctrl" kindref="compound">wxTextCtrl</ref> methods</para></listitem>
</itemizedlist>
<ref refid="classwx_text_entry_1a8c52ab71f51c8f80556c2c8e763cbca1" kindref="member">wxTextCtrl::ChangeValue</ref> can be used instead of <ref refid="classwx_text_entry_1a90f876b2dd83ba5c97ba0c193b386e9f" kindref="member">wxTextCtrl::SetValue</ref> but the other functions, such as <ref refid="classwx_text_entry_1a1fb3ac76d270b2c64cff595497815f8d" kindref="member">wxTextCtrl::Replace</ref> or <ref refid="classwx_text_entry_1aa1b9419f95878c44234ff812b528c17b" kindref="member">wxTextCtrl::WriteText</ref> don&apos;t have event-free equivalents.</para></sect2>
<sect2 id="overview_events_1overview_events_pluggable">
<title>Pluggable Event Handlers</title>
<para><emphasis>TODO: Probably deprecated, Bind() provides a better way to do this</emphasis></para><para>In fact, you don&apos;t have to derive a new class from a window class if you don&apos;t want to. You can derive a new class from <ref refid="classwx_evt_handler" kindref="compound">wxEvtHandler</ref> instead, defining the appropriate event table, and then call <ref refid="classwx_window_1af6c84b7679183b377ba27a52a2f708b4" kindref="member">wxWindow::SetEventHandler</ref> (or, preferably, <ref refid="classwx_window_1a398c11ab9af7956067a964f560d1978c" kindref="member">wxWindow::PushEventHandler</ref>) to make this event handler the object that responds to events. This way, you can avoid a lot of class derivation, and use instances of the same event handler class (but different objects as the same event handler object shouldn&apos;t be used more than once) to handle events from instances of different widget classes.</para><para>If you ever have to call a window&apos;s event handler manually, use the GetEventHandler function to retrieve the window&apos;s event handler and use that to call the member function. By default, GetEventHandler returns a pointer to the window itself unless an application has redirected event handling using SetEventHandler or PushEventHandler.</para><para>One use of PushEventHandler is to temporarily or permanently change the behaviour of the GUI. For example, you might want to invoke a dialog editor in your application that changes aspects of dialog boxes. You can grab all the input for an existing dialog box, and edit it &apos;in situ&apos;, before restoring its behaviour to normal. So even if the application has derived new classes to customize behaviour, your utility can indulge in a spot of body-snatching. It could be a useful technique for on-line tutorials, too, where you take a user through a serious of steps and don&apos;t want them to diverge from the lesson. Here, you can examine the events coming from buttons and windows, and if acceptable, pass them through to the original event handler. Use PushEventHandler/PopEventHandler to form a chain of event handlers, where each handler processes a different range of events independently from the other handlers.</para></sect2>
<sect2 id="overview_events_1overview_events_winid">
<title>Window Identifiers</title>
<para>Window identifiers are integers, and are used to uniquely determine window identity in the event system (though you can use it for other purposes). In fact, identifiers do not need to be unique across your entire application as long they are unique within the particular context you&apos;re interested in, such as a frame and its children. You may use the <computeroutput>wxID_OK</computeroutput> identifier, for example, on any number of dialogs as long as you don&apos;t have several within the same dialog.</para><para>If you pass <computeroutput>wxID_ANY</computeroutput> to a window constructor, an identifier will be generated for you automatically by wxWidgets. This is useful when you don&apos;t care about the exact identifier either because you&apos;re not going to process the events from the control being created or because you process the events from all controls in one place (in which case you should specify <computeroutput>wxID_ANY</computeroutput> in the event table or <ref refid="classwx_evt_handler_1a84b1e446053bda8f76f13336839e8b64" kindref="member">wxEvtHandler::Bind</ref> call as well). The automatically generated identifiers are always negative and so will never conflict with the user-specified identifiers which must be always positive.</para><para>See <ref refid="page_stdevtid" kindref="compound">Standard event identifiers</ref> for the list of standard identifiers available. You can use wxID_HIGHEST to determine the number above which it is safe to define your own identifiers. Or, you can use identifiers below wxID_LOWEST. Finally, you can allocate identifiers dynamically using <ref refid="group__group__funcmacro__misc_1gaef162e1ba5d17a839b2f7912424bc822" kindref="member">wxNewId()</ref> function too. If you use <ref refid="group__group__funcmacro__misc_1gaef162e1ba5d17a839b2f7912424bc822" kindref="member">wxNewId()</ref> consistently in your application, you can be sure that your identifiers don&apos;t conflict accidentally.</para></sect2>
<sect2 id="overview_events_1overview_events_custom_generic">
<title>Generic Event Table Macros</title>
<para><table rows="6" cols="2"><row>
<entry thead="no"><para>EVT_CUSTOM(event, id, func) </para></entry><entry thead="no"><para>Allows you to add a custom event table entry by specifying the event identifier (such as wxEVT_SIZE), the window identifier, and a member function to call. </para></entry></row>
<row>
<entry thead="no"><para>EVT_CUSTOM_RANGE(event, id1, id2, func) </para></entry><entry thead="no"><para>The same as EVT_CUSTOM, but responds to a range of window identifiers. </para></entry></row>
<row>
<entry thead="no"><para>EVT_COMMAND(id, event, func) </para></entry><entry thead="no"><para>The same as EVT_CUSTOM, but expects a member function with a <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref> argument. </para></entry></row>
<row>
<entry thead="no"><para>EVT_COMMAND_RANGE(id1, id2, event, func) </para></entry><entry thead="no"><para>The same as EVT_CUSTOM_RANGE, but expects a member function with a <ref refid="classwx_command_event" kindref="compound">wxCommandEvent</ref> argument. </para></entry></row>
<row>
<entry thead="no"><para>EVT_NOTIFY(event, id, func) </para></entry><entry thead="no"><para>The same as EVT_CUSTOM, but expects a member function with a <ref refid="classwx_notify_event" kindref="compound">wxNotifyEvent</ref> argument. </para></entry></row>
<row>
<entry thead="no"><para>EVT_NOTIFY_RANGE(event, id1, id2, func) </para></entry><entry thead="no"><para>The same as EVT_CUSTOM_RANGE, but expects a member function with a <ref refid="classwx_notify_event" kindref="compound">wxNotifyEvent</ref> argument. </para></entry></row>
</table>
</para></sect2>
<sect2 id="overview_events_1overview_events_list">
<title>List of wxWidgets events</title>
<para>For the full list of event classes, please see the <ref refid="group__group__class__events" kindref="compound">event classes group page</ref>. </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
