<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.4">
  <compounddef id="overview_datetime" kind="page">
    <compoundname>overview_datetime</compoundname>
    <title>Date and Time</title>
    <detaileddescription>
<para>Classes: <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref>, <ref refid="classwx_date_span" kindref="compound">wxDateSpan</ref>, <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref>, <ref refid="classwx_calendar_ctrl" kindref="compound">wxCalendarCtrl</ref></para><para><itemizedlist>
<listitem><para><ref refid="overview_datetime_1overview_datetime_introduction" kindref="member">Introduction</ref> </para></listitem>
<listitem><para><ref refid="overview_datetime_1overview_datetime_classes" kindref="member">All date/time classes at a glance</ref> </para></listitem>
<listitem><para><ref refid="overview_datetime_1overview_datetime_characteristics" kindref="member">wxDateTime characteristics</ref> </para></listitem>
<listitem><para><ref refid="overview_datetime_1overview_datetime_timespandiff" kindref="member">Difference between wxDateSpan and wxTimeSpan</ref> </para></listitem>
<listitem><para><ref refid="overview_datetime_1overview_datetime_arithmetics" kindref="member">Date arithmetics</ref> </para></listitem>
<listitem><para><ref refid="overview_datetime_1overview_datetime_timezones" kindref="member">Time zone considerations</ref> </para></listitem>
<listitem><para><ref refid="overview_datetime_1overview_datetime_dst" kindref="member">Daylight saving time (DST)</ref> </para></listitem>
<listitem><para><ref refid="overview_datetime_1overview_datetime_holidays" kindref="member">wxDateTime and Holidays</ref> </para></listitem>
<listitem><para><ref refid="overview_datetime_1overview_datetime_compat" kindref="member">Compatibility</ref></para></listitem>
</itemizedlist>
<hruler/>
</para><sect1 id="overview_datetime_1overview_datetime_introduction">
<title>Introduction</title>
<para>wxWidgets provides a set of powerful classes to work with dates and times. Some of the supported features of <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> class are:</para><para><itemizedlist>
<listitem><para>Wide range: the range of supported dates goes from about 4714 B.C. to some 480 million years in the future.</para></listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>Precision: not using floating point calculations anywhere ensures that the date calculations don&apos;t suffer from rounding errors.</para></listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>Many features: not only all usual calculations with dates are supported, but also more exotic week and year day calculations, work day testing, standard astronomical functions, conversion to and from strings in either strict or free format.</para></listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>Efficiency: objects of <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> are small (8 bytes) and working with them is fast</para></listitem>
</itemizedlist>
</para></sect1>
<sect1 id="overview_datetime_1overview_datetime_classes">
<title>All date/time classes at a glance</title>
<para>There are 3 main classes declared in <computeroutput><ref refid="interface_2wx_2datetime_8h" kindref="compound">wx/datetime.h</ref></computeroutput>: except <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> itself which represents an absolute moment in time, there are also two classes - <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref> and <ref refid="classwx_date_span" kindref="compound">wxDateSpan</ref> - which represent the intervals of time.</para><para>There are also helper classes which are used together with <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref>: <ref refid="classwx_date_time_holiday_authority" kindref="compound">wxDateTimeHolidayAuthority</ref> which is used to determine whether a given date is a holiday or not and <ref refid="classwx_date_time_work_days" kindref="compound">wxDateTimeWorkDays</ref> which is a derivation of this class for which (only) Saturdays and Sundays are the holidays. See more about these classes in the discussion of the holidays (see <ref refid="overview_datetime_1overview_datetime_holidays" kindref="member">wxDateTime and Holidays</ref>).</para><para>Finally, in other parts of this manual you may find mentions of wxDate and wxTime classes. <ref refid="overview_datetime_1overview_datetime_compat" kindref="member">Compatibility</ref> are obsolete and superseded by <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref>.</para></sect1>
<sect1 id="overview_datetime_1overview_datetime_characteristics">
<title>wxDateTime characteristics</title>
<para><ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> stores the time as a signed number of milliseconds since the Epoch which is fixed, by convention, to Jan 1, 1970 - however this is not visible to the class users (in particular, dates prior to the Epoch are handled just as well (or as bad) as the dates after it). But it does mean that the best resolution which can be achieved with this class is 1 millisecond.</para><para>The size of <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> object is 8 bytes because it is represented as a 64 bit integer. The resulting range of supported dates is thus approximatively 580 million years, but due to the current limitations in the Gregorian calendar support, only dates from Nov 24, 4714BC are supported (this is subject to change if there is sufficient interest in doing it).</para><para>Finally, the internal representation is time zone independent (always in GMT) and the time zones only come into play when a date is broken into year/month/day components. See more about timezones below (see <ref refid="overview_datetime_1overview_datetime_timezones" kindref="member">Time zone considerations</ref>).</para><para>Currently, the only supported calendar is Gregorian one (which is used even for the dates prior to the historic introduction of this calendar which was first done on Oct 15, 1582 but is, generally speaking, country, and even region, dependent). Future versions will probably have Julian calendar support as well and support for other calendars (Maya, Hebrew, Chinese...) is not ruled out.</para></sect1>
<sect1 id="overview_datetime_1overview_datetime_timespandiff">
<title>Difference between wxDateSpan and wxTimeSpan</title>
<para>While there is only one logical way to represent an absolute moment in the time (and hence only one <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> class), there are at least two methods to describe a time interval.</para><para>First, there is the direct and self-explaining way implemented by <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref>: it is just a difference in milliseconds between two moments in time. Adding or subtracting such an interval to <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> is always well-defined and is a fast operation.</para><para>But in the daily life other, calendar-dependent time interval specifications are used. For example, &apos;one month later&apos; is commonly used. However, it is clear that this is not the same as <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref> of 60*60*24*31 seconds because &apos;one month later&apos; Feb 15 is Mar 15 and not Mar 17 or Mar 16 (depending on whether the year is leap or not).</para><para>This is why there is another class for representing such intervals called <ref refid="classwx_date_span" kindref="compound">wxDateSpan</ref>. It handles these sort of operations in the most natural way possible, but note that manipulating with intervals of this kind is not always well-defined. Consider, for example, Jan 31 + &apos;1 month&apos;: this will give Feb 28 (or 29), i.e. the last day of February and not the non-existent Feb 31. Of course, this is what is usually wanted, but you still might be surprised to notice that now subtracting back the same interval from Feb 28 will result in Jan 28 and <bold>not</bold> Jan 31 we started with!</para><para>So, unless you plan to implement some kind of natural language parsing in the program, you should probably use <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref> instead of <ref refid="classwx_date_span" kindref="compound">wxDateSpan</ref> (which is also more efficient). However, <ref refid="classwx_date_span" kindref="compound">wxDateSpan</ref> may be very useful in situations when you do need to understand what &apos;in a month&apos; means (of course, it is just <computeroutput><ref refid="classwx_date_time_1a6e6c37a0414bb4831e2cc03b37f498a2" kindref="member">wxDateTime::Now()</ref></computeroutput> + <ref refid="classwx_date_span_1a14e488e59083c754acfd96adf5a291d9" kindref="member">wxDateSpan::Month()</ref>).</para></sect1>
<sect1 id="overview_datetime_1overview_datetime_arithmetics">
<title>Date arithmetics</title>
<para>Many different operations may be performed with the dates, however not all of them make sense. For example, multiplying a date by a number is an invalid operation, even though multiplying either of the time span classes by a number is perfectly valid.</para><para>Here is what can be done:</para><para><itemizedlist>
<listitem><para><bold>Addition:</bold> a <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref> or <ref refid="classwx_date_span" kindref="compound">wxDateSpan</ref> can be added to <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> resulting in a new <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> object and also 2 objects of the same span class can be added together giving another object of the same class.</para></listitem>
</itemizedlist>
<itemizedlist>
<listitem><para><bold>Subtraction:</bold> the same types of operations as above are allowed and, additionally, a difference between two <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> objects can be taken and this will yield <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref>.</para></listitem>
</itemizedlist>
<itemizedlist>
<listitem><para><bold>Multiplication:</bold> a <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref> or <ref refid="classwx_date_span" kindref="compound">wxDateSpan</ref> object can be multiplied by an integer number resulting in an object of the same type.</para></listitem>
</itemizedlist>
<itemizedlist>
<listitem><para><bold>Unary minus</bold>: a <ref refid="classwx_time_span" kindref="compound">wxTimeSpan</ref> or <ref refid="classwx_date_span" kindref="compound">wxDateSpan</ref> object may finally be negated giving an interval of the same magnitude but of opposite time direction.</para></listitem>
</itemizedlist>
For all these operations there are corresponding global (overloaded) operators and also member functions which are synonyms for them: Add(), Subtract() and Multiply(). Unary minus as well as composite assignment operations (like +=) are only implemented as members and Neg() is the synonym for unary minus.</para></sect1>
<sect1 id="overview_datetime_1overview_datetime_timezones">
<title>Time zone considerations</title>
<para>Although the time is always stored internally in GMT, you will usually work in the local time zone. Because of this, all <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> constructors and setters which take the broken down date assume that these values are for the local time zone. Thus, <computeroutput>wxDateTime(1, wxDateTime::Jan, 1970)</computeroutput> will not correspond to the <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> Epoch unless you happen to live in the UK. All methods returning the date components (year, month, day, hour, minute, second...) will also return the correct values for the local time zone by default, so, generally, doing the natural things will lead to natural and correct results.</para><para>If you only want to do this, you may safely skip the rest of this section. However, if you want to work with different time zones, you should read it to the end.</para><para>In this (rare) case, you are still limited to the local time zone when constructing <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> objects, i.e. there is no way to construct a <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref> corresponding to the given date in, say, Pacific Standard Time. To do it, you will need to call <ref refid="classwx_date_time_1a254dff0f6fb8861216941dcc3d4fdc15" kindref="member">wxDateTime::ToTimezone</ref> or <ref refid="classwx_date_time_1ad6ce9eb1fb237eda8013695ebd531af1" kindref="member">wxDateTime::MakeTimezone</ref> methods to adjust the date for the target time zone. There are also special versions of these functions <ref refid="classwx_date_time_1a4bddd303b09cc47c7251b01ca49dc04c" kindref="member">wxDateTime::ToUTC</ref> and <ref refid="classwx_date_time_1aa7e62cebf49c1c6b765e70ec19caedc0" kindref="member">wxDateTime::MakeUTC</ref> for the most common case - when the date should be constructed in UTC.</para><para>You also can just retrieve the value for some time zone without converting the object to it first. For this you may pass TimeZone argument to any of the methods which are affected by the time zone (all methods getting date components and the date formatting ones, for example). In particular, the Format() family of methods accepts a TimeZone parameter and this allows to simply print time in any time zone.</para><para>To see how to do it, the last issue to address is how to construct a TimeZone object which must be passed to all these methods. First of all, you may construct it manually by specifying the time zone offset in seconds from GMT, but usually you will just use one of the <ref refid="overview_datetime" kindref="compound">Date and Time</ref> and let the conversion constructor do the job.</para><para>I.e. you would just write</para><para><programlisting><codeline><highlight class="normal"><ref refid="classwx_date_time" kindref="compound" tooltip="wxDateTime class represents an absolute moment in time.">wxDateTime</ref><sp/>dt(...whatever...);</highlight></codeline>
<codeline><highlight class="normal">printf(</highlight><highlight class="stringliteral">&quot;The<sp/>time<sp/>is<sp/>%s<sp/>in<sp/>local<sp/>time<sp/>zone&quot;</highlight><highlight class="normal">,<sp/>dt.<ref refid="classwx_date_time_1a4d3145af33faf443ac9d9fdfc4256c1e" kindref="member" tooltip="Identical to calling Format() with &amp;quot;%X&amp;quot; argument (which means &amp;quot;preferred time representation for the ...">FormatTime</ref>().<ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member" tooltip="Returns a lightweight intermediate class which is in turn implicitly convertible to both const char* ...">c_str</ref>());</highlight></codeline>
<codeline><highlight class="normal">printf(</highlight><highlight class="stringliteral">&quot;The<sp/>time<sp/>is<sp/>%s<sp/>in<sp/>GMT&quot;</highlight><highlight class="normal">,<sp/>dt.<ref refid="classwx_date_time_1a4d3145af33faf443ac9d9fdfc4256c1e" kindref="member" tooltip="Identical to calling Format() with &amp;quot;%X&amp;quot; argument (which means &amp;quot;preferred time representation for the ...">FormatTime</ref>(wxDateTime::GMT).<ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member" tooltip="Returns a lightweight intermediate class which is in turn implicitly convertible to both const char* ...">c_str</ref>());</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="overview_datetime_1overview_datetime_dst">
<title>Daylight saving time (DST)</title>
<para>DST (a.k.a. &apos;summer time&apos;) handling is always a delicate task which is better left to the operating system which is supposed to be configured by the administrator to behave correctly. Unfortunately, when doing calculations with date outside of the range supported by the standard library, we are forced to deal with these issues ourselves.</para><para>Several functions are provided to calculate the beginning and end of DST in the given year and to determine whether it is in effect at the given moment or not, but they should not be considered as absolutely correct because, first of all, they only work more or less correctly for only a handful of countries (any information about other ones appreciated!) and even for them the rules may perfectly well change in the future.</para><para>The time zone handling methods (see <ref refid="overview_datetime_1overview_datetime_timezones" kindref="member">Time zone considerations</ref>) use these functions too, so they are subject to the same limitations.</para></sect1>
<sect1 id="overview_datetime_1overview_datetime_holidays">
<title>wxDateTime and Holidays</title>
<para><xrefsect id="todo_1_todo000003"><xreftitle>Todo</xreftitle><xrefdescription><para>WRITE THIS DOC PARAGRAPH.</para></xrefdescription></xrefsect></para></sect1>
<sect1 id="overview_datetime_1overview_datetime_compat">
<title>Compatibility</title>
<para>The old classes for date/time manipulations ported from wxWidgets version 1.xx are still included but are reimplemented in terms of <ref refid="classwx_date_time" kindref="compound">wxDateTime</ref>. However, using them is strongly discouraged because they have a few quirks/bugs and were not &apos;Y2K&apos; compatible. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
