<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.4">
  <compounddef id="page_multiplatform" kind="page">
    <compoundname>page_multiplatform</compoundname>
    <title>General Cross-Platform Development Tips</title>
    <detaileddescription>
<para>This chapter describes some tips related to cross-platform development.</para><para><itemizedlist>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_includefiles" kindref="member">Include Files</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_libraries" kindref="member">Libraries</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_configuration" kindref="member">Configuration</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_makefiles" kindref="member">Makefiles</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_winresources" kindref="member">Windows Resource Files</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_allocatingobjects" kindref="member">Allocating and Deleting wxWidgets Objects</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_architecturedependency" kindref="member">Architecture Dependency</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_conditionalcompilation" kindref="member">Conditional Compilation</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_cpp" kindref="member">C++ Issues</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_filehandling" kindref="member">File Handling</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_reducingerr" kindref="member">Reducing Programming Errors</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_gui" kindref="member">GUI Design</ref> </para></listitem>
<listitem><para><ref refid="page_multiplatform_1page_multiplatform_debug" kindref="member">Debugging</ref></para></listitem>
</itemizedlist>
<hruler/>
</para><sect1 id="page_multiplatform_1page_multiplatform_includefiles">
<title>Include Files</title>
<para>The main include file is <computeroutput>&quot;wx/wx.h&quot;</computeroutput>; this includes the most commonly used modules of wxWidgets.</para><para>To save on compilation time, include only those header files relevant to the source file. If you are using <bold>precompiled</bold> headers, you should include the following section before any other includes:</para><para><verbatim>
// For compilers that support precompilation, includes &quot;wx.h&quot;.
#include &lt;wx/wxprec.h&gt;

#ifdef __BORLANDC__
#   pragma hdrstop
#endif

#ifndef WX_PRECOMP
    // Include your minimal set of headers here, or wx.h
#   include &lt;wx/wx.h&gt;
#endif

... now your other include files ...
</verbatim></para><para>The file <computeroutput>&quot;wx/wxprec.h&quot;</computeroutput> includes <computeroutput>&quot;wx/wx.h&quot;</computeroutput>. Although this incantation may seem quirky, it is in fact the end result of a lot of experimentation, and several Windows compilers to use precompilation which is largely automatic for compilers with necessary support. Currently it is used for Visual C++ (including embedded Visual C++), Borland C++, Open Watcom C++, Digital Mars C++ and newer versions of GCC. Some compilers might need extra work from the application developer to set the build environment up as necessary for the support.</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_libraries">
<title>Libraries</title>
<para>All ports of wxWidgets can create either a <bold>static</bold> library or a <bold>shared</bold> library.</para><para>When a program is linked against a <emphasis>static</emphasis> library, the machine code from the object files for any external functions used by the program is copied from the library into the final executable.</para><para><emphasis>Shared</emphasis> libraries are handled with a more advanced form of linking, which makes the executable file smaller. They use the extension <computeroutput>&quot;.so&quot;</computeroutput> (Shared Object) under Linux and <computeroutput>&quot;.dll&quot;</computeroutput> (Dynamic Link Library) under Windows.</para><para>An executable file linked against a shared library contains only a small table of the functions it requires, instead of the complete machine code from the object files for the external functions. Before the executable file starts running, the machine code for the external functions is copied into memory from the shared library file on disk by the operating system - a process referred to as <emphasis>dynamic</emphasis> linking.</para><para>Dynamic linking makes executable files smaller and saves disk space, because one copy of a library can be shared between multiple programs. Most operating systems also provide a virtual memory mechanism which allows one copy of a shared library in physical memory to be used by all running programs, saving memory as well as disk space.</para><para>Furthermore, shared libraries make it possible to update a library without recompiling the programs which use it (provided the interface to the library does not change).</para><para>wxWidgets can also be built in <bold>multilib</bold> and <bold>monolithic</bold> variants. See the <ref refid="page_libs" kindref="compound">Library List</ref> for more information on these.</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_configuration">
<title>Configuration</title>
<para>When using project files and makefiles directly to build wxWidgets, options are configurable in the file <computeroutput>&quot;wx/XXX/setup.h&quot;</computeroutput> where XXX is the required platform (such as <computeroutput>msw</computeroutput>, <computeroutput>motif</computeroutput>, <computeroutput>gtk</computeroutput>, <computeroutput>mac</computeroutput>).</para><para>Some settings are a matter of taste, some help with platform-specific problems, and others can be set to minimize the size of the library. Please see the <computeroutput>&quot;setup.h&quot;</computeroutput> file and <computeroutput>&quot;install.txt&quot;</computeroutput> files for details on configuration.</para><para>When using the <computeroutput>&quot;configure&quot;</computeroutput> script to configure wxWidgets (on Unix and other platforms where configure is available), the corresponding <computeroutput>&quot;setup.h&quot;</computeroutput> files are generated automatically along with suitable makefiles.</para><para>When using the RPM packages (or DEB or other forms of <emphasis>binaries</emphasis>) for installing wxWidgets on Linux, a correct <computeroutput>&quot;setup.h&quot;</computeroutput> is shipped in the package and this must not be changed.</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_makefiles">
<title>Makefiles</title>
<para>On Microsoft Windows, wxWidgets has a different set of makefiles for each compiler, because each compiler&apos;s <computeroutput>&apos;make&apos;</computeroutput> tool is slightly different. Popular Windows compilers that we cater for, and the corresponding makefile extensions, include: Microsoft Visual C++ (.vc), Borland C++ (.bcc), OpenWatcom C++ (.wat) and MinGW/Cygwin (.gcc). Makefiles are provided for the wxWidgets library itself, samples, demos, and utilities.</para><para>On Linux, Mac and OS/2, you use the <computeroutput>&apos;configure&apos;</computeroutput> command to generate the necessary makefiles. You should also use this method when building with MinGW/Cygwin on Windows.</para><para>We also provide project files for some compilers, such as Microsoft VC++. However, we recommend using makefiles to build the wxWidgets library itself, because makefiles can be more powerful and less manual intervention is required.</para><para>On Windows using a compiler other than MinGW/Cygwin, you would build the wxWidgets library from the <computeroutput>&quot;build/msw&quot;</computeroutput> directory which contains the relevant makefiles.</para><para>On Windows using MinGW/Cygwin, and on Unix, MacOS X and OS/2, you invoke &apos;configure&apos; (found in the top-level of the wxWidgets source hierarchy), from within a suitable empty directory for containing makefiles, object files and libraries.</para><para>For details on using makefiles, configure, and project files, please see <computeroutput>&quot;docs/xxx/install.txt&quot;</computeroutput> in your distribution, where <computeroutput>&quot;xxx&quot;</computeroutput> is the platform of interest, such as <computeroutput>msw</computeroutput>, <computeroutput>gtk</computeroutput>, <computeroutput>x11</computeroutput>, <computeroutput>mac</computeroutput>.</para><para>All wxWidgets makefiles are generated using Bakefile &lt;<ulink url="http://www.bakefile.org/">http://www.bakefile.org/</ulink>&gt;. wxWidgets also provides (in the <computeroutput>&quot;build/bakefiles/wxpresets&quot;</computeroutput> folder) the wxWidgets bakefile presets. These files allow you to create bakefiles for your own wxWidgets-based applications very easily.</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_winresources">
<title>Windows Resource Files</title>
<para>wxWidgets application compilation under MS Windows requires at least one extra <ulink url="file:">file:</ulink> a resource file.</para><para>The least that must be defined in the Windows resource file (extension RC) is the following statement:</para><para><verbatim>
#include &quot;wx/msw/wx.rc&quot;
</verbatim></para><para>which includes essential internal wxWidgets definitions. The resource script may also contain references to icons, cursors, etc., for example:</para><para><verbatim>
wxicon icon wx.ico
</verbatim></para><para>The icon can then be referenced by name when creating a frame icon. See the Microsoft Windows SDK documentation.</para><para><simplesect kind="note"><para>Include &quot;wx.rc&quot; <emphasis>after</emphasis> any ICON statements so programs that search your executable for icons (such as the Program Manager) find your application icon first.</para></simplesect>
</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_allocatingobjects">
<title>Allocating and Deleting wxWidgets Objects</title>
<para>In general, classes derived from <ref refid="classwx_window" kindref="compound">wxWindow</ref> must dynamically allocated with <emphasis>new</emphasis> and deleted with <emphasis>delete</emphasis>. If you delete a window, all of its children and descendants will be automatically deleted, so you don&apos;t need to delete these descendants explicitly.</para><para>When deleting a frame or dialog, use <bold>Destroy</bold> rather than <bold>delete</bold> so that the wxWidgets delayed deletion can take effect. This waits until idle time (when all messages have been processed) to actually delete the window, to avoid problems associated with the GUI sending events to deleted windows.</para><para>In general wxWindow-derived objects should always be allocated on the heap as wxWidgets will destroy them itself. The only, but important, exception to this rule are the modal dialogs, i.e. <ref refid="classwx_dialog" kindref="compound">wxDialog</ref> objects which are shown using <ref refid="classwx_dialog_1a6e078c3d0653f75ad3c34a37c0b54637" kindref="member">wxDialog::ShowModal()</ref> method. They may be allocated on the stack and, indeed, usually are local variables to ensure that they are destroyed on scope exit as wxWidgets does not destroy them unlike with all the other windows. So while it is still possible to allocate modal dialogs on the heap, you should still destroy or delete them explicitly in this case instead of relying on wxWidgets doing it.</para><para>If you decide to allocate a C++ array of objects (such as <ref refid="classwx_bitmap" kindref="compound">wxBitmap</ref>) that may be cleaned up by wxWidgets, make sure you delete the array explicitly before wxWidgets has a chance to do so on exit, since calling <emphasis>delete</emphasis> on array members will cause memory problems.</para><para><ref refid="classwx_colour" kindref="compound">wxColour</ref> can be created statically: it is not automatically cleaned up and is unlikely to be shared between other objects; it is lightweight enough for copies to be made.</para><para>Beware of deleting objects such as a <ref refid="classwx_pen" kindref="compound">wxPen</ref> or <ref refid="classwx_bitmap" kindref="compound">wxBitmap</ref> if they are still in use. Windows is particularly sensitive to this, so make sure you make calls like wxDC::SetPen(wxNullPen) or wxDC::SelectObject(wxNullBitmap) before deleting a drawing object that may be in use. Code that doesn&apos;t do this will probably work fine on some platforms, and then fail under Windows.</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_architecturedependency">
<title>Architecture Dependency</title>
<para>A problem which sometimes arises from writing multi-platform programs is that the basic C types are not defined the same on all platforms. This holds true for both the length in bits of the standard types (such as int and long) as well as their byte order, which might be little endian (typically on Intel computers) or big endian (typically on some Unix workstations). wxWidgets defines types and macros that make it easy to write architecture independent code. The types are:</para><para>wxInt32, wxInt16, wxInt8, wxUint32, wxUint16 = wxWord, wxUint8 = wxByte</para><para>where wxInt32 stands for a 32-bit signed integer type etc. You can also check which architecture the program is compiled on using the wxBYTE_ORDER define which is either wxBIG_ENDIAN or wxLITTLE_ENDIAN (in the future maybe wxPDP_ENDIAN as well).</para><para>The macros handling bit-swapping with respect to the applications endianness are described in the <ref refid="group__group__funcmacro__byteorder" kindref="compound">Byte Order</ref> section.</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_conditionalcompilation">
<title>Conditional Compilation</title>
<para>One of the purposes of wxWidgets is to reduce the need for conditional compilation in source code, which can be messy and confusing to follow. However, sometimes it is necessary to incorporate platform-specific features (such as metafile use under MS Windows). The <ref refid="page_wxusedef" kindref="compound">wxUSE preprocessor symbols defined by wxWidgets</ref> symbols listed in the file <computeroutput>setup.h</computeroutput> may be used for this purpose, along with any user-supplied ones.</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_cpp">
<title>C++ Issues</title>
<para>The following documents some miscellaneous C++ issues.</para><sect2 id="page_multiplatform_1page_multiplatform_cpp_templates">
<title>Templates</title>
<para>wxWidgets does not use templates (except for some advanced features that are switched off by default) since it is a notoriously unportable feature.</para></sect2>
<sect2 id="page_multiplatform_1page_multiplatform_cpp_rtti">
<title>Runtime Type Information (RTTI)</title>
<para>wxWidgets does not use C++ run-time type information since wxWidgets provides its own run-time type information system, implemented using macros.</para></sect2>
<sect2 id="page_multiplatform_1page_multiplatform_cpp_precompiledheaders">
<title>Precompiled Headers</title>
<para>Some compilers, such as Borland C++ and Microsoft C++, support precompiled headers. This can save a great deal of compiling time. The recommended approach is to precompile <computeroutput>&quot;wx.h&quot;</computeroutput>, using this precompiled header for compiling both wxWidgets itself and any wxWidgets applications. For Windows compilers, two dummy source files are provided (one for normal applications and one for creating DLLs) to allow initial creation of the precompiled header.</para><para>However, there are several downsides to using precompiled headers. One is that to take advantage of the facility, you often need to include more header files than would normally be the case. This means that changing a header file will cause more recompilations (in the case of wxWidgets, everything needs to be recompiled since everything includes <computeroutput>&quot;wx.h&quot;</computeroutput>).</para><para>A related problem is that for compilers that don&apos;t have precompiled headers, including a lot of header files slows down compilation considerably. For this reason, you will find (in the common X and Windows parts of the library) conditional compilation that under Unix, includes a minimal set of headers; and when using Visual C++, includes <computeroutput>&quot;wx.h&quot;</computeroutput>. This should help provide the optimal compilation for each compiler, although it is biased towards the precompiled headers facility available in Microsoft C++.</para></sect2>
</sect1>
<sect1 id="page_multiplatform_1page_multiplatform_filehandling">
<title>File Handling</title>
<para>When building an application which may be used under different environments, one difficulty is coping with documents which may be moved to different directories on other machines. Saving a file which has pointers to full pathnames is going to be inherently unportable.</para><para>One approach is to store filenames on their own, with no directory information. The application then searches into a list of standard paths (platform-specific) through the use of <ref refid="classwx_standard_paths" kindref="compound">wxStandardPaths</ref>.</para><para>Eventually you may want to use also the <ref refid="classwx_path_list" kindref="compound">wxPathList</ref> class.</para><para>Nowadays the limitations of DOS 8+3 filenames doesn&apos;t apply anymore. Most modern operating systems allow at least 255 characters in the filename; the exact maximum length, as well as the characters allowed in the filenames, are OS-specific so you should try to avoid extremely long (&gt; 255 chars) filenames and/or filenames with non-ANSI characters.</para><para>Another thing you need to keep in mind is that all Windows operating systems are case-insensitive, while Unix operating systems (Linux, Mac, etc) are case-sensitive.</para><para>Also, for text files, different OSes use different End Of Lines (EOL). Windows uses CR+LF convention, Linux uses LF only, Mac CR only.</para><para>The <ref refid="classwx_text_file" kindref="compound">wxTextFile</ref>, <ref refid="classwx_text_input_stream" kindref="compound">wxTextInputStream</ref>, <ref refid="classwx_text_output_stream" kindref="compound">wxTextOutputStream</ref> classes help to abstract from these differences. Of course, there are also 3rd party utilities such as <computeroutput>dos2unix</computeroutput> and <computeroutput>unix2dos</computeroutput> which do the EOL conversions.</para><para>See also the <ref refid="group__group__funcmacro__file" kindref="compound">Files and Directories</ref> section of the reference manual for the description of miscellaneous file handling functions.</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_reducingerr">
<title>Reducing Programming Errors</title>
<sect2 id="page_multiplatform_1page_multiplatform_reducingerr_useassert">
<title>Use ASSERT</title>
<para>It is good practice to use ASSERT statements liberally, that check for conditions that should or should not hold, and print out appropriate error messages.</para><para>These can be compiled out of a non-debugging version of wxWidgets and your application. Using ASSERT is an example of `defensive programming&apos;: it can alert you to problems later on.</para><para>See <ref refid="group__group__funcmacro__debug_1ga204cc264ee560b67e6c6467ba8ffee5f" kindref="member">wxASSERT()</ref> for more info.</para></sect2>
<sect2 id="page_multiplatform_1page_multiplatform_reducingerr_usewxstring">
<title>Use wxString in Preference to Character Arrays</title>
<para>Using <ref refid="classwx_string" kindref="compound">wxString</ref> can be much safer and more convenient than using <computeroutput>wxChar*</computeroutput>.</para><para>You can reduce the possibility of memory leaks substantially, and it is much more convenient to use the overloaded operators than functions such as <computeroutput>strcmp</computeroutput>. <ref refid="classwx_string" kindref="compound">wxString</ref> won&apos;t add a significant overhead to your program; the overhead is compensated for by easier manipulation (which means less code).</para><para>The same goes for other data types: use classes wherever possible.</para></sect2>
</sect1>
<sect1 id="page_multiplatform_1page_multiplatform_gui">
<title>GUI Design</title>
<para><itemizedlist>
<listitem><para><bold>Use Sizers:</bold> Don&apos;t use absolute panel item positioning if you can avoid it. Every platform&apos;s native controls have very different sizes. Consider using the <ref refid="overview_sizer" kindref="compound">Sizers Overview</ref> instead. </para></listitem>
<listitem><para><bold>Use wxWidgets Resource Files:</bold> Use <computeroutput>XRC</computeroutput> (wxWidgets resource files) where possible, because they can be easily changed independently of source code. See the <ref refid="overview_xrc" kindref="compound">XML Based Resource System (XRC)</ref> for more info.</para></listitem>
</itemizedlist>
</para></sect1>
<sect1 id="page_multiplatform_1page_multiplatform_debug">
<title>Debugging</title>
<sect2 id="page_multiplatform_1page_multiplatform_debug_positivethinking">
<title>Positive Thinking</title>
<para>It is common to blow up the problem in one&apos;s imagination, so that it seems to threaten weeks, months or even years of work. The problem you face may seem insurmountable: but almost never is. Once you have been programming for some time, you will be able to remember similar incidents that threw you into the depths of despair. But remember, you always solved the problem, somehow!</para><para>Perseverance is often the key, even though a seemingly trivial problem can take an apparently inordinate amount of time to solve. In the end, you will probably wonder why you worried so much. That&apos;s not to say it isn&apos;t painful at the time. Try not to worry -- there are many more important things in life.</para></sect2>
<sect2 id="page_multiplatform_1page_multiplatform_debug_simplifyproblem">
<title>Simplify the Problem</title>
<para>Reduce the code exhibiting the problem to the smallest program possible that exhibits the problem. If it is not possible to reduce a large and complex program to a very small program, then try to ensure your code doesn&apos;t hide the problem (you may have attempted to minimize the problem in some way: but now you want to expose it).</para><para>With luck, you can add a small amount of code that causes the program to go from functioning to non-functioning state. This should give a clue to the problem. In some cases though, such as memory leaks or wrong deallocation, this can still give totally spurious results!</para></sect2>
<sect2 id="page_multiplatform_1page_multiplatform_debug_usedebugger">
<title>Use a Debugger</title>
<para>This sounds like facetious advice, but it is surprising how often people don&apos;t use a debugger. Often it is an overhead to install or learn how to use a debugger, but it really is essential for anything but the most trivial programs.</para></sect2>
<sect2 id="page_multiplatform_1page_multiplatform_debug_uselogging">
<title>Use Logging Functions</title>
<para>There is a variety of logging functions that you can use in your program: see <ref refid="group__group__funcmacro__log" kindref="compound">Logging</ref>.</para><para>Using tracing statements may be more convenient than using the debugger in some circumstances (such as when your debugger doesn&apos;t support a lot of debugging code, or you wish to print a bunch of variables).</para></sect2>
<sect2 id="page_multiplatform_1page_multiplatform_debug_usedebuggingfacilities">
<title>Use the wxWidgets Debugging Facilities</title>
<para>You can use <ref refid="classwx_debug_context" kindref="compound">wxDebugContext</ref> to check for memory leaks and corrupt memory: in fact in debugging mode, wxWidgets will automatically check for memory leaks at the end of the program if wxWidgets is suitably configured. Depending on the operating system and compiler, more or less specific information about the problem will be logged.</para><para>You should also use <ref refid="group__group__funcmacro__debug" kindref="compound">Debugging macros</ref> as part of a &quot;defensive
programming&quot; strategy, scattering <ref refid="group__group__funcmacro__debug_1ga204cc264ee560b67e6c6467ba8ffee5f" kindref="member">wxASSERT()</ref>s liberally to test for problems in your code as early as possible. Forward thinking will save a surprising amount of time in the long run.</para><para>See the <ref refid="overview_debugging" kindref="compound">Debugging</ref> for further information. </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
