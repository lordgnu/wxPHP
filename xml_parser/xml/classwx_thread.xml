<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.4">
  <compounddef id="classwx_thread" kind="class" prot="public">
    <compoundname>wxThread</compoundname>
    <includes local="no">wx/thread.h</includes>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classwx_thread_1ade9497fa072fe19481086e6486dcc028" prot="public" static="no">
        <type>void *</type>
        <definition>typedef void* wxThread::ExitCode</definition>
        <argsstring></argsstring>
        <name>ExitCode</name>
        <briefdescription>
<para>The return type for the thread functions. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="994" bodyfile="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" bodystart="994" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classwx_thread_1aafdb64801bd4d595ad0956f71d5791f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>wxThread::wxThread</definition>
        <argsstring>(wxThreadKind kind=wxTHREAD_DETACHED)</argsstring>
        <name>wxThread</name>
        <param>
          <type><ref refid="interface_2wx_2thread_8h_1a0dc9a167e8d084946512da99b37b5fd0" kindref="member">wxThreadKind</ref></type>
          <declname>kind</declname>
          <defval>wxTHREAD_DETACHED</defval>
        </param>
        <briefdescription>
<para>This constructor creates a new detached (default) or joinable C++ thread object. </para>        </briefdescription>
        <detaileddescription>
<para>It does not create or start execution of the real thread - for this you should use the <ref refid="classwx_thread_1a88051a33aa3fa9ca9392ac7d47b43cf4" kindref="member">Create()</ref> and <ref refid="classwx_thread_1a5d894750ffaac8fc42ee85aeff8bb4c0" kindref="member">Run()</ref> methods.</para><para>The possible values for <emphasis>kind</emphasis> parameters are:<itemizedlist>
<listitem><para><bold>wxTHREAD_DETACHED</bold> - Creates a detached thread.</para></listitem><listitem><para><bold>wxTHREAD_JOINABLE</bold> - Creates a joinable thread. </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1005"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a48c37f3555eb99cca9d9f3594fed5793" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual wxThread::~wxThread</definition>
        <argsstring>()</argsstring>
        <name>~wxThread</name>
        <briefdescription>
<para>The destructor frees the resources associated with the thread. </para>        </briefdescription>
        <detaileddescription>
<para>Notice that you should never delete a detached thread -- you may only call <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref> on it or wait until it terminates (and auto destructs) itself.</para><para>Because the detached threads delete themselves, they can only be allocated on the heap. Joinable threads should be deleted explicitly. The <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref> and <ref refid="classwx_thread_1a2cbff8b3b0a93ab82f212c02f38a1ef4" kindref="member">Kill()</ref> functions will not delete the C++ thread object. It is also safe to allocate them on stack. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1016"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a88051a33aa3fa9ca9392ac7d47b43cf4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2" kindref="member">wxThreadError</ref></type>
        <definition>wxThreadError wxThread::Create</definition>
        <argsstring>(unsigned int stackSize=0)</argsstring>
        <name>Create</name>
        <param>
          <type>unsigned int</type>
          <declname>stackSize</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Creates a new thread. </para>        </briefdescription>
        <detaileddescription>
<para>The thread object is created in the suspended state, and you should call <ref refid="classwx_thread_1a5d894750ffaac8fc42ee85aeff8bb4c0" kindref="member">Run()</ref> to start running it. You may optionally specify the stack size to be allocated to it (Ignored on platforms that don&apos;t support setting it explicitly, eg. Unix system without <computeroutput>pthread_attr_setstacksize</computeroutput>).</para><para>If you do not specify the stack size,the system&apos;s default value is used.</para><para><simplesect kind="warning"><para>It is a good idea to explicitly specify a value as systems&apos; default values vary from just a couple of KB on some systems (BSD and OS/2 systems) to one or several MB (Windows, Solaris, Linux). So, if you have a thread that requires more than just a few KB of memory, you will have mysterious problems on some platforms but not on the common ones. On the other hand, just indicating a large stack size by default will give you performance issues on those systems with small default stack since those typically use fully committed memory for the stack. On the contrary, if you use a lot of threads (say several hundred), virtual address space can get tight unless you explicitly specify a smaller amount of thread stack space for each thread.</para></simplesect>
<simplesect kind="return"><para>One of:<itemizedlist>
<listitem><para><bold>wxTHREAD_NO_ERROR</bold> - No error.</para></listitem><listitem><para><bold>wxTHREAD_NO_RESOURCE</bold> - There were insufficient resources to create the thread.</para></listitem><listitem><para><bold>wxTHREAD_NO_RUNNING</bold> - The thread is already running </para></listitem></itemizedlist>
</para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1046"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2" kindref="member">wxThreadError</ref></type>
        <definition>wxThreadError wxThread::Delete</definition>
        <argsstring>(ExitCode *rc=NULL, wxThreadWait waitMode=wxTHREAD_WAIT_BLOCK)</argsstring>
        <name>Delete</name>
        <param>
          <type><ref refid="classwx_thread_1ade9497fa072fe19481086e6486dcc028" kindref="member">ExitCode</ref> *</type>
          <declname>rc</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="interface_2wx_2thread_8h_1a180bd0d42ba227657c3ad00194371a87" kindref="member">wxThreadWait</ref></type>
          <declname>waitMode</declname>
          <defval>wxTHREAD_WAIT_BLOCK</defval>
        </param>
        <briefdescription>
<para>Calling <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref> gracefully terminates a <bold>detached</bold> thread, either when the thread calls <ref refid="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" kindref="member">TestDestroy()</ref> or when it finishes processing. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rc</parametername>
</parameternamelist>
<parameterdescription>
<para>The thread exit code, if rc is not NULL.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>waitMode</parametername>
</parameternamelist>
<parameterdescription>
<para>As described in wxThreadWait documentation, wxTHREAD_WAIT_BLOCK should be used as the wait mode even although currently wxTHREAD_WAIT_YIELD is for compatibility reasons. This parameter is new in wxWidgets 2.9.2.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function works on a joinable thread but in that case makes the <ref refid="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" kindref="member">TestDestroy()</ref> function of the thread return true and then waits for its completion (i.e. it differs from <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref> because it asks the thread to terminate before waiting).</para></simplesect>
See <ref refid="classwx_thread_1thread_deletion" kindref="member">wxThread Deletion</ref> for a broader explanation of this routine. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1070"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a2c9db3ca1d37d8ed921e78c31acd9bb4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>wxThreadIdType</type>
        <definition>wxThreadIdType wxThread::GetId</definition>
        <argsstring>() const </argsstring>
        <name>GetId</name>
        <briefdescription>
<para>Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e. </para>        </briefdescription>
        <detaileddescription>
<para>the thread identifiers may be reused). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1097"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a1fc5fa753cf2bc0ec63ff16825a144b2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="interface_2wx_2thread_8h_1a0dc9a167e8d084946512da99b37b5fd0" kindref="member">wxThreadKind</ref></type>
        <definition>wxThreadKind wxThread::GetKind</definition>
        <argsstring>() const </argsstring>
        <name>GetKind</name>
        <briefdescription>
<para>Returns the thread kind as it was given in the ctor. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="since"><para>2.9.0 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1104"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a785ac6add565d789481f8a9dfde5c229" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int wxThread::GetPriority</definition>
        <argsstring>() const </argsstring>
        <name>GetPriority</name>
        <briefdescription>
<para>Gets the priority of the thread, between zero and 100. </para>        </briefdescription>
        <detaileddescription>
<para>The following priorities are defined:<itemizedlist>
<listitem><para><bold>WXTHREAD_MIN_PRIORITY:</bold> 0</para></listitem><listitem><para><bold>WXTHREAD_DEFAULT_PRIORITY:</bold> 50</para></listitem><listitem><para><bold>WXTHREAD_MAX_PRIORITY:</bold> 100 </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1123"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1adc6cf71c426b1da03c6ca4b7f7da8aab" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxThread::IsAlive</definition>
        <argsstring>() const </argsstring>
        <name>IsAlive</name>
        <briefdescription>
<para>Returns true if the thread is alive (i.e. </para>        </briefdescription>
        <detaileddescription>
<para>started and not terminating).</para><para>Note that this function can only safely be used with joinable threads, not detached ones as the latter delete themselves and so when the real thread is no longer alive, it is not possible to call this function because the <ref refid="classwx_thread" kindref="compound">wxThread</ref> object no longer exists. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1133"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a315c2abb553ba7e17ab2d5b2a0728e73" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxThread::IsDetached</definition>
        <argsstring>() const </argsstring>
        <name>IsDetached</name>
        <briefdescription>
<para>Returns true if the thread is of the detached kind, false if it is a joinable one. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1139"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a34328ecb720a1066971fb5e48cd84b6f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxThread::IsPaused</definition>
        <argsstring>() const </argsstring>
        <name>IsPaused</name>
        <briefdescription>
<para>Returns true if the thread is paused. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1154"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a0230733ffdc8f7603082dd2ca86b8cdd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxThread::IsRunning</definition>
        <argsstring>() const </argsstring>
        <name>IsRunning</name>
        <briefdescription>
<para>Returns true if the thread is running. </para>        </briefdescription>
        <detaileddescription>
<para>This method may only be safely used for joinable threads, see the remark in <ref refid="classwx_thread_1adc6cf71c426b1da03c6ca4b7f7da8aab" kindref="member">IsAlive()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1162"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a2cbff8b3b0a93ab82f212c02f38a1ef4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2" kindref="member">wxThreadError</ref></type>
        <definition>wxThreadError wxThread::Kill</definition>
        <argsstring>()</argsstring>
        <name>Kill</name>
        <briefdescription>
<para>Immediately terminates the target thread. </para>        </briefdescription>
        <detaileddescription>
<para><bold>&quot;This function is dangerous and should be used with extreme care&quot;</bold> (and not used at all whenever possible)! The resources allocated to the thread will not be freed and the state of the C runtime library may become inconsistent. Use <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref> for detached threads or <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref> for joinable threads instead.</para><para>For detached threads <ref refid="classwx_thread_1a2cbff8b3b0a93ab82f212c02f38a1ef4" kindref="member">Kill()</ref> will also delete the associated C++ object. However this will not happen for joinable threads and this means that you will still have to delete the <ref refid="classwx_thread" kindref="compound">wxThread</ref> object yourself to avoid memory leaks.</para><para>In neither case OnExit() of the dying thread will be called, so no thread-specific cleanup will be performed. This function can only be called from another thread context, i.e. a thread cannot kill itself.</para><para>It is also an error to call this function for a thread which is not running or paused (in the latter case, the thread will be resumed first) -- if you do it, a <bold>wxTHREAD_NOT_RUNNING</bold> error will be returned. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1186"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a8c6d835578dde71dd2c241c38336a4ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2" kindref="member">wxThreadError</ref></type>
        <definition>wxThreadError wxThread::Pause</definition>
        <argsstring>()</argsstring>
        <name>Pause</name>
        <briefdescription>
<para>Suspends the thread. </para>        </briefdescription>
        <detaileddescription>
<para>Under some implementations (Win32), the thread is suspended immediately, under others it will only be suspended when it calls <ref refid="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" kindref="member">TestDestroy()</ref> for the next time (hence, if the thread doesn&apos;t call it at all, it won&apos;t be suspended).</para><para>This function can only be called from another thread context. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1198"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1afe81d37cd6cb6d5eb142773fb2c94562" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2" kindref="member">wxThreadError</ref></type>
        <definition>wxThreadError wxThread::Resume</definition>
        <argsstring>()</argsstring>
        <name>Resume</name>
        <briefdescription>
<para>Resumes a thread suspended by the call to <ref refid="classwx_thread_1a8c6d835578dde71dd2c241c38336a4ba" kindref="member">Pause()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This function can only be called from another thread context. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1205"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a5d894750ffaac8fc42ee85aeff8bb4c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2" kindref="member">wxThreadError</ref></type>
        <definition>wxThreadError wxThread::Run</definition>
        <argsstring>()</argsstring>
        <name>Run</name>
        <briefdescription>
<para>Starts the thread execution. </para>        </briefdescription>
        <detaileddescription>
<para>Should be called after <ref refid="classwx_thread_1a88051a33aa3fa9ca9392ac7d47b43cf4" kindref="member">Create()</ref>.</para><para>Note that once you <ref refid="classwx_thread_1a5d894750ffaac8fc42ee85aeff8bb4c0" kindref="member">Run()</ref> a <bold>detached</bold> thread, <emphasis>any</emphasis> function call you do on the thread pointer (you must allocate it on the heap) is <emphasis>&quot;unsafe&quot;</emphasis>; i.e. the thread may have terminated at any moment after <ref refid="classwx_thread_1a5d894750ffaac8fc42ee85aeff8bb4c0" kindref="member">Run()</ref> and your pointer may be dangling. See <ref refid="classwx_thread_1thread_types" kindref="member">Types of wxThreads</ref> for an example of safe manipulation of detached threads.</para><para>This function can only be called from another thread context.</para><para>Finally, note that once a thread has completed and its <ref refid="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" kindref="member">Entry()</ref> function returns, you cannot call <ref refid="classwx_thread_1a5d894750ffaac8fc42ee85aeff8bb4c0" kindref="member">Run()</ref> on it again (an assert will fail in debug builds or <computeroutput>wxTHREAD_RUNNING</computeroutput> will be returned in release builds). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1222"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a6236828fe98e81103219a519fbd7091d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void wxThread::SetPriority</definition>
        <argsstring>(unsigned int priority)</argsstring>
        <name>SetPriority</name>
        <param>
          <type>unsigned int</type>
          <declname>priority</declname>
        </param>
        <briefdescription>
<para>Sets the priority of the thread, between 0 and 100. </para>        </briefdescription>
        <detaileddescription>
<para>It can only be set after calling <ref refid="classwx_thread_1a88051a33aa3fa9ca9392ac7d47b43cf4" kindref="member">Create()</ref> but before calling <ref refid="classwx_thread_1a5d894750ffaac8fc42ee85aeff8bb4c0" kindref="member">Run()</ref>.</para><para>The following priorities are defined:<itemizedlist>
<listitem><para><bold>WXTHREAD_MIN_PRIORITY:</bold> 0</para></listitem><listitem><para><bold>WXTHREAD_DEFAULT_PRIORITY:</bold> 50</para></listitem><listitem><para><bold>WXTHREAD_MAX_PRIORITY:</bold> 100 </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1245"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>virtual bool wxThread::TestDestroy</definition>
        <argsstring>()</argsstring>
        <name>TestDestroy</name>
        <briefdescription>
<para>This function should be called periodically by the thread to ensure that calls to <ref refid="classwx_thread_1a8c6d835578dde71dd2c241c38336a4ba" kindref="member">Pause()</ref> and <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref> will work. </para>        </briefdescription>
        <detaileddescription>
<para>If it returns true, the thread should exit as soon as possible. Notice that under some platforms (POSIX), implementation of <ref refid="classwx_thread_1a8c6d835578dde71dd2c241c38336a4ba" kindref="member">Pause()</ref> also relies on this function being called, so not calling it would prevent both stopping and suspending thread from working. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1263"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classwx_thread_1ade9497fa072fe19481086e6486dcc028" kindref="member">ExitCode</ref></type>
        <definition>ExitCode wxThread::Wait</definition>
        <argsstring>(wxThreadWait flags=wxTHREAD_WAIT_BLOCK)</argsstring>
        <name>Wait</name>
        <param>
          <type><ref refid="interface_2wx_2thread_8h_1a180bd0d42ba227657c3ad00194371a87" kindref="member">wxThreadWait</ref></type>
          <declname>flags</declname>
          <defval>wxTHREAD_WAIT_BLOCK</defval>
        </param>
        <briefdescription>
<para>Waits for a <bold>joinable</bold> thread to terminate and returns the value the thread returned from <ref refid="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" kindref="member">Entry()</ref> or <computeroutput>&quot;(ExitCode)-1&quot;</computeroutput> on error. </para>        </briefdescription>
        <detaileddescription>
<para>Notice that, unlike <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref>, this function doesn&apos;t cancel the thread in any way so the caller waits for as long as it takes to the thread to exit.</para><para>You can only <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref> for <bold>joinable</bold> (not detached) threads.</para><para>This function can only be called from another thread context.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>waitMode</parametername>
</parameternamelist>
<parameterdescription>
<para>As described in wxThreadWait documentation, wxTHREAD_WAIT_BLOCK should be used as the wait mode even although currently wxTHREAD_WAIT_YIELD is for compatibility reasons. This parameter is new in wxWidgets 2.9.2.</para></parameterdescription>
</parameteritem>
</parameterlist>
See <ref refid="classwx_thread_1thread_deletion" kindref="member">wxThread Deletion</ref> for a broader explanation of this routine. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1293"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classwx_thread_1a21ccbc2f91bed8d65aeada49a7f8335d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int wxThread::GetCPUCount</definition>
        <argsstring>()</argsstring>
        <name>GetCPUCount</name>
        <briefdescription>
<para>Returns the number of system CPUs or -1 if the value is unknown. </para>        </briefdescription>
        <detaileddescription>
<para>For multi-core systems the returned value is typically the total number of <emphasis>cores</emphasis>, since the OS usually abstract a single N-core CPU as N different cores.</para><para><simplesect kind="see"><para><ref refid="classwx_thread_1a09dfe3800bbfad53be303a4608d52959" kindref="member">SetConcurrency()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1081"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a414fecfb855a7e12088bb0fa54ebd330" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>wxThreadIdType</type>
        <definition>static wxThreadIdType wxThread::GetCurrentId</definition>
        <argsstring>()</argsstring>
        <name>GetCurrentId</name>
        <briefdescription>
<para>Returns the platform specific thread ID of the current thread as a long. </para>        </briefdescription>
        <detaileddescription>
<para>This can be used to uniquely identify threads, even if they are not wxThreads.</para><para><simplesect kind="see"><para><ref refid="classwx_thread_1a0023e6e671b016f06c452f34dd6ce8f4" kindref="member">GetMainId()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1090"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a0023e6e671b016f06c452f34dd6ce8f4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>wxThreadIdType</type>
        <definition>static wxThreadIdType wxThread::GetMainId</definition>
        <argsstring>()</argsstring>
        <name>GetMainId</name>
        <briefdescription>
<para>Returns the thread ID of the main thread. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="classwx_thread_1a1ee917ef87f986ba3b2ee26e620378e4" kindref="member">IsMain()</ref></para></simplesect>
<simplesect kind="since"><para>2.9.1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1113"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a1ee917ef87f986ba3b2ee26e620378e4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool wxThread::IsMain</definition>
        <argsstring>()</argsstring>
        <name>IsMain</name>
        <briefdescription>
<para>Returns true if the calling thread is the main application thread. </para>        </briefdescription>
        <detaileddescription>
<para>Main thread in the context of wxWidgets is the one which initialized the library.</para><para><simplesect kind="see"><para><ref refid="classwx_thread_1a0023e6e671b016f06c452f34dd6ce8f4" kindref="member">GetMainId()</ref>, <ref refid="classwx_thread_1a414fecfb855a7e12088bb0fa54ebd330" kindref="member">GetCurrentId()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1149"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a09dfe3800bbfad53be303a4608d52959" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool wxThread::SetConcurrency</definition>
        <argsstring>(size_t level)</argsstring>
        <name>SetConcurrency</name>
        <param>
          <type>size_t</type>
          <declname>level</declname>
        </param>
        <briefdescription>
<para>Sets the thread concurrency level for this process. </para>        </briefdescription>
        <detaileddescription>
<para>This is, roughly, the number of threads that the system tries to schedule to run in parallel. The value of 0 for <emphasis>level</emphasis> may be used to set the default one.</para><para><simplesect kind="return"><para>true on success or false otherwise (for example, if this function is not implemented for this platform -- currently everything except Solaris). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1234"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a9ae47b39270c54dba5534af31f885ec6" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void wxThread::Sleep</definition>
        <argsstring>(unsigned long milliseconds)</argsstring>
        <name>Sleep</name>
        <param>
          <type>unsigned long</type>
          <declname>milliseconds</declname>
        </param>
        <briefdescription>
<para>Pauses the thread execution for the given amount of time. </para>        </briefdescription>
        <detaileddescription>
<para>This is the same as <ref refid="group__group__funcmacro__time_1ga66778879349f76fd833902d3767006fa" kindref="member">wxMilliSleep()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1252"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a7077fa46ffef0fd1d023628776598335" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classwx_thread" kindref="compound">wxThread</ref> *</type>
        <definition>static wxThread* wxThread::This</definition>
        <argsstring>()</argsstring>
        <name>This</name>
        <briefdescription>
<para>Return the thread object for the calling thread. </para>        </briefdescription>
        <detaileddescription>
<para>NULL is returned if the calling thread is the main (GUI) thread, but <ref refid="classwx_thread_1a1ee917ef87f986ba3b2ee26e620378e4" kindref="member">IsMain()</ref> should be used to test whether the thread is really the main one because NULL may also be returned for the thread not created with <ref refid="classwx_thread" kindref="compound">wxThread</ref> class. Generally speaking, the return value for such a thread is undefined. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1273"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a7a36099bab2d4be9d72cfd4cf76e8aa6" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void wxThread::Yield</definition>
        <argsstring>()</argsstring>
        <name>Yield</name>
        <briefdescription>
<para>Give the rest of the thread&apos;s time-slice to the system allowing the other threads to run. </para>        </briefdescription>
        <detaileddescription>
<para>Note that using this function is <bold>strongly</bold> discouraged, since in many cases it indicates a design weakness of your threading model (as does using <ref refid="classwx_thread_1a9ae47b39270c54dba5534af31f885ec6" kindref="member">Sleep()</ref> functions).</para><para>Threads should use the CPU in an efficient manner, i.e. they should do their current work efficiently, then as soon as the work is done block on a wakeup event (<ref refid="classwx_condition" kindref="compound">wxCondition</ref>, <ref refid="classwx_mutex" kindref="compound">wxMutex</ref>, select(), poll(), ...) which will get signalled e.g. by other threads or a user device once further thread work is available. Using <ref refid="classwx_thread_1a7a36099bab2d4be9d72cfd4cf76e8aa6" kindref="member">Yield()</ref> or <ref refid="classwx_thread_1a9ae47b39270c54dba5534af31f885ec6" kindref="member">Sleep()</ref> indicates polling-type behaviour, since we&apos;re fuzzily giving up our timeslice and wait until sometime later we&apos;ll get reactivated, at which time we realize that there isn&apos;t really much to do and <ref refid="classwx_thread_1a7a36099bab2d4be9d72cfd4cf76e8aa6" kindref="member">Yield()</ref> again...</para><para>The most critical characteristic of <ref refid="classwx_thread_1a7a36099bab2d4be9d72cfd4cf76e8aa6" kindref="member">Yield()</ref> is that it&apos;s operating system specific: there may be scheduler changes which cause your thread to not wake up relatively soon again, but instead many seconds later, causing huge performance issues for your application.</para><para><bold> With a well-behaving, CPU-efficient thread the operating system is likely to properly care for its reactivation the moment it needs it, whereas with non-deterministic, Yield-using threads all bets are off and the system scheduler is free to penalize them drastically</bold>, and this effect gets worse with increasing system load due to less free CPU resources available. You may refer to various Linux kernel <computeroutput>sched_yield</computeroutput> discussions for more information.</para><para>See also <ref refid="classwx_thread_1a9ae47b39270c54dba5534af31f885ec6" kindref="member">Sleep()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1329"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" prot="protected" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="classwx_thread_1ade9497fa072fe19481086e6486dcc028" kindref="member">ExitCode</ref></type>
        <definition>virtual ExitCode wxThread::Entry</definition>
        <argsstring>()=0</argsstring>
        <name>Entry</name>
        <briefdescription>
<para>This is the entry point of the thread. </para>        </briefdescription>
        <detaileddescription>
<para>This function is pure virtual and must be implemented by any derived class. The thread execution will start here.</para><para>The returned value is the thread exit code which is only useful for joinable threads and is the value returned by <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref>. This function is called by wxWidgets itself and should never be called directly. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1344"/>
      </memberdef>
      <memberdef kind="function" id="classwx_thread_1a888b9b94f64a2b61bd4740de1149e6e2" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void wxThread::Exit</definition>
        <argsstring>(ExitCode exitcode=0)</argsstring>
        <name>Exit</name>
        <param>
          <type><ref refid="classwx_thread_1ade9497fa072fe19481086e6486dcc028" kindref="member">ExitCode</ref></type>
          <declname>exitcode</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>This is a protected function of the <ref refid="classwx_thread" kindref="compound">wxThread</ref> class and thus can only be called from a derived class. </para>        </briefdescription>
        <detaileddescription>
<para>It also can only be called in the context of this thread, i.e. a thread can only exit from itself, not from another thread.</para><para>This function will terminate the OS thread (i.e. stop the associated path of execution) and also delete the associated C++ object for detached threads. OnExit() will be called just before exiting. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1355"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classwx_thread_1acf4e4a34c3acd45d52bcb03d1a2e79fe" prot="private" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void wxThread::OnExit</definition>
        <argsstring>()</argsstring>
        <name>OnExit</name>
        <briefdescription>
<para>Called when the thread exits. </para>        </briefdescription>
        <detaileddescription>
<para>This function is called in the context of the thread associated with the <ref refid="classwx_thread" kindref="compound">wxThread</ref> object, not in the context of the main thread. This function will not be called if the thread was <ref refid="classwx_thread_1a2cbff8b3b0a93ab82f212c02f38a1ef4" kindref="member">Kill()</ref> killed.</para><para>This function should never be called directly. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="1368"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A thread is basically a path of execution through a program. </para>    </briefdescription>
    <detaileddescription>
<para>Threads are sometimes called <emphasis>light-weight</emphasis> processes, but the fundamental difference between threads and processes is that memory spaces of different processes are separated while all threads share the same address space.</para><para>While it makes it much easier to share common data between several threads, it also makes it much easier to shoot oneself in the foot, so careful use of synchronization objects such as mutexes (see <ref refid="classwx_mutex" kindref="compound">wxMutex</ref>) or critical sections (see <ref refid="classwx_critical_section" kindref="compound">wxCriticalSection</ref>) is recommended. In addition, don&apos;t create global thread objects because they allocate memory in their constructor, which will cause problems for the memory checking system.</para><sect1 id="classwx_thread_1thread_types">
<title>Types of wxThreads</title>
<para>There are two types of threads in wxWidgets: <emphasis>detached</emphasis> and <emphasis>joinable</emphasis>, modeled after the POSIX thread API. This is different from the Win32 API where all threads are joinable.</para><para>By default wxThreads in wxWidgets use the <bold>detached</bold> behaviour. Detached threads delete themselves once they have completed, either by themselves when they complete processing or through a call to <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref>, and thus <bold>must</bold> be created on the heap (through the new operator, for example).</para><para>Typically you&apos;ll want to store the instances of the detached wxThreads you allocate, so that you can call functions on them. Because of their nature however you&apos;ll need to always use a critical section when accessing them:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>declare<sp/>a<sp/>new<sp/>type<sp/>of<sp/>event,<sp/>to<sp/>be<sp/>used<sp/>by<sp/>our<sp/>MyThread<sp/>class:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1ga767b12d37f7370bc5f6b3d62340f3ef8" kindref="member" tooltip="Declares a custom event type.">wxDECLARE_EVENT</ref>(wxEVT_COMMAND_MYTHREAD_COMPLETED,<sp/><ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1ga767b12d37f7370bc5f6b3d62340f3ef8" kindref="member" tooltip="Declares a custom event type.">wxDECLARE_EVENT</ref>(wxEVT_COMMAND_MYTHREAD_UPDATE,<sp/><ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyFrame;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyThread<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classwx_thread" kindref="compound" tooltip="A thread is basically a path of execution through a program.">wxThread</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MyThread(MyFrame<sp/>*handler)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><ref refid="classwx_thread" kindref="compound" tooltip="A thread is basically a path of execution through a program.">wxThread</ref>(<ref refid="interface_2wx_2thread_8h_1a0dc9a167e8d084946512da99b37b5fd0acd9af5dbbc12a95684ab6e7be16e30c9" kindref="member" tooltip="Detached thread.">wxTHREAD_DETACHED</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/>m_pHandler<sp/>=<sp/>handler<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>~MyThread();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">protected</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/><ref refid="classwx_thread_1ade9497fa072fe19481086e6486dcc028" kindref="member" tooltip="The return type for the thread functions.">ExitCode</ref><sp/><ref refid="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" kindref="member" tooltip="This is the entry point of the thread.">Entry</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MyFrame<sp/>*m_pHandler;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyFrame<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classwx_frame" kindref="compound" tooltip="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>~MyFrame()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>it&apos;s<sp/>better<sp/>to<sp/>do<sp/>any<sp/>thread<sp/>cleanup<sp/>in<sp/>the<sp/>OnClose()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>event<sp/>handler,<sp/>rather<sp/>than<sp/>in<sp/>the<sp/>destructor.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>because<sp/>the<sp/>event<sp/>loop<sp/>for<sp/>a<sp/>top-level<sp/>window<sp/>is<sp/>not</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>active<sp/>anymore<sp/>when<sp/>its<sp/>destructor<sp/>is<sp/>called<sp/>and<sp/>if<sp/>the<sp/>thread</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>sends<sp/>events<sp/>when<sp/>ending,<sp/>they<sp/>won&apos;t<sp/>be<sp/>processed<sp/>unless</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>you<sp/>ended<sp/>the<sp/>thread<sp/>from<sp/>OnClose.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>See<sp/>@ref<sp/>overview_windowdeletion<sp/>for<sp/>more<sp/>info.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DoStartThread();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DoPauseThread();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>resume<sp/>routine<sp/>would<sp/>be<sp/>nearly<sp/>identic<sp/>to<sp/>DoPauseThread()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DoResumeThread()<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnThreadUpdate(<ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>&amp;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnThreadCompletion(<ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>&amp;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnClose(<ref refid="classwx_close_event" kindref="compound" tooltip="This event class contains information about window and session close events.">wxCloseEvent</ref>&amp;);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">protected</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MyThread<sp/>*m_pThread;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_critical_section" kindref="compound" tooltip="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</ref><sp/>m_pThreadCS;<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>protects<sp/>the<sp/>m_pThread<sp/>pointer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1gab6eca03fad44ec10b75d3cb82e9219e3" kindref="member" tooltip="Use this macro inside a class declaration to declare a static event table for that class...">wxDECLARE_EVENT_TABLE</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1ga736930efaab4d7e445e9e8e520c7b74d" kindref="member" tooltip="Use this macro in a source file to start listing static event handlers for a specific class...">wxBEGIN_EVENT_TABLE</ref>(MyFrame,<sp/><ref refid="classwx_frame" kindref="compound" tooltip="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EVT_CLOSE(MyFrame::OnClose)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EVT_MENU(Minimal_Start,<sp/><sp/>MyFrame::DoStartThread)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EVT_COMMAND(<ref refid="defs_8h_1ac66d0a09761e7d86b2ac0b2e0c6a8cbba1f375b01ea03a713bbb7e32a36a2589c" kindref="member" tooltip="Any id: means that we don&amp;#39;t care about the id, whether when installing an event handler or when creat...">wxID_ANY</ref>,<sp/>wxEVT_COMMAND_MYTHREAD_UPDATE,<sp/>MyFrame::OnThreadUpdate)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EVT_COMMAND(wxID_ANY,<sp/>wxEVT_COMMAND_MYTHREAD_COMPLETED,<sp/>MyFrame::OnThreadCompletion)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1ga383fad2a46e1d6c220fbe03ecfbc9c17" kindref="member" tooltip="Use this macro in a source file to end listing static event handlers for a specific class...">wxEND_EVENT_TABLE</ref>()</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1ga09ec1d095bee3085c1cb31459b46bc00" kindref="member" tooltip="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</ref>(wxEVT_COMMAND_MYTHREAD_COMPLETED,<sp/><ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1ga09ec1d095bee3085c1cb31459b46bc00" kindref="member" tooltip="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</ref>(wxEVT_COMMAND_MYTHREAD_UPDATE,<sp/><ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::DoStartThread()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pThread<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>MyThread(</highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>m_pThread-&gt;Create()<sp/>!=<sp/><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" kindref="member" tooltip="No error.">wxTHREAD_NO_ERROR</ref><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__log_1ga0dd3c633f990f794e76065c9a7af4c87" kindref="member" tooltip="The functions to use for error messages, i.e.">wxLogError</ref>(</highlight><highlight class="stringliteral">&quot;Can&apos;t<sp/>create<sp/>the<sp/>thread!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal"><sp/>m_pThread;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pThread<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pThread-&gt;Run()<sp/>!=<sp/><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" kindref="member" tooltip="No error.">wxTHREAD_NO_ERROR</ref><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__log_1ga0dd3c633f990f794e76065c9a7af4c87" kindref="member" tooltip="The functions to use for error messages, i.e.">wxLogError</ref>(</highlight><highlight class="stringliteral">&quot;Can&apos;t<sp/>create<sp/>the<sp/>thread!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal"><sp/>m_pThread;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pThread<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>after<sp/>the<sp/>call<sp/>to<sp/>wxThread::Run(),<sp/>the<sp/>m_pThread<sp/>pointer<sp/>is<sp/>&quot;unsafe&quot;:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>at<sp/>any<sp/>moment<sp/>the<sp/>thread<sp/>may<sp/>cease<sp/>to<sp/>exist<sp/>(because<sp/>it<sp/>completes<sp/>its<sp/>work).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>To<sp/>avoid<sp/>dangling<sp/>pointers<sp/>OnThreadExit()<sp/>will<sp/>set<sp/>m_pThread</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>to<sp/>NULL<sp/>when<sp/>the<sp/>thread<sp/>dies.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_thread_1ade9497fa072fe19481086e6486dcc028" kindref="member" tooltip="The return type for the thread functions.">wxThread::ExitCode</ref><sp/><ref refid="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" kindref="member" tooltip="This is the entry point of the thread.">MyThread::Entry</ref>()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!<ref refid="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" kindref="member" tooltip="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy</ref>())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/>do<sp/>a<sp/>bit<sp/>of<sp/>work...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1gae921d7bd0e52fedbf3f253d2c408bce1" kindref="member" tooltip="Queue an event for processing on the given object.">wxQueueEvent</ref>(m_pHandler,<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/><ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>(wxEVT_COMMAND_MYTHREAD_UPDATE));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>signal<sp/>the<sp/>event<sp/>handler<sp/>that<sp/>this<sp/>thread<sp/>is<sp/>going<sp/>to<sp/>be<sp/>destroyed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>NOTE:<sp/>here<sp/>we<sp/>assume<sp/>that<sp/>using<sp/>the<sp/>m_pHandler<sp/>pointer<sp/>is<sp/>safe,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/>(in<sp/>this<sp/>case<sp/>this<sp/>is<sp/>assured<sp/>by<sp/>the<sp/>MyFrame<sp/>destructor)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__events_1gae921d7bd0e52fedbf3f253d2c408bce1" kindref="member" tooltip="Queue an event for processing on the given object.">wxQueueEvent</ref>(m_pHandler,<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/><ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>(wxEVT_COMMAND_MYTHREAD_COMPLETED));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="classwx_thread_1ade9497fa072fe19481086e6486dcc028" kindref="member" tooltip="The return type for the thread functions.">wxThread::ExitCode</ref>)0;<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>success</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MyThread::~MyThread()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_critical_section_locker" kindref="compound" tooltip="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</ref><sp/>enter(m_pHandler-&gt;m_pThreadCS);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>thread<sp/>is<sp/>being<sp/>destroyed;<sp/>make<sp/>sure<sp/>not<sp/>to<sp/>leave<sp/>dangling<sp/>pointers<sp/>around</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pHandler-&gt;m_pThread<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::OnThreadCompletion(<ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>&amp;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_message_output_debug" kindref="compound" tooltip="Output messages to the system debug output channel.">wxMessageOutputDebug</ref>().<ref refid="classwx_message_output_1a233e76ce6c1b569f16b42b49151ab979" kindref="member" tooltip="Output a message.">Printf</ref>(</highlight><highlight class="stringliteral">&quot;MYFRAME:<sp/>MyThread<sp/>exited!\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::OnThreadUpdate(<ref refid="classwx_thread_event" kindref="compound" tooltip="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</ref>&amp;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_message_output_debug" kindref="compound" tooltip="Output messages to the system debug output channel.">wxMessageOutputDebug</ref>().<ref refid="classwx_message_output_1a233e76ce6c1b569f16b42b49151ab979" kindref="member" tooltip="Output a message.">Printf</ref>(</highlight><highlight class="stringliteral">&quot;MYFRAME:<sp/>MyThread<sp/>update...\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::DoPauseThread()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>anytime<sp/>we<sp/>access<sp/>the<sp/>m_pThread<sp/>pointer<sp/>we<sp/>must<sp/>ensure<sp/>that<sp/>it<sp/>won&apos;t</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>be<sp/>modified<sp/>in<sp/>the<sp/>meanwhile;<sp/>since<sp/>only<sp/>a<sp/>single<sp/>thread<sp/>may<sp/>be</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>inside<sp/>a<sp/>given<sp/>critical<sp/>section<sp/>at<sp/>a<sp/>given<sp/>time,<sp/>the<sp/>following<sp/>code</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>is<sp/>safe:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_critical_section_locker" kindref="compound" tooltip="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</ref><sp/>enter(m_pThreadCS);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pThread)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>does<sp/>the<sp/>thread<sp/>still<sp/>exist?</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>without<sp/>a<sp/>critical<sp/>section,<sp/>once<sp/>reached<sp/>this<sp/>point<sp/>it<sp/>may<sp/>happen</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>the<sp/>OS<sp/>scheduler<sp/>gives<sp/>control<sp/>to<sp/>the<sp/>MyThread::Entry()<sp/>function,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>which<sp/>in<sp/>turn<sp/>may<sp/>return<sp/>(because<sp/>it<sp/>completes<sp/>its<sp/>work)<sp/>making</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>invalid<sp/>the<sp/>m_pThread<sp/>pointer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pThread-&gt;Pause()<sp/>!=<sp/><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" kindref="member" tooltip="No error.">wxTHREAD_NO_ERROR</ref><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__log_1ga0dd3c633f990f794e76065c9a7af4c87" kindref="member" tooltip="The functions to use for error messages, i.e.">wxLogError</ref>(</highlight><highlight class="stringliteral">&quot;Can&apos;t<sp/>pause<sp/>the<sp/>thread!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MyFrame::OnClose(<ref refid="classwx_close_event" kindref="compound" tooltip="This event class contains information about window and session close events.">wxCloseEvent</ref>&amp;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_critical_section_locker" kindref="compound" tooltip="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</ref><sp/>enter(m_pThreadCS);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pThread)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>does<sp/>the<sp/>thread<sp/>still<sp/>exist?</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_message_output_debug" kindref="compound" tooltip="Output messages to the system debug output channel.">wxMessageOutputDebug</ref>().<ref refid="classwx_message_output_1a233e76ce6c1b569f16b42b49151ab979" kindref="member" tooltip="Output a message.">Printf</ref>(</highlight><highlight class="stringliteral">&quot;MYFRAME:<sp/>deleting<sp/>thread&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pThread-&gt;Delete()<sp/>!=<sp/><ref refid="interface_2wx_2thread_8h_1a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" kindref="member" tooltip="No error.">wxTHREAD_NO_ERROR</ref><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__funcmacro__log_1ga0dd3c633f990f794e76065c9a7af4c87" kindref="member" tooltip="The functions to use for error messages, i.e.">wxLogError</ref>(</highlight><highlight class="stringliteral">&quot;Can&apos;t<sp/>delete<sp/>the<sp/>thread!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>exit<sp/>from<sp/>the<sp/>critical<sp/>section<sp/>to<sp/>give<sp/>the<sp/>thread</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>possibility<sp/>to<sp/>enter<sp/>its<sp/>destructor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(which<sp/>is<sp/>guarded<sp/>with<sp/>m_pThreadCS<sp/>critical<sp/>section!)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/></highlight><highlight class="comment">//<sp/>was<sp/>the<sp/>~MyThread()<sp/>function<sp/>executed?</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_critical_section_locker" kindref="compound" tooltip="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</ref><sp/>enter(m_pThreadCS);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_pThread)<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>wait<sp/>for<sp/>thread<sp/>completion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classwx_thread_1a7077fa46ffef0fd1d023628776598335" kindref="member" tooltip="Return the thread object for the calling thread.">wxThread::This</ref>()-&gt;<ref refid="classwx_thread_1a9ae47b39270c54dba5534af31f885ec6" kindref="member" tooltip="Pauses the thread execution for the given amount of time.">Sleep</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Destroy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting></para><para>For a more detailed and comprehensive example, see <ref refid="page_samples_1page_samples_thread" kindref="member">Thread Sample</ref>. For a simpler way to share data and synchronization objects between the main and the secondary thread see <ref refid="classwx_thread_helper" kindref="compound">wxThreadHelper</ref>.</para><para>Conversely, <bold>joinable</bold> threads do not delete themselves when they are done processing and as such are safe to create on the stack. Joinable threads also provide the ability for one to get value it returned from <ref refid="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" kindref="member">Entry()</ref> through <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref>. You shouldn&apos;t hurry to create all the threads joinable, however, because this has a disadvantage as well: you <bold>must</bold> <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref> for a joinable thread or the system resources used by it will never be freed, and you also must delete the corresponding <ref refid="classwx_thread" kindref="compound">wxThread</ref> object yourself if you did not create it on the stack. In contrast, detached threads are of the &quot;fire-and-forget&quot; kind: you only have to start a detached thread and it will terminate and destroy itself.</para></sect1>
<sect1 id="classwx_thread_1thread_deletion">
<title>wxThread Deletion</title>
<para>Regardless of whether it has terminated or not, you should call <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref> on a <bold>joinable</bold> thread to release its memory, as outlined in <ref refid="classwx_thread_1thread_types" kindref="member">Types of wxThreads</ref>. If you created a joinable thread on the heap, remember to delete it manually with the <computeroutput>delete</computeroutput> operator or similar means as only detached threads handle this type of memory management.</para><para>Since <bold>detached</bold> threads delete themselves when they are finished processing, you should take care when calling a routine on one. If you are certain the thread is still running and would like to end it, you may call <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref> to gracefully end it (which implies that the thread will be deleted after that call to <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref>). It should be implied that you should <bold>never</bold> attempt to delete a detached thread with the <computeroutput>delete</computeroutput> operator or similar means.</para><para>As mentioned, <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref> or <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref> functions attempt to gracefully terminate a joinable and a detached thread, respectively. They do this by waiting until the thread in question calls <ref refid="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" kindref="member">TestDestroy()</ref> or ends processing (i.e. returns from <ref refid="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" kindref="member">wxThread::Entry</ref>).</para><para>Obviously, if the thread does call <ref refid="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" kindref="member">TestDestroy()</ref> and does not end, the thread which called <ref refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" kindref="member">Wait()</ref> or <ref refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" kindref="member">Delete()</ref> will come to halt. This is why it&apos;s important to call <ref refid="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" kindref="member">TestDestroy()</ref> in the <ref refid="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" kindref="member">Entry()</ref> routine of your threads as often as possible and immediately exit when it returns true.</para><para>As a last resort you can end the thread immediately through <ref refid="classwx_thread_1a2cbff8b3b0a93ab82f212c02f38a1ef4" kindref="member">Kill()</ref>. It is strongly recommended that you do not do this, however, as it does not free the resources associated with the object (although the <ref refid="classwx_thread" kindref="compound">wxThread</ref> object of detached threads will still be deleted) and could leave the C runtime library in an undefined state.</para></sect1>
<sect1 id="classwx_thread_1thread_secondary">
<title>wxWidgets Calls in Secondary Threads</title>
<para>All threads other than the &quot;main application thread&quot; (the one running <ref refid="classwx_app_console_1a99953775a2fd83fa2456e390779afe15" kindref="member">wxApp::OnInit()</ref> or the one your main function runs in, for example) are considered &quot;secondary threads&quot;. These include all threads created by <ref refid="classwx_thread_1a88051a33aa3fa9ca9392ac7d47b43cf4" kindref="member">Create()</ref> or the corresponding constructors.</para><para>GUI calls, such as those to a <ref refid="classwx_window" kindref="compound">wxWindow</ref> or <ref refid="classwx_bitmap" kindref="compound">wxBitmap</ref> are explicitly not safe at all in secondary threads and could end your application prematurely. This is due to several reasons, including the underlying native API and the fact that <ref refid="classwx_thread" kindref="compound">wxThread</ref> does not run a GUI event loop similar to other APIs as MFC.</para><para>A workaround for some wxWidgets ports is calling wxMutexGUIEnter() before any GUI calls and then calling wxMutexGUILeave() afterwords. However, the recommended way is to simply process the GUI calls in the main thread through an event that is posted by <ref refid="group__group__funcmacro__events_1gae921d7bd0e52fedbf3f253d2c408bce1" kindref="member">wxQueueEvent()</ref>. This does not imply that calls to these classes are thread-safe, however, as most wxWidgets classes are not thread-safe, including <ref refid="classwx_string" kindref="compound">wxString</ref>.</para></sect1>
<sect1 id="classwx_thread_1thread_poll">
<title>Don&apos;t Poll a wxThread</title>
<para>A common problem users experience with <ref refid="classwx_thread" kindref="compound">wxThread</ref> is that in their main thread they will check the thread every now and then to see if it has ended through <ref refid="classwx_thread_1a0230733ffdc8f7603082dd2ca86b8cdd" kindref="member">IsRunning()</ref>, only to find that their application has run into problems because the thread is using the default behaviour (i.e. it&apos;s <bold>detached</bold>) and has already deleted itself. Naturally, they instead attempt to use joinable threads in place of the previous behaviour. However, polling a <ref refid="classwx_thread" kindref="compound">wxThread</ref> for when it has ended is in general a bad idea - in fact calling a routine on any running <ref refid="classwx_thread" kindref="compound">wxThread</ref> should be avoided if possible. Instead, find a way to notify yourself when the thread has ended.</para><para>Usually you only need to notify the main thread, in which case you can post an event to it via <ref refid="group__group__funcmacro__events_1gae921d7bd0e52fedbf3f253d2c408bce1" kindref="member">wxQueueEvent()</ref>. In the case of secondary threads you can call a routine of another class when the thread is about to complete processing and/or set the value of a variable, possibly using mutexes (see <ref refid="classwx_mutex" kindref="compound">wxMutex</ref>) and/or other synchronization means if necessary.</para><para><heading level="2"></heading>
</para><para>Library:<nonbreakablespace/><nonbreakablespace/><ref refid="page_libs_1page_libs_wxbase" kindref="member">wxBase</ref></para><para>Category:<nonbreakablespace/><nonbreakablespace/><ref refid="group__group__class__threading" kindref="compound">Threading</ref></para><para><simplesect kind="see"><para><ref refid="classwx_thread_helper" kindref="compound">wxThreadHelper</ref>, <ref refid="classwx_mutex" kindref="compound">wxMutex</ref>, <ref refid="classwx_condition" kindref="compound">wxCondition</ref>, <ref refid="classwx_critical_section" kindref="compound">wxCriticalSection</ref>, <ref refid="overview_thread" kindref="compound">Multithreading Overview</ref> </para></simplesect>
</para></sect1>
    </detaileddescription>
    <location file="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" line="989" bodyfile="/home/jgm/Development/wxWidgets-svn/interface/wx/thread.h" bodystart="988" bodyend="1369"/>
    <listofallmembers>
      <member refid="classwx_thread_1a88051a33aa3fa9ca9392ac7d47b43cf4" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Create</name></member>
      <member refid="classwx_thread_1a66796042bf5f3eb33a0ad3db85f686d4" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Delete</name></member>
      <member refid="classwx_thread_1af50fa7d3ac55002e367e79989b9cbc5d" prot="protected" virt="pure-virtual"><scope>wxThread</scope><name>Entry</name></member>
      <member refid="classwx_thread_1a888b9b94f64a2b61bd4740de1149e6e2" prot="protected" virt="non-virtual"><scope>wxThread</scope><name>Exit</name></member>
      <member refid="classwx_thread_1ade9497fa072fe19481086e6486dcc028" prot="public" virt="non-virtual"><scope>wxThread</scope><name>ExitCode</name></member>
      <member refid="classwx_thread_1a21ccbc2f91bed8d65aeada49a7f8335d" prot="public" virt="non-virtual"><scope>wxThread</scope><name>GetCPUCount</name></member>
      <member refid="classwx_thread_1a414fecfb855a7e12088bb0fa54ebd330" prot="public" virt="non-virtual"><scope>wxThread</scope><name>GetCurrentId</name></member>
      <member refid="classwx_thread_1a2c9db3ca1d37d8ed921e78c31acd9bb4" prot="public" virt="non-virtual"><scope>wxThread</scope><name>GetId</name></member>
      <member refid="classwx_thread_1a1fc5fa753cf2bc0ec63ff16825a144b2" prot="public" virt="non-virtual"><scope>wxThread</scope><name>GetKind</name></member>
      <member refid="classwx_thread_1a0023e6e671b016f06c452f34dd6ce8f4" prot="public" virt="non-virtual"><scope>wxThread</scope><name>GetMainId</name></member>
      <member refid="classwx_thread_1a785ac6add565d789481f8a9dfde5c229" prot="public" virt="non-virtual"><scope>wxThread</scope><name>GetPriority</name></member>
      <member refid="classwx_thread_1adc6cf71c426b1da03c6ca4b7f7da8aab" prot="public" virt="non-virtual"><scope>wxThread</scope><name>IsAlive</name></member>
      <member refid="classwx_thread_1a315c2abb553ba7e17ab2d5b2a0728e73" prot="public" virt="non-virtual"><scope>wxThread</scope><name>IsDetached</name></member>
      <member refid="classwx_thread_1a1ee917ef87f986ba3b2ee26e620378e4" prot="public" virt="non-virtual"><scope>wxThread</scope><name>IsMain</name></member>
      <member refid="classwx_thread_1a34328ecb720a1066971fb5e48cd84b6f" prot="public" virt="non-virtual"><scope>wxThread</scope><name>IsPaused</name></member>
      <member refid="classwx_thread_1a0230733ffdc8f7603082dd2ca86b8cdd" prot="public" virt="non-virtual"><scope>wxThread</scope><name>IsRunning</name></member>
      <member refid="classwx_thread_1a2cbff8b3b0a93ab82f212c02f38a1ef4" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Kill</name></member>
      <member refid="classwx_thread_1acf4e4a34c3acd45d52bcb03d1a2e79fe" prot="private" virt="virtual"><scope>wxThread</scope><name>OnExit</name></member>
      <member refid="classwx_thread_1a8c6d835578dde71dd2c241c38336a4ba" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Pause</name></member>
      <member refid="classwx_thread_1afe81d37cd6cb6d5eb142773fb2c94562" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Resume</name></member>
      <member refid="classwx_thread_1a5d894750ffaac8fc42ee85aeff8bb4c0" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Run</name></member>
      <member refid="classwx_thread_1a09dfe3800bbfad53be303a4608d52959" prot="public" virt="non-virtual"><scope>wxThread</scope><name>SetConcurrency</name></member>
      <member refid="classwx_thread_1a6236828fe98e81103219a519fbd7091d" prot="public" virt="non-virtual"><scope>wxThread</scope><name>SetPriority</name></member>
      <member refid="classwx_thread_1a9ae47b39270c54dba5534af31f885ec6" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Sleep</name></member>
      <member refid="classwx_thread_1a9a3acec44b06b2a2430c5659991a3eac" prot="public" virt="virtual"><scope>wxThread</scope><name>TestDestroy</name></member>
      <member refid="classwx_thread_1a7077fa46ffef0fd1d023628776598335" prot="public" virt="non-virtual"><scope>wxThread</scope><name>This</name></member>
      <member refid="classwx_thread_1a62ee778033013d3a4754b71b8cf2902e" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Wait</name></member>
      <member refid="classwx_thread_1aafdb64801bd4d595ad0956f71d5791f0" prot="public" virt="non-virtual"><scope>wxThread</scope><name>wxThread</name></member>
      <member refid="classwx_thread_1a7a36099bab2d4be9d72cfd4cf76e8aa6" prot="public" virt="non-virtual"><scope>wxThread</scope><name>Yield</name></member>
      <member refid="classwx_thread_1a48c37f3555eb99cca9d9f3594fed5793" prot="public" virt="virtual"><scope>wxThread</scope><name>~wxThread</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
