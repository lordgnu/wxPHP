<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.4">
  <compounddef id="overview_thread" kind="page">
    <compoundname>overview_thread</compoundname>
    <title>Multithreading Overview</title>
    <detaileddescription>
<para>Classes: <ref refid="classwx_thread" kindref="compound">wxThread</ref>, <ref refid="classwx_thread_helper" kindref="compound">wxThreadHelper</ref>, <ref refid="classwx_mutex" kindref="compound">wxMutex</ref>, <ref refid="classwx_critical_section" kindref="compound">wxCriticalSection</ref>, <ref refid="classwx_condition" kindref="compound">wxCondition</ref>, <ref refid="classwx_semaphore" kindref="compound">wxSemaphore</ref></para><sect1 id="overview_thread_1overview_thread_intro">
<title>When to use multiple threads</title>
<para>wxWidgets provides a complete set of classes encapsulating objects necessary in multithreaded (MT) programs: the <ref refid="classwx_thread" kindref="compound">wxThread</ref> class itself and different synchronization objects: mutexes (see <ref refid="classwx_mutex" kindref="compound">wxMutex</ref>) and critical sections (see <ref refid="classwx_critical_section" kindref="compound">wxCriticalSection</ref>) with conditions (see <ref refid="classwx_condition" kindref="compound">wxCondition</ref>). The thread API in wxWidgets resembles to POSIX1.c threads API (a.k.a. pthreads), although several functions have different names and some features inspired by Win32 thread API are there as well.</para><para>These classes hopefully make writing MT programs easier and they also provide some extra error checking (compared to the native - be it Win32 or Posix - thread API), however it is still a non-trivial undertaking especially for large projects. Before starting an MT application (or starting to add MT features to an existing one) it is worth asking oneself if there is no easier and safer way to implement the same functionality. Of course, in some situations threads really make sense (classical example is a server application which launches a new thread for each new client), but in others it might be an overkill. On the other hand, the recent evolution of the computer hardware shows an important trend towards multi-core systems, which are better exploited using multiple threads (e.g. you may want to split a long task among as many threads as many CPU (cores) the system reports; see <ref refid="classwx_thread_1a21ccbc2f91bed8d65aeada49a7f8335d" kindref="member">wxThread::GetCPUCount</ref>).</para><para>To implement non-blocking operations <emphasis>without</emphasis> using multiple threads you have two possible implementation choices:<itemizedlist>
<listitem><para>use <ref refid="classwx_idle_event" kindref="compound">wxIdleEvent</ref> (e.g. to perform a long calculation while updating a progress dialog)</para></listitem><listitem><para>do everything at once but call <ref refid="classwx_window_1abaf28f1a075fd1b10f761a8febe597ec" kindref="member">wxWindow::Update()</ref> or wxApp::YieldFor(wxEVT_CATEGORY_UI) periodically to update the screen. If instead you choose to use threads in your application, please read also the following sections of this overview.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="overview_thread_1overview_thread_notes">
<title>Important notes for multithreaded applications</title>
<para>When writing a multi-threaded application, it is strongly recommended that <bold>no secondary threads call GUI functions</bold>. The design which uses one GUI thread and several worker threads which communicate with the main one using <bold>events</bold> is much more robust and will undoubtedly save you countless problems (example: under Win32 a thread can only access GDI objects such as pens, brushes, device contexts created by itself and not by the other threads).</para><para>For communication between secondary threads and the main thread, you may use <ref refid="classwx_evt_handler_1acffd03bf407a856166ea71ef0318b59a" kindref="member">wxEvtHandler::QueueEvent</ref> or its short version <ref refid="group__group__funcmacro__events_1gae921d7bd0e52fedbf3f253d2c408bce1" kindref="member">wxQueueEvent</ref>. These functions have a thread-safe implementation so that they can be used as they are for sending events from one thread to another. However there is no built in method to send messages to the worker threads and you will need to use the available synchronization classes to implement the solution which suits your needs yourself. In particular, please note that it is not enough to derive your class from <ref refid="classwx_thread" kindref="compound">wxThread</ref> and <ref refid="classwx_evt_handler" kindref="compound">wxEvtHandler</ref> to send messages to it: in fact, this does not work at all. You&apos;re instead encouraged to use <ref refid="classwx_thread_helper" kindref="compound">wxThreadHelper</ref> as it greatly simplifies the communication and the sharing of resources.</para><para>You should also look at the <ref refid="classwx_thread" kindref="compound">wxThread</ref> docs for important notes about secondary threads and their deletion.</para><para>Last, remember that if <ref refid="classwx_event_loop_base_1afb5ed08160c7e6b1364170af6115af55" kindref="member">wxEventLoopBase::YieldFor()</ref> is used directly or indirectly (e.g. through <ref refid="classwx_progress_dialog" kindref="compound">wxProgressDialog</ref>) in your code, then you may have both re-entrancy problems and also problems caused by the processing of events out of order. To resolve the last problem <ref refid="classwx_thread_event" kindref="compound">wxThreadEvent</ref> can be used: thanks to its implementation of the <ref refid="classwx_thread_event_1a21a87c9ffaa750f3daf05fb628fe9251" kindref="member">wxThreadEvent::GetEventCategory</ref> function <ref refid="classwx_thread_event" kindref="compound">wxThreadEvent</ref> classes in fact do not get processed by <ref refid="classwx_event_loop_base_1afb5ed08160c7e6b1364170af6115af55" kindref="member">wxEventLoopBase::YieldFor()</ref> unless you specify the <computeroutput>wxEVT_CATEGORY_THREAD</computeroutput> flag.</para><para>See also the <ref refid="page_samples_1page_samples_thread" kindref="member">Thread Sample</ref> for a sample showing some simple interactions between the main and secondary threads. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
