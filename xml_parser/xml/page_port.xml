<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.4">
  <compounddef id="page_port" kind="page">
    <compoundname>page_port</compoundname>
    <title>Platform Details</title>
    <detaileddescription>
<para>wxWidgets defines a common API across platforms, but uses the native graphical user interface (GUI) on each platform, so your program will take on the native look and feel that users are familiar with.</para><para>Unfortunately native toolkits and hardware do not always support the functionality that the wxWidgets API requires. This chapter collects notes about differences among supported platforms and ports.</para><para><itemizedlist>
<listitem><para><ref refid="page_port_1page_port_wxgtk" kindref="member">wxGTK</ref> </para></listitem>
<listitem><para><ref refid="page_port_1page_port_wxosx" kindref="member">wxOSX</ref> </para></listitem>
<listitem><para><ref refid="page_port_1page_port_wxos2" kindref="member">wxOS2</ref> </para></listitem>
<listitem><para><ref refid="page_port_1page_port_wxx11" kindref="member">wxX11</ref> </para></listitem>
<listitem><para><ref refid="page_port_1page_port_wxmotif" kindref="member">wxMotif</ref> </para></listitem>
<listitem><para><ref refid="page_port_1page_port_wxmsw" kindref="member">wxMSW</ref> </para></listitem>
<listitem><para><ref refid="page_port_1page_port_nativedocs" kindref="member">Documentation for the native toolkits</ref></para></listitem>
</itemizedlist>
<hruler/>
</para><sect1 id="page_port_1page_port_wxgtk">
<title>wxGTK</title>
<para><htmlonly> 
&lt;img src=&quot;logo_gtk.png&quot; alt=&quot;GTK logo&quot; title=&quot;GTK logo&quot; class=&quot;logo&quot;&gt;
</htmlonly></para><para>wxGTK is a port of wxWidgets using the GTK+ library. It makes use of GTK+&apos;s native widgets wherever possible and uses wxWidgets&apos; generic controls when needed. GTK+ itself has been ported to a number of systems, but so far only the original X11 version is supported. Support for other GTK+ backends is planned, such as the new DirectFB backend.</para><para>All work is being done on GTK+ version 2.0 and above. Support for GTK+ 1.2 will be deprecated in a later release.</para><para>You will need GTK+ 2.6 or higher which is available from:</para><para><ulink url="http://www.gtk.org">http://www.gtk.org</ulink></para><para>The newer version of GTK+ you use, the more native widgets and features will be utilized. We have gone to great lengths to allow compiling wxWidgets applications with the latest version of GTK+, with the resulting binary working on systems even with a much earlier version of GTK+. You will have to ensure that the application is launched with lazy symbol binding for that.</para><para>In order to configure wxWidgets to compile wxGTK you will need use the <computeroutput>--with-gtk</computeroutput> argument to the <computeroutput>configure</computeroutput> script. This is the default for many systems.</para><para>GTK+ 1.2 can still be used, albeit discouraged. For that you can pass <computeroutput>--with-gtk=1</computeroutput> to the <computeroutput>configure</computeroutput> script.</para><para>For further information, please see the files in <computeroutput>docs/gtk</computeroutput> in the distribution.</para></sect1>
<sect1 id="page_port_1page_port_wxosx">
<title>wxOSX</title>
<para><htmlonly> 
&lt;img src=&quot;logo_osxleopard.png&quot; alt=&quot;Mac OS X (Leopard) logo&quot;
    title=&quot;Mac OS X (Leopard) logo&quot; class=&quot;logo&quot;&gt;
</htmlonly></para><sect2 id="page_port_1page_port_wxosx_carbon">
<title>wxOSX/Carbon</title>
<para>wxOSX/Carbon is a port of wxWidgets for the Macintosh OS platform. Currently MacOS X 10.4 or higher are supported. wxOSX/Carbon can be compiled both using Apple&apos;s command line developer tools as well as Apple&apos;s Xcode IDE. wxOSX/Carbon supports both the Intel and PowerPC architectures and can be used to produce &quot;universal binaries&quot; in order create application which can run both architecture. Unfortunately, wxOSX/Carbon does not support any 64-bit architecture since Apple decided not to port its Carbon API entirely to 64-bit.</para><para><simplesect kind="note"><para>Carbon has been deprecated by Apple as of OS X 10.5 and will likely be removed entirely in a future OS version. It&apos;s recommended you look into switching your app over to wxOSX/Cocoa as soon as possible.</para></simplesect>
For further information, please see the files in <computeroutput>docs/osx</computeroutput> in the distribution.</para></sect2>
<sect2 id="page_port_1page_port_wxosx_cocoa">
<title>wxOSX/Cocoa</title>
<para>wxOSX/Cocoa is another port of wxWidgets for the Macintosh OS platform. In contrast to wxOSX/Carbon, it uses the Cocoa API in place of Carbon. Much work has gone into this port and many controls are functional, but the port has not reached the maturity of the wxOSX/Carbon port yet. It is possible to use wxOSX/Cocoa on 64-bit architectures.</para><para>In order to configure wxWidgets to compile wxOSX/Cocoa you will need to type:</para><para><verbatim>configure --with-osx_cocoa </verbatim></para><para>For further information, please see the files in <computeroutput>docs/osx</computeroutput> in the distribution.</para><para><simplesect kind="note"><para>There was a previous effort towards a Cocoa port called wxCocoa, which was implemented totally with Cocoa API unlike the OSX/Cocoa port which uses OS X C APIs to share code, and while it is no longer being actively developed, docs for it are available in <computeroutput>docs/cocoa</computeroutput> in the distribution.</para></simplesect>
</para></sect2>
</sect1>
<sect1 id="page_port_1page_port_wxos2">
<title>wxOS2</title>
<para>wxOS2 is a port of wxWidgets for the IBM OS/2 Warp3 and Warp4 platforms. This port is currently under construction and in beta phase.</para><para>For further information, please see the files in <computeroutput>docs/os2</computeroutput> in the distribution.</para></sect1>
<sect1 id="page_port_1page_port_wxx11">
<title>wxX11</title>
<para><htmlonly> 
&lt;img src=&quot;logo_x11.png&quot; alt=&quot;X.org logo&quot; title=&quot;X.org logo&quot; class=&quot;logo&quot;&gt;
</htmlonly></para><para>wxX11 is a port of wxWidgets using X11 (The X Window System) as the underlying graphics backend. wxX11 draws its widgets using the wxUniversal widget set which is now part of wxWidgets. wxX11 is well-suited for a number of special applications such as those running on systems with few resources (PDAs) or for applications which need to use a special themed look.</para><para>In order to configure wxWidgets to compile wxX11 you will need to type:</para><para><verbatim>configure --with-x11 --with-universal </verbatim></para><para>For further information, please see the files in <computeroutput>docs/x11</computeroutput> in the distribution. There is also a page on the use of wxWidgets for embedded applications on the wxWidgets web site.</para></sect1>
<sect1 id="page_port_1page_port_wxmotif">
<title>wxMotif</title>
<para><htmlonly> 
&lt;img src=&quot;logo_motif.png&quot; alt=&quot;Motif logo&quot; title=&quot;Motif logo&quot; class=&quot;logo&quot;&gt;
</htmlonly></para><para>wxMotif is a port of wxWidgets for X11 systems using Motif libraries. Motif libraries provide a clean and fast user interface at the expense of the beauty and candy of newer interfaces like GTK.</para><para>For further information, please see the files in <computeroutput>docs/motif</computeroutput> in the distribution.</para></sect1>
<sect1 id="page_port_1page_port_wxmsw">
<title>wxMSW</title>
<para><htmlonly> 
&lt;img src=&quot;logo_win.png&quot; alt=&quot;Windows logo&quot; title=&quot;Windows logo&quot; class=&quot;logo&quot;&gt;
</htmlonly></para><para>wxMSW is a port of wxWidgets for the Windows platforms including Windows 95, 98, ME, 2000, NT, XP and Vista in ANSI and Unicode modes (for Windows 9x and ME through the MSLU extension library). wxMSW ensures native look and feel for XP when using wxWidgets version 2.3.3 or higher.wxMSW can be compiled with a great variety of compilers including Microsoft Studio VC++, Borland 5.5, MinGW32, Cygwin and Watcom as well as cross-compilation with a Linux-hosted MinGW32 tool chain.</para><para>For further information, please see the files in docs/msw in the distribution.</para><sect2 id="page_port_1page_port_wxmsw_themedborders">
<title>Themed borders on Windows</title>
<para>Starting with wxWidgets 2.8.5, you can specify the <computeroutput>wxBORDER_THEME</computeroutput> style to have wxWidgets use a themed border. Using the default XP theme, this is a thin 1-pixel blue border, with an extra 1-pixel border in the window client background colour (usually white) to separate the client area&apos;s scrollbars from the border.</para><para>If you don&apos;t specify a border style for a <ref refid="classwx_text_ctrl" kindref="compound">wxTextCtrl</ref> in rich edit mode, wxWidgets now gives the control themed borders automatically, where previously they would take the Windows 95-style sunken border. Other native controls such as <ref refid="classwx_text_ctrl" kindref="compound">wxTextCtrl</ref> in non-rich edit mode, and <ref refid="classwx_combo_box" kindref="compound">wxComboBox</ref> already paint themed borders where appropriate. To use themed borders on other windows, such as <ref refid="classwx_panel" kindref="compound">wxPanel</ref>, pass the <computeroutput>wxBORDER_THEME</computeroutput> style, or (apart from <ref refid="classwx_panel" kindref="compound">wxPanel</ref>) pass no border style.</para><para>In general, specifying <computeroutput>wxBORDER_THEME</computeroutput> will cause a border of some kind to be used, chosen by the platform and control class. To leave the border decision entirely to wxWidgets, pass <computeroutput>wxBORDER_DEFAULT</computeroutput>. This is not to be confused with specifying <computeroutput>wxBORDER_NONE</computeroutput>, which says that there should definitely be <emphasis>no</emphasis> border.</para><sect3 id="page_port_1page_port_wxmsw_themedborders_details">
<title>More detail on border implementation</title>
<para>The way that wxMSW decides whether to apply a themed border is as follows. The theming code calls <ref refid="classwx_window_1ad95a95e683e57ac6365745b737571582" kindref="member">wxWindow::GetBorder()</ref> to obtain a border. If no border style has been passed to the window constructor, GetBorder() calls GetDefaultBorder() for this window. If wxBORDER_THEME was passed to the window constructor, GetBorder() calls GetDefaultBorderForControl().</para><para>The implementation of wxWindow::GetDefaultBorder() on wxMSW calls wxWindow::CanApplyThemeBorder() which is a virtual function that tells wxWidgets whether a control can have a theme applied explicitly (some native controls already paint a theme in which case we should not apply it ourselves). Note that <ref refid="classwx_panel" kindref="compound">wxPanel</ref> is an exception to this rule because in many cases we wish to create a window with no border (for example, notebook pages). So <ref refid="classwx_panel" kindref="compound">wxPanel</ref> overrides GetDefaultBorder() in order to call the generic wxWindowBase::GetDefaultBorder(), returning wxBORDER_NONE.</para></sect3>
</sect2>
<sect2 id="page_port_1page_port_wxmsw_wince">
<title>wxWinCE</title>
<para>wxWinCE is the name given to wxMSW when compiled on Windows CE devices; most of wxMSW is common to Win32 and Windows CE but there are some simplifications, enhancements, and differences in behaviour.</para><para>For building instructions, see docs/msw/wince in the distribution, also the section about Visual Studio 2005 project files below. The rest of this section documents issues you need to be aware of when programming for Windows CE devices.</para><sect3 id="page_port_1page_port_wxmsw_wince_">
<title>General issues for wxWinCE programming</title>
<para>Mobile applications generally have fewer features and simpler user interfaces. Simply omit whole sizers, static lines and controls in your dialogs, and use comboboxes instead of listboxes where appropriate. You also need to reduce the amount of spacing used by sizers, for which you can use a macro such as this:</para><para><programlisting><codeline><highlight class="preprocessor">#if<sp/>defined(__WXWINCE__)</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>wxLARGESMALL(large,small)<sp/>small</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="preprocessor">#else</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>wxLARGESMALL(large,small)<sp/>large</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Usage</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">topsizer-&gt;<ref refid="classwx_sizer_1a4e2122f2749261473c21cb192d00709f" kindref="member" tooltip="Appends a child to the sizer.">Add</ref>(<sp/>CreateTextSizer(<sp/>message<sp/>),<sp/>0,<sp/><ref refid="defs_8h_1ac0f30319732dcceda470516918ff3556a066863c82a2c08f6f53b663de87c60b6" kindref="member">wxALL</ref>,<sp/>wxLARGESMALL(10,0)<sp/>);</highlight></codeline>
</programlisting></para><para>There is only ever one instance of a Windows CE application running, and wxWidgets will take care of showing the current instance and shutting down the second instance if necessary.</para><para>You can test the return value of <ref refid="classwx_system_settings_1af8a2e5d2411eb520b8dad5fc5e9a1a7a" kindref="member">wxSystemSettings::GetScreenType()</ref> for a qualitative assessment of what kind of display is available, or use <ref refid="group__group__funcmacro__gdi_1gaefd6b970b2fa62bfc00f386da06ab286" kindref="member">wxGetDisplaySize()</ref> if you need more information.</para><para>You can also use wxGetOsVersion to test for a version of Windows CE at run-time (see the next section). However, because different builds are currently required to target different kinds of device, these values are hard-wired according to the build, and you cannot dynamically adapt the same executable for different major Windows CE platforms. This would require a different approach to the way wxWidgets adapts its behaviour (such as for menubars) to suit the style of device.</para><para>See the &quot;Life!&quot; example (demos/life) for an example of an application that has been tailored for PocketPC and Smartphone use.</para><para><simplesect kind="note"><para>don&apos;t forget to have this line in your .rc file, as for desktop Windows applications:</para></simplesect>
<verbatim>#include &quot;wx/msw/wx.rc&quot; </verbatim></para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_sdk">
<title>Testing for WinCE SDKs</title>
<para>Use these preprocessor symbols to test for the different types of device or SDK:</para><para><itemizedlist>
<listitem><para><bold>__SMARTPHONE__</bold> Generic mobile devices with phone buttons and a small display </para></listitem>
<listitem><para><bold>__PDA__</bold> Generic mobile devices with no phone </para></listitem>
<listitem><para><bold>__HANDHELDPC__</bold> Generic mobile device with a keyboard </para></listitem>
<listitem><para><bold>__WXWINCE__</bold> Microsoft-powered Windows CE devices, whether PocketPC, Smartphone or Standard SDK </para></listitem>
<listitem><para><bold>WIN32_PLATFORM_WFSP</bold> Microsoft-powered smartphone </para></listitem>
<listitem><para><bold>__POCKETPC__</bold> Microsoft-powered PocketPC devices with touch-screen </para></listitem>
<listitem><para><bold>__WINCE_STANDARDSDK__</bold> Microsoft-powered Windows CE devices, for generic Windows CE applications </para></listitem>
<listitem><para><bold>__WINCE_NET__</bold> Microsoft-powered Windows CE .NET devices (_WIN32_WCE is 400 or greater)</para></listitem>
</itemizedlist>
wxGetOsVersion will return these values:</para><para><itemizedlist>
<listitem><para><bold>wxWINDOWS_POCKETPC</bold> The application is running under PocketPC. </para></listitem>
<listitem><para><bold>wxWINDOWS_SMARTPHONE</bold> The application is running under Smartphone. </para></listitem>
<listitem><para><bold>wxWINDOWS_CE</bold> The application is running under Windows CE (built with the Standard SDK).</para></listitem>
</itemizedlist>
</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_sizing">
<title>Window sizing in wxWinCE</title>
<para>Top level windows (dialogs, frames) are created always full-screen. Fit() of sizers will not rescale top level windows but instead will scale window content.</para><para>If the screen orientation changes, the windows will automatically be resized so no further action needs to be taken (unless you want to change the layout according to the orientation, which you could detect in idle time, for example). When input panel (SIP) is shown, top level windows (frames and dialogs) resize accordingly (see <ref refid="classwx_top_level_window_1ac804159a17302c7e805d70ff4911318c" kindref="member">wxTopLevelWindow::HandleSettingChange()</ref>).</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_toplevel">
<title>Closing top-level windows in wxWinCE</title>
<para>You won&apos;t get a <ref refid="classwx_close_event" kindref="compound">wxCloseEvent</ref> when the user clicks on the X in the titlebar on Smartphone and PocketPC; the window is simply hidden instead. However the system may send the event to force the application to close down.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_hibernation">
<title>Hibernation in wxWinCE</title>
<para>Smartphone and PocketPC will send a <computeroutput>wxEVT_HIBERNATE</computeroutput> to the application object in low memory conditions. Your application should release memory and close dialogs, and wake up again when the next <computeroutput>wxEVT_ACTIVATE</computeroutput> or <computeroutput>wxEVT_ACTIVATE_APP</computeroutput> message is received. (<computeroutput>wxEVT_ACTIVATE_APP</computeroutput> is generated whenever a <computeroutput>wxEVT_ACTIVATE</computeroutput> event is received in Smartphone and PocketPC, since these platforms do not support <computeroutput>WM_ACTIVATEAPP</computeroutput>.)</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_hwbutt">
<title>Hardware buttons in wxWinCE</title>
<para>Special hardware buttons are sent to a window via the <computeroutput>wxEVT_HOTKEY</computeroutput> event under Smartphone and PocketPC. You should first register each required button with <ref refid="classwx_window_1a53ca57872dac5851ea6ba55a494b899b" kindref="member">wxWindow::RegisterHotKey()</ref>, and unregister the button when you&apos;re done with it. For example:</para><para><programlisting><codeline><highlight class="normal">win-&gt;<ref refid="classwx_window_1a53ca57872dac5851ea6ba55a494b899b" kindref="member" tooltip="Registers a system wide hotkey.">RegisterHotKey</ref>(0,<sp/><ref refid="defs_8h_1a5b81968ab866f5874cabc504490ae5cda5a287f69b590d3fd245970caaa61a8da" kindref="member">wxMOD_WIN</ref>,<sp/><ref refid="defs_8h_1a41c4609211685cff198618963ec8f77dabde23340ad1723b2b641cc10fd319bb0" kindref="member" tooltip="Hardware-specific buttons.">WXK_SPECIAL1</ref>);</highlight></codeline>
<codeline><highlight class="normal">win-&gt;<ref refid="classwx_window_1a695f60d65f8f6c12e3c3645ad9c0c35b" kindref="member" tooltip="Unregisters a system wide hotkey.">UnregisterHotKey</ref>(0);</highlight></codeline>
</programlisting></para><para>You may have to register the buttons in a <computeroutput>wxEVT_ACTIVATE</computeroutput> event handler since other applications will grab the buttons.</para><para>There is currently no method of finding out the names of the special buttons or how many there are.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_dialogs">
<title>Dialogs in wxWinCE</title>
<para>PocketPC dialogs have an OK button on the caption, and so you should generally not repeat an OK button on the dialog. You can add a Cancel button if necessary, but some dialogs simply don&apos;t offer you the choice (the guidelines recommend you offer an Undo facility to make up for it). When the user clicks on the OK button, your dialog will receive a <computeroutput>wxID_OK</computeroutput> event by default. If you wish to change this, call <ref refid="classwx_dialog_1a72ea7e269bedb2552bfeaccdbac07939" kindref="member">wxDialog::SetAffirmativeId()</ref> with the required identifier to be used. Or, override <ref refid="classwx_dialog_1a08a07820be45f6c6fcde5c9e2f786389" kindref="member">wxDialog::DoOK()</ref> (return false to have wxWidgets simply call Close to dismiss the dialog).</para><para>Smartphone dialogs do <emphasis>not</emphasis> have an OK button on the caption, and are closed using one of the two menu buttons. You need to assign these using <ref refid="classwx_top_level_window_1a198cff4212ff5342c0c4358b59274fd5" kindref="member">wxTopLevelWindow::SetLeftMenu</ref> and <ref refid="classwx_top_level_window_1a98e95b1b10f44b80f9b29a03ab09a879" kindref="member">wxTopLevelWindow::SetRightMenu()</ref>, for example:</para><para><programlisting><codeline><highlight class="preprocessor">#ifdef<sp/>__SMARTPHONE__</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/>SetLeftMenu(<ref refid="defs_8h_1ac66d0a09761e7d86b2ac0b2e0c6a8cbbaeeb1bdf97306d7f0fdffb62c8af3d02f" kindref="member" tooltip="Standard button and menu IDs.">wxID_OK</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SetRightMenu(<ref refid="defs_8h_1ac66d0a09761e7d86b2ac0b2e0c6a8cbba27aec3f2d4b5cf0e36c028bbab048206" kindref="member">wxID_CANCEL</ref>,<sp/><ref refid="group__group__funcmacro__string_1ga8a02b8875a521df57263a9e6f090f2d0" kindref="member" tooltip="Macro to be used around all literal strings that should be translated.">_</ref>(</highlight><highlight class="stringliteral">&quot;Cancel&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined(__POCKETPC__)</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>OK/Cancel<sp/>buttons<sp/>on<sp/>PocketPC,<sp/>OK<sp/>on<sp/>caption<sp/>will<sp/>close</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/>topsizer-&gt;<ref refid="classwx_sizer_1a4e2122f2749261473c21cb192d00709f" kindref="member" tooltip="Appends a child to the sizer.">Add</ref>(<sp/>CreateButtonSizer(<sp/><ref refid="defs_8h_1a9c40266b61a27f0124a69a699753889a" kindref="member">wxOK</ref>|<ref refid="defs_8h_1a5580412e224117ac127aacaafd49dc2e" kindref="member">wxCANCEL</ref><sp/>),<sp/>0,<sp/><ref refid="defs_8h_1a27b6b668631a5f79f24d474af7d9b388a0d831bd6985c81f9bbc4830cc0c2e7df" kindref="member">wxEXPAND</ref><sp/>|<sp/><ref refid="defs_8h_1ac0f30319732dcceda470516918ff3556a066863c82a2c08f6f53b663de87c60b6" kindref="member">wxALL</ref>,<sp/>10<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para><para>For implementing property sheets (flat tabs), use a <ref refid="classwx_notebook" kindref="compound">wxNotebook</ref> with <computeroutput>wxNB_FLAT|wxNB_BOTTOM</computeroutput> and have the notebook left, top and right sides overlap the dialog by about 3 pixels to eliminate spurious borders. You can do this by using a negative spacing in your sizer Add() call. The cross-platform property sheet dialog <ref refid="classwx_property_sheet_dialog" kindref="compound">wxPropertySheetDialog</ref> is provided, to show settings in the correct style on PocketPC and on other platforms.</para><para>Notifications (bubble HTML text with optional buttons and links) will also be implemented in the future for PocketPC.</para><para>Modeless dialogs probably don&apos;t make sense for PocketPC and Smartphone, since frames and dialogs are normally full-screen, and a modeless dialog is normally intended to co-exist with the main application frame.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_ppc">
<title>Menubars and toolbars in PocketPC</title>
<para>On PocketPC, a frame must always have a menubar, even if it&apos;s empty. An empty menubar/toolbar is automatically provided for dialogs, to hide any existing menubar for the duration of the dialog.</para><para>Menubars and toolbars are implemented using a combined control, but you can use essentially the usual wxWidgets API; wxWidgets will combine the menubar and toolbar. However, there are some restrictions:</para><para><itemizedlist>
<listitem><para>You must create the frame&apos;s primary toolbar with <ref refid="classwx_frame_1a529698edc2fd2037ac8578dadafad0e2" kindref="member">wxFrame::CreateToolBar()</ref>, because this uses the special wxToolMenuBar class (derived from <ref refid="classwx_tool_bar" kindref="compound">wxToolBar</ref>) to implement the combined toolbar and menubar. Otherwise, you can create and manage toolbars using the <ref refid="classwx_tool_bar" kindref="compound">wxToolBar</ref> class as usual, for example to implement an optional formatting toolbar above the menubar as Pocket Word does. But don&apos;t assign a <ref refid="classwx_tool_bar" kindref="compound">wxToolBar</ref> to a frame using SetToolBar - you should always use CreateToolBar for the main frame toolbar. </para></listitem>
<listitem><para>Deleting and adding tools to wxToolMenuBar after Realize is called is not supported. </para></listitem>
<listitem><para>For speed, colours are not remapped to the system colours as they are in wxMSW. Provide the tool bitmaps either with the correct system button background, or with transparency (for example, using XPMs). </para></listitem>
<listitem><para>Adding controls to wxToolMenuBar is not supported. However, <ref refid="classwx_tool_bar" kindref="compound">wxToolBar</ref> supports controls.</para></listitem>
</itemizedlist>
Unlike in all other ports, a <ref refid="classwx_dialog" kindref="compound">wxDialog</ref> has a <ref refid="classwx_tool_bar" kindref="compound">wxToolBar</ref> automatically created for you. You may either leave it blank, or access it with <ref refid="classwx_dialog_1a80c76ed6b8f6eb92992f816e1a987f80" kindref="member">wxDialog::GetToolBar()</ref> and add buttons, then calling <ref refid="classwx_tool_bar_1abb31ce337a2d3c1e30e8e3748905ecbf" kindref="member">wxToolBar::Realize()</ref>. You cannot set or recreate the toolbar.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_smart">
<title>Menubars and toolbars in Smartphone</title>
<para>On Smartphone, there are only two menu buttons, so a menubar is simulated using a nested menu on the right menu button. Any toolbars are simply ignored on Smartphone.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_closing">
<title>Closing windows in wxWinCE</title>
<para>The guidelines state that applications should not have a Quit menu item, since the user should not have to know whether an application is in memory or not. The close button on a window does not call the window&apos;s close handler; it simply hides the window. However, the guidelines say that the Ctrl+Q accelerator can be used to quit the application, so wxWidgets defines this accelerator by default and if your application handles wxID_EXIT, it will do the right thing.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_ctx">
<title>Context menus in wxWinCE</title>
<para>To enable context menus in PocketPC, you currently need to call wxWindow::EnableContextMenu(), a wxWinCE-only function. Otherwise the context menu event (<ref refid="classwx_context_menu_event" kindref="compound">wxContextMenuEvent</ref>) will never be sent. This API is subject to change.</para><para>Context menus are not supported in Smartphone.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_ctrl">
<title>Control differences on wxWinCE</title>
<para>These controls and styles are specific to wxWinCE:</para><para><itemizedlist>
<listitem><para><ref refid="classwx_text_ctrl" kindref="compound">wxTextCtrl</ref> The <computeroutput>wxTE_CAPITALIZE</computeroutput> style causes a CAPEDIT control to be created, which capitalizes the first letter.</para></listitem>
</itemizedlist>
These controls are missing from wxWinCE:</para><para><itemizedlist>
<listitem><para>MDI classes MDI is not supported under Windows CE. </para></listitem>
<listitem><para><ref refid="classwx_mini_frame" kindref="compound">wxMiniFrame</ref> Not supported under Windows CE.</para></listitem>
</itemizedlist>
Tooltips are not currently supported for controls, since on PocketPC controls with tooltips are distinct controls, and it will be hard to add dynamic tooltip support.</para><para>Control borders on PocketPC and Smartphone should normally be specified with <computeroutput>wxBORDER_SIMPLE</computeroutput> instead of <computeroutput>wxBORDER_SUNKEN</computeroutput>. Controls will usually adapt appropriately by virtue of their GetDefaultBorder() function, but if you wish to specify a style explicitly you can use <computeroutput>wxDEFAULT_CONTROL_BORDER</computeroutput> which will give a simple border on PocketPC and Smartphone, and the sunken border on other platforms.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_help">
<title>Online help in wxWinCE</title>
<para>You can use the help controller wxWinceHelpController which controls simple <computeroutput></computeroutput>.htm files, usually installed in the Windows directory. See the Windows CE reference for how to format the HTML files.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_install">
<title>Installing your PocketPC and Smartphone applications</title>
<para>To install your application, you need to build a CAB file using the parameters defined in a special .inf file. The CabWiz program in your SDK will compile the CAB file from the .inf file and files that it specifies.</para><para>For delivery, you can simply ask the user to copy the CAB file to the device and execute the CAB file using File Explorer. Or, you can write a program for the desktop PC that will find the ActiveSync Application Manager and install the CAB file on the device, which is obviously much easier for the user.</para><para>Here are some links that may help.</para><para><itemizedlist>
<listitem><para>A setup builder that takes CABs and builds a setup program is at <ulink url="http://www.eskimo.com/~scottlu/win/index.html.">http://www.eskimo.com/~scottlu/win/index.html.</ulink> </para></listitem>
<listitem><para>Sample installation files can be found in <computeroutput>Windows CE Tools/wce420/POCKET PC 2003/Samples/Win32/AppInst</computeroutput>. </para></listitem>
<listitem><para>An installer generator using wxPython can be found at <ulink url="http://ppcquicksoft.iespana.es/ppcquicksoft/myinstall.html.">http://ppcquicksoft.iespana.es/ppcquicksoft/myinstall.html.</ulink> </para></listitem>
<listitem><para>Miscellaneous Windows CE resources can be found at <ulink url="http://www.orbworks.com/pcce/resources.html.">http://www.orbworks.com/pcce/resources.html.</ulink> </para></listitem>
<listitem><para>Installer creation instructions with a setup.exe for installing to PPC can be found at <ulink url="http://www.pocketpcdn.com/articles/creatingsetup.html.">http://www.pocketpcdn.com/articles/creatingsetup.html.</ulink> </para></listitem>
<listitem><para>Microsoft instructions are at <ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnce30/html/appinstall30.asp?frame=true">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnce30/html/appinstall30.asp?frame=true</ulink> </para></listitem>
<listitem><para>Troubleshooting WinCE application installations: <ulink url="http://support.microsoft.com/default.aspx?scid=KB;en-us;q181007">http://support.microsoft.com/default.aspx?scid=KB;en-us;q181007</ulink></para></listitem>
</itemizedlist>
You may also check out <computeroutput>demos/life/setup/wince</computeroutput> which contains scripts to create a PocketPC installation for ARM-based devices. In particular, <computeroutput>build.bat</computeroutput> builds the distribution and copies it to a directory called <computeroutput>Deliver</computeroutput>.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_filedlg">
<title>wxFileDialog in PocketPC</title>
<para>Allowing the user to access files on memory cards, or on arbitrary parts of the filesystem, is a pain; the standard file dialog only shows folders under My Documents or folders on memory cards (not the system or card root directory, for example). This is a known problem for PocketPC developers.</para><para>If you need a file dialog that allows access to all folders, you can use wxGenericFileDialog instead. You will need to include <computeroutput>wx/generic/filedlgg.h</computeroutput>.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_evc">
<title>Embedded Visual C++ Issues</title>
<para><bold>Run-time type information</bold></para><para>If you wish to use runtime type information (RTTI) with eVC++ 4, you need to download an extra library, <computeroutput>ccrtrtti.lib</computeroutput>, and link with it. At the time of writing you can get it from here:</para><para><verbatim>
http://support.microsoft.com/kb/830482/en-us
</verbatim></para><para>Otherwise you will get linker errors similar to this:</para><para><verbatim>
wxwince26d.lib(control.obj) : error LNK2001: unresolved external symbol &quot;const type_info::`vftable&apos;&quot; (??_7type_info@@6B@)
</verbatim></para><para><bold>Windows Mobile 5.0 emulator</bold></para><para>Note that there is no separate emulator configuration for Windows Mobile 5.0: the emulator runs the ARM code directly.</para><para><bold>Visual Studio 2005 project files</bold></para><para>Unfortunately, Visual Studio 2005, required to build Windows Mobile 5.0 applications, doesn&apos;t do a perfect job of converting the project files from eVC++ format.</para><para>When you have converted the wxWidgets workspace, edit the configuration properties for each configuration and in the Librarian, add a relative path ..\..\lib to each library path. For example: <computeroutput>..\\\wx_mono.lib</computeroutput>.</para><para>Then, for a sample you want to compile, edit the configuration properties and make sure <computeroutput>..\..\lib\\</computeroutput> is in the Linker/General/Additional Library Directories property. Also change the Linker/Input/Additional Dependencies property to something like <computeroutput>coredll.lib wx_mono.lib wx_wxjpeg.lib wx_wxpng.lib wx_wxzlib.lib wx_wxexpat.lib commctrl.lib winsock.lib wininet.lib</computeroutput> (since the library names in the wxWidgets workspace were changed by VS 2005).</para><para>Alternately, you could edit all the names to be identical to the original eVC++ names, but this will probably be more fiddly.</para></sect3>
<sect3 id="page_port_1page_port_wxmsw_wince_issues">
<title>Remaining issues</title>
<para>These are some of the remaining problems to be sorted out, and features to be supported.</para><para><itemizedlist>
<listitem><para><bold>Windows Mobile 5 issues.</bold> It is not possible to get the HMENU for the command bar on Mobile 5, so the menubar functions need to be rewritten to get the individual menus without use of a menubar handle. Also the new Mobile 5 convention of using only two menus (and no bitmap buttons) needs to be considered. </para></listitem>
<listitem><para><bold>Sizer speed.</bold> Particularly for dialogs containing notebooks, layout seems slow. Some analysis is required. </para></listitem>
<listitem><para><bold>Notification boxes.</bold> The balloon-like notification messages, and their icons, should be implemented. This will be quite straightforward. </para></listitem>
<listitem><para><bold>SIP size.</bold> We need to be able to get the area taken up by the SIP (input panel), and the remaining area, by calling SHSipInfo. We also may need to be able to show and hide the SIP programmatically, with SHSipPreference. See also the <emphasis>Input Dialogs</emphasis> topic in the <emphasis>Programming Windows CE</emphasis> guide for more on this, and how to have dialogs show the SIP automatically using the <computeroutput>WC_SIPREF</computeroutput> control. </para></listitem>
<listitem><para><bold><ref refid="classwx_static_bitmap" kindref="compound">wxStaticBitmap</ref>.</bold> The About box in the &quot;Life!&quot; demo shows a bitmap that is the correct size on the emulator, but too small on a VGA Pocket Loox device. </para></listitem>
<listitem><para><bold><ref refid="classwx_static_line" kindref="compound">wxStaticLine</ref>.</bold> Lines don&apos;t show up, and the documentation suggests that missing styles are implemented with <computeroutput>WM_PAINT</computeroutput>. </para></listitem>
<listitem><para><bold>HTML control.</bold> PocketPC has its own HTML control which can be used for showing local pages or navigating the web. We should create a version of <ref refid="classwx_html_window" kindref="compound">wxHtmlWindow</ref> that uses this control, or have a separately-named control (wxHtmlCtrl), with a syntax as close as possible to <ref refid="classwx_html_window" kindref="compound">wxHtmlWindow</ref>. </para></listitem>
<listitem><para><bold>Tooltip control.</bold> PocketPC uses special TTBUTTON and TTSTATIC controls for adding tooltips, with the tooltip separated from the label with a double tilde. We need to support this using SetToolTip.(Unfortunately it does not seem possible to dynamically remove the tooltip, so an extra style may be required.) </para></listitem>
<listitem><para><bold>Focus.</bold> In the <ref refid="classwx_property_sheet_dialog" kindref="compound">wxPropertySheetDialog</ref> demo on Smartphone, it&apos;s not possible to navigate between controls. The focus handling in wxWidgets needs investigation. See in particular src/common/containr.cpp, and note that the default OnActivate handler in src/msw/toplevel.cpp sets the focus to the first child of the dialog. </para></listitem>
<listitem><para><bold>OK button.</bold> We should allow the OK button on a dialog to be optional, perhaps by using <computeroutput>wxCLOSE_BOX</computeroutput> to indicate when the OK button should be displayed. </para></listitem>
<listitem><para><bold>Dynamic adaptation.</bold> We should probably be using run-time tests more than preprocessor tests, so that the same WinCE application can run on different versions of the operating system. </para></listitem>
<listitem><para><bold>Modeless dialogs.</bold> When a modeless dialog is hidden with the OK button, it doesn&apos;t restore the frame&apos;s menubar. See for example the find dialog in the dialogs sample. However, the menubar is restored if pressing Cancel (the window is closed). This reflects the fact that modeless dialogs are not very useful on Windows CE; however, we could perhaps destroy/restore a modeless dialog&apos;s menubar on deactivation and activation. </para></listitem>
<listitem><para><bold>Home screen plugins.</bold> Figure out how to make home screen plugins for use with wxWidgets applications (see <ulink url="http://www.codeproject.com/ce/CTodayWindow.asp">http://www.codeproject.com/ce/CTodayWindow.asp</ulink> for inspiration). Although we can&apos;t use wxWidgets to create the plugin (too large), we could perhaps write a generic plugin that takes registry information from a given application, with options to display information in a particular way using icons and text from a specified location. </para></listitem>
<listitem><para><bold>Further abstraction.</bold> We should be able to abstract away more of the differences between desktop and mobile applications, in particular for sizer layout. </para></listitem>
<listitem><para><bold>Dialog captions.</bold> The blue, bold captions on dialogs - with optional help button - should be catered for, either by hard-wiring the capability into all dialogs and panels, or by providing a standard component and sizer.</para></listitem>
</itemizedlist>
</para></sect3>
</sect2>
</sect1>
<sect1 id="page_port_1page_port_nativedocs">
<title>Documentation for the native toolkits</title>
<para>It&apos;s sometimes useful to interface directly with the underlying toolkit used by wxWidgets to e.g. use toolkit-specific features. In such case (or when you want to e.g. write a port-specific patch) it can be necessary to use the underlying toolkit API directly:</para><para><itemizedlist>
<listitem><para>wxMSW port uses win32 API: see MSDN docs at <ulink url="http://msdn2.microsoft.com/en-us/library/ms649779.aspx">http://msdn2.microsoft.com/en-us/library/ms649779.aspx</ulink></para></listitem><listitem><para>wxGTK port uses GTK+ and other lower-level libraries; see<itemizedlist>
<listitem><para>GTK+ docs at <ulink url="http://library.gnome.org/devel/gtk/unstable/">http://library.gnome.org/devel/gtk/unstable/</ulink></para></listitem><listitem><para>GDK docs at <ulink url="http://library.gnome.org/devel/gdk/unstable/">http://library.gnome.org/devel/gdk/unstable/</ulink></para></listitem><listitem><para>GLib docs at <ulink url="http://library.gnome.org/devel/glib/unstable/">http://library.gnome.org/devel/glib/unstable/</ulink></para></listitem><listitem><para>GObject docs at <ulink url="http://library.gnome.org/devel/gobject/unstable/">http://library.gnome.org/devel/gobject/unstable/</ulink></para></listitem><listitem><para>Pango docs at <ulink url="http://library.gnome.org/devel/pango/unstable/">http://library.gnome.org/devel/pango/unstable/</ulink></para></listitem></itemizedlist>
</para></listitem><listitem><para>wxMac port uses the Carbon API: see Carbon docs at <ulink url="http://developer.apple.com/carbon">http://developer.apple.com/carbon</ulink></para></listitem><listitem><para>wxCocoa port uses the Cocoa API: see Cocoa docs at <ulink url="http://developer.apple.com/cocoa">http://developer.apple.com/cocoa</ulink> </para></listitem></itemizedlist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
