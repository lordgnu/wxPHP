<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.4">
  <compounddef id="overview_string" kind="page">
    <compoundname>overview_string</compoundname>
    <title>wxString Overview</title>
    <detaileddescription>
<para>Classes: <ref refid="classwx_string" kindref="compound">wxString</ref>, <ref refid="classwx_array_string" kindref="compound">wxArrayString</ref>, <ref refid="classwx_string_tokenizer" kindref="compound">wxStringTokenizer</ref></para><para><itemizedlist>
<listitem><para><ref refid="overview_string_1overview_string_intro" kindref="member">Introduction</ref> </para></listitem>
<listitem><para><ref refid="overview_string_1overview_string_internal" kindref="member">Internal wxString encoding</ref> </para></listitem>
<listitem><para><ref refid="overview_string_1overview_string_binary" kindref="member">Using wxString to store binary data</ref> </para></listitem>
<listitem><para><ref refid="overview_string_1overview_string_comparison" kindref="member">Comparison to Other String Classes</ref> </para></listitem>
<listitem><para><ref refid="overview_string_1overview_string_advice" kindref="member">Advice About Using wxString</ref> </para></listitem>
<listitem><para><ref refid="overview_string_1overview_string_related" kindref="member">String Related Functions and Classes</ref> </para></listitem>
<listitem><para><ref refid="overview_string_1overview_string_tuning" kindref="member">Tuning wxString for Your Application</ref> </para></listitem>
<listitem><para><ref refid="overview_string_1overview_string_settings" kindref="member">wxString Related Compilation Settings</ref></para></listitem>
</itemizedlist>
<hruler/>
</para><sect1 id="overview_string_1overview_string_intro">
<title>Introduction</title>
<para><ref refid="classwx_string" kindref="compound">wxString</ref> is a class which represents a Unicode string of arbitrary length and containing arbitrary Unicode characters.</para><para>This class has all the standard operations you can expect to find in a string class: dynamic memory management (string extends to accommodate new characters), construction from other strings, compatibility with C strings and wide character C strings, assignment operators, access to individual characters, string concatenation and comparison, substring extraction, case conversion, trimming and padding (with spaces), searching and replacing and both C-like <computeroutput>printf</computeroutput> (<ref refid="classwx_string_1a9588b7f2684b9a6a924dc3746a2b2f8d" kindref="member">wxString::Printf</ref>) and stream-like insertion functions as well as much more - see <ref refid="classwx_string" kindref="compound">wxString</ref> for a list of all functions.</para><para>The <ref refid="classwx_string" kindref="compound">wxString</ref> class has been completely rewritten for wxWidgets 3.0 but much work has been done to make existing code using ANSI string literals work as it did in previous versions.</para></sect1>
<sect1 id="overview_string_1overview_string_internal">
<title>Internal wxString encoding</title>
<para>Since wxWidgets 3.0 <ref refid="classwx_string" kindref="compound">wxString</ref> internally uses <bold>UTF-16</bold> (with Unicode code units stored in <computeroutput>wchar_t</computeroutput>) under Windows and <bold>UTF-8</bold> (with Unicode code units stored in <computeroutput>char</computeroutput>) under Unix, Linux and Mac OS X to store its content.</para><para>For definitions of <emphasis>code units</emphasis> and <emphasis>code points</emphasis> terms, please see the <ref refid="overview_unicode_1overview_unicode_encodings" kindref="member">Unicode Representations and Terminology</ref> paragraph.</para><para>For simplicity of implementation, <ref refid="classwx_string" kindref="compound">wxString</ref> when <computeroutput>wxUSE_UNICODE_WCHAR==1</computeroutput> (e.g. on Windows) uses <emphasis>per code unit indexing</emphasis> instead of <emphasis>per code point indexing</emphasis> and doesn&apos;t know anything about surrogate pairs; in other words it always considers code points to be composed by 1 code unit, while this is really true only for characters in the <emphasis>BMP</emphasis> (Basic Multilingual Plane). Thus when iterating over a UTF-16 string stored in a <ref refid="classwx_string" kindref="compound">wxString</ref> under Windows, the user code has to take care of <emphasis>surrogate pairs</emphasis> himself. (Note however that Windows itself has built-in support for surrogate pairs in UTF-16, such as for drawing strings on screen.)</para><para><simplesect kind="remark"><para>Note that while the behaviour of <ref refid="classwx_string" kindref="compound">wxString</ref> when <computeroutput>wxUSE_UNICODE_WCHAR==1</computeroutput> resembles UCS-2 encoding, it&apos;s not completely correct to refer to <ref refid="classwx_string" kindref="compound">wxString</ref> as UCS-2 encoded since you can encode code points outside the <emphasis>BMP</emphasis> in a <ref refid="classwx_string" kindref="compound">wxString</ref> as two code units (i.e. as a surrogate pair; as already mentioned however <ref refid="classwx_string" kindref="compound">wxString</ref> will &quot;see&quot; them as two different code points)</para></simplesect>
When instead <computeroutput>wxUSE_UNICODE_UTF8==1</computeroutput> (e.g. on Linux and Mac OS X) <ref refid="classwx_string" kindref="compound">wxString</ref> handles UTF8 multi-bytes sequences just fine also for characters outside the BMP (it implements <emphasis>per code point indexing</emphasis>), so that you can use UTF8 in a completely transparent way:</para><para>Example: <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>first<sp/>test,<sp/>using<sp/>exotic<sp/>characters<sp/>outside<sp/>of<sp/>the<sp/>Unicode<sp/>BMP:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>test<sp/>=<sp/><ref refid="classwx_string_1a2ddc1b7c8e1eb9adbf5874dead5b180b" kindref="member" tooltip="Converts C string encoded in UTF-8 to wxString.">wxString::FromUTF8</ref>(</highlight><highlight class="stringliteral">&quot;\xF0\x90\x8C\x80&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>U+10300<sp/>is<sp/>&quot;OLD<sp/>ITALIC<sp/>LETTER<sp/>A&quot;<sp/>and<sp/>is<sp/>part<sp/>of<sp/>Unicode<sp/>Plane<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>UTF8<sp/>it&apos;s<sp/>encoded<sp/>as<sp/>0xF0<sp/>0x90<sp/>0x8C<sp/>0x80</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>it&apos;s<sp/>a<sp/>single<sp/>Unicode<sp/>code-point<sp/>encoded<sp/>as:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>-<sp/>a<sp/>UTF16<sp/>surrogate<sp/>pair<sp/>under<sp/>Windows</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>-<sp/>a<sp/>UTF8<sp/>multiple-bytes<sp/>sequence<sp/>under<sp/>Linux</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(without<sp/>considering<sp/>the<sp/>final<sp/>NULL)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wxPrintf(</highlight><highlight class="stringliteral">&quot;wxString<sp/>reports<sp/>a<sp/>length<sp/>of<sp/>%d<sp/>character(s)&quot;</highlight><highlight class="normal">,<sp/>test.<ref refid="classwx_string_1af63f200410b56436a830550905e20539" kindref="member">length</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>prints<sp/>&quot;wxString<sp/>reports<sp/>a<sp/>length<sp/>of<sp/>1<sp/>character(s)&quot;<sp/>on<sp/>Linux</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>prints<sp/>&quot;wxString<sp/>reports<sp/>a<sp/>length<sp/>of<sp/>2<sp/>character(s)&quot;<sp/>on<sp/>Windows</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>since<sp/>wxString<sp/>on<sp/>Windows<sp/>doesn&apos;t<sp/>have<sp/>surrogate<sp/>pairs<sp/>support!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>second<sp/>test,<sp/>this<sp/>time<sp/>using<sp/>characters<sp/>part<sp/>of<sp/>the<sp/>Unicode<sp/>BMP:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>test2<sp/>=<sp/><ref refid="classwx_string_1a2ddc1b7c8e1eb9adbf5874dead5b180b" kindref="member" tooltip="Converts C string encoded in UTF-8 to wxString.">wxString::FromUTF8</ref>(</highlight><highlight class="stringliteral">&quot;\x41\xC3\xA0\xE2\x82\xAC&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>the<sp/>UTF8<sp/>encoding<sp/>of<sp/>capital<sp/>letter<sp/>A<sp/>followed<sp/>by</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>&apos;small<sp/>case<sp/>letter<sp/>a<sp/>with<sp/>grave&apos;<sp/>followed<sp/>by<sp/>the<sp/>&apos;euro<sp/>sign&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>they<sp/>are<sp/>3<sp/>Unicode<sp/>code-points<sp/>encoded<sp/>as:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>-<sp/>3<sp/>UTF16<sp/>code<sp/>units<sp/>under<sp/>Windows</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>-<sp/>6<sp/>UTF8<sp/>code<sp/>units<sp/>under<sp/>Linux</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(without<sp/>considering<sp/>the<sp/>final<sp/>NULL)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wxPrintf(</highlight><highlight class="stringliteral">&quot;wxString<sp/>reports<sp/>a<sp/>length<sp/>of<sp/>%d<sp/>character(s)&quot;</highlight><highlight class="normal">,<sp/>test2.length());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>prints<sp/>&quot;wxString<sp/>reports<sp/>a<sp/>length<sp/>of<sp/>3<sp/>character(s)&quot;<sp/>on<sp/>Linux</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>prints<sp/>&quot;wxString<sp/>reports<sp/>a<sp/>length<sp/>of<sp/>3<sp/>character(s)&quot;<sp/>on<sp/>Windows</highlight></codeline>
</programlisting></para><para>To better explain what stated above, consider the second string of the example above; it&apos;s composed by 3 characters and the final <computeroutput>NULL:</computeroutput> </para><para><image type="html" name="overview_wxstring_encoding.png"></image>
</para><para>As you can see, UTF16 encoding is straightforward (for characters in the <emphasis>BMP</emphasis>) and in this example the UTF16-encoded <ref refid="classwx_string" kindref="compound">wxString</ref> takes 8 bytes. UTF8 encoding is more elaborated and in this example takes 7 bytes.</para><para>In general, for strings containing many latin characters UTF8 provides a big advantage with regards to the memory footprint respect UTF16, but requires some more processing for common operations like e.g. length calculation.</para><para>Finally, note that the type used by <ref refid="classwx_string" kindref="compound">wxString</ref> to store Unicode code units (<computeroutput>wchar_t</computeroutput> or <computeroutput>char</computeroutput>) is always <computeroutput>typedef-ined</computeroutput> to be <ref refid="group__group__funcmacro__string_1gaf558f1d34fbf3cf5e3258e42a40875fd" kindref="member">wxStringCharType</ref>.</para></sect1>
<sect1 id="overview_string_1overview_string_binary">
<title>Using wxString to store binary data</title>
<para><ref refid="classwx_string" kindref="compound">wxString</ref> can be used to store binary data (even if it contains <computeroutput>NULs</computeroutput>) using the functions <ref refid="classwx_string_1afa91a632574bcbba1bf35b54f2c5562a" kindref="member">wxString::To8BitData</ref> and <ref refid="classwx_string_1a5aedc23e9cc2774237d99148d0622661" kindref="member">wxString::From8BitData</ref>.</para><para>Beware that even if <computeroutput>NUL</computeroutput> character is allowed, in the current string implementation some methods might not work correctly with them.</para><para>Note however that other classes like <ref refid="classwx_memory_buffer" kindref="compound">wxMemoryBuffer</ref> are more suited to this task. For handling binary data you may also want to look at the <ref refid="classwx_stream_buffer" kindref="compound">wxStreamBuffer</ref>, <ref refid="classwx_memory_output_stream" kindref="compound">wxMemoryOutputStream</ref>, <ref refid="classwx_memory_input_stream" kindref="compound">wxMemoryInputStream</ref> classes.</para></sect1>
<sect1 id="overview_string_1overview_string_comparison">
<title>Comparison to Other String Classes</title>
<para>The advantages of using a special string class instead of working directly with C strings are so obvious that there is a huge number of such classes available. The most important advantage is the need to always remember to allocate/free memory for C strings; working with fixed size buffers almost inevitably leads to buffer overflows. At last, C++ has a standard string class (<computeroutput>std::string</computeroutput>). So why the need for <ref refid="classwx_string" kindref="compound">wxString</ref>? There are several advantages:</para><para><itemizedlist>
<listitem><para><bold>Efficiency:</bold> Since wxWidgets 3.0 <ref refid="classwx_string" kindref="compound">wxString</ref> uses <computeroutput>std::string</computeroutput> (in UTF8 mode under Linux, Unix and OS X) or <computeroutput>std::wstring</computeroutput> (in UTF16 mode under Windows) internally by default to store its contents. <ref refid="classwx_string" kindref="compound">wxString</ref> will therefore inherit the performance characteristics from <computeroutput>std::string</computeroutput>. </para></listitem>
<listitem><para><bold>Compatibility:</bold> This class tries to combine almost full compatibility with the old wxWidgets 1.xx <ref refid="classwx_string" kindref="compound">wxString</ref> class, some reminiscence of MFC&apos;s CString class and 90% of the functionality of <computeroutput>std::string</computeroutput> class. </para></listitem>
<listitem><para><bold>Rich set of functions:</bold> Some of the functions present in <ref refid="classwx_string" kindref="compound">wxString</ref> are very useful but don&apos;t exist in most of other string classes: for example, <ref refid="classwx_string_1a1605126b7bbf5f60a6fca7f393a58f1d" kindref="member">wxString::AfterFirst</ref>, <ref refid="classwx_string_1a9b6f088a6ef2faadf922a521df0fae3a" kindref="member">wxString::BeforeLast</ref>, <ref refid="classwx_string_1a9588b7f2684b9a6a924dc3746a2b2f8d" kindref="member">wxString::Printf</ref>. Of course, all the standard string operations are supported as well. </para></listitem>
<listitem><para><bold><ref refid="classwx_string" kindref="compound">wxString</ref> is Unicode friendly:</bold> it allows to easily convert to and from ANSI and Unicode strings (see <ref refid="overview_unicode" kindref="compound">Unicode Support in wxWidgets</ref> for more details) and maps to <computeroutput>std::wstring</computeroutput> transparently. </para></listitem>
<listitem><para><bold>Used by wxWidgets:</bold> And, of course, this class is used everywhere inside wxWidgets so there is no performance loss which would result from conversions of objects of any other string class (including <computeroutput>std::string</computeroutput>) to <ref refid="classwx_string" kindref="compound">wxString</ref> internally by wxWidgets.</para></listitem>
</itemizedlist>
However, there are several problems as well. The most important one is probably that there are often several functions to do exactly the same thing: for example, to get the length of the string either one of <ref refid="classwx_string_1af63f200410b56436a830550905e20539" kindref="member">wxString::length()</ref>, <ref refid="classwx_string_1ab20a87ca731a52c36ec674dae2213ad8" kindref="member">wxString::Len()</ref> or <ref refid="classwx_string_1a8895cca03120099236c002c0577b4d1c" kindref="member">wxString::Length()</ref> may be used. The first function, as almost all the other functions in lowercase, is <computeroutput>std::string</computeroutput> compatible. The second one is the &quot;native&quot; <ref refid="classwx_string" kindref="compound">wxString</ref> version and the last one is the wxWidgets 1.xx way.</para><para>So which is better to use? The usage of the <computeroutput>std::string</computeroutput> compatible functions is strongly advised! It will both make your code more familiar to other C++ programmers (who are supposed to have knowledge of <computeroutput>std::string</computeroutput> but not of <ref refid="classwx_string" kindref="compound">wxString</ref>), let you reuse the same code in both wxWidgets and other programs (by just typedefing <ref refid="classwx_string" kindref="compound">wxString</ref> as <computeroutput>std::string</computeroutput> when used outside wxWidgets) and by staying compatible with future versions of wxWidgets which will probably start using <computeroutput>std::string</computeroutput> sooner or later too.</para><para>In the situations where there is no corresponding <computeroutput>std::string</computeroutput> function, please try to use the new <ref refid="classwx_string" kindref="compound">wxString</ref> methods and not the old wxWidgets 1.xx variants which are deprecated and may disappear in future versions.</para></sect1>
<sect1 id="overview_string_1overview_string_advice">
<title>Advice About Using wxString</title>
<sect2 id="overview_string_1overview_string_implicitconv">
<title>Implicit conversions</title>
<para>Probably the main trap with using this class is the implicit conversion operator to <computeroutput>const char*</computeroutput>. It is advised that you use <ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member">wxString::c_str()</ref> instead to clearly indicate when the conversion is done. Specifically, the danger of this implicit conversion may be seen in the following code fragment:</para><para><programlisting><codeline><highlight class="comment">//<sp/>this<sp/>function<sp/>converts<sp/>the<sp/>input<sp/>string<sp/>to<sp/>uppercase,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>output<sp/>it<sp/>to<sp/>the<sp/>screen<sp/>and<sp/>returns<sp/>the<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*SayHELLO(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref>&amp;<sp/>input)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>output<sp/>=<sp/>input.<ref refid="classwx_string_1ab84d4b6e9f38ba939d61f3382d2a009b" kindref="member" tooltip="Returns this string converted to upper case.">Upper</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>%s!\n&quot;</highlight><highlight class="normal">,<sp/>output);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>output;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>There are two nasty bugs in these three lines. The first is in the call to the <computeroutput>printf()</computeroutput> function. Although the implicit conversion to C strings is applied automatically by the compiler in the case of</para><para><programlisting><codeline><highlight class="normal">puts(output);</highlight></codeline>
</programlisting></para><para>because the argument of <computeroutput>puts()</computeroutput> is known to be of the type <computeroutput>const char*</computeroutput>, this is <bold>not</bold> done for <computeroutput>printf()</computeroutput> which is a function with variable number of arguments (and whose arguments are of unknown types). So this call may do any number of things (including displaying the correct string on screen), although the most likely result is a program crash. The solution is to use <ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member">wxString::c_str()</ref>. Just replace this line with this:</para><para><programlisting><codeline><highlight class="normal">printf(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>%s!\n&quot;</highlight><highlight class="normal">,<sp/>output.<ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member" tooltip="Returns a lightweight intermediate class which is in turn implicitly convertible to both const char* ...">c_str</ref>());</highlight></codeline>
</programlisting></para><para>The second bug is that returning <computeroutput>output</computeroutput> doesn&apos;t work. The implicit cast is used again, so the code compiles, but as it returns a pointer to a buffer belonging to a local variable which is deleted as soon as the function exits, its contents are completely arbitrary. The solution to this problem is also easy, just make the function return <ref refid="classwx_string" kindref="compound">wxString</ref> instead of a C string.</para><para>This leads us to the following general advice: all functions taking string arguments should take <computeroutput>const <ref refid="classwx_string" kindref="compound">wxString</ref>&amp;</computeroutput> (this makes assignment to the strings inside the function faster) and all functions returning strings should return <ref refid="classwx_string" kindref="compound">wxString</ref> - this makes it safe to return local variables.</para><para>Finally note that <ref refid="classwx_string" kindref="compound">wxString</ref> uses the current locale encoding to convert any C string literal to Unicode. The same is done for converting to and from <computeroutput>std::string</computeroutput> and for the return value of c_str(). For this conversion, the <emphasis>wxConvLibc</emphasis> class instance is used. See <ref refid="classwx_c_s_conv" kindref="compound">wxCSConv</ref> and <ref refid="classwx_m_b_conv" kindref="compound">wxMBConv</ref>.</para></sect2>
<sect2 id="overview_string_1overview_string_iterating">
<title>Iterating wxString&apos;s characters</title>
<para>As previously described, when <computeroutput>wxUSE_UNICODE_UTF8==1</computeroutput>, <ref refid="classwx_string" kindref="compound">wxString</ref> internally uses the variable-length UTF8 encoding. Accessing a UTF-8 string by index can be very <bold>inefficient</bold> because a single character is represented by a variable number of bytes so that the entire string has to be parsed in order to find the character. Since iterating over a string by index is a common programming technique and was also possible and encouraged by <ref refid="classwx_string" kindref="compound">wxString</ref> using the access operator[]() <ref refid="classwx_string" kindref="compound">wxString</ref> implements caching of the last used index so that iterating over a string is a linear operation even in UTF-8 mode.</para><para>It is nonetheless recommended to use <bold>iterators</bold> (instead of index based access) like this:</para><para><programlisting><codeline><highlight class="normal"><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>s<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">wxString::const_iterator<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>s.<ref refid="classwx_string_1ad59ca2dd208720b3cce07d90bcb90093" kindref="member">begin</ref>();<sp/>i<sp/>!=<sp/>s.<ref refid="classwx_string_1a6a0f235fff88df5e6b16b5f0e1e719cc" kindref="member">end</ref>();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_uni_char" kindref="compound" tooltip="This class represents a single Unicode character.">wxUniChar</ref><sp/>uni_ch<sp/>=<sp/>*i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>with<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="overview_string_1overview_string_related">
<title>String Related Functions and Classes</title>
<para>As most programs use character strings, the standard C library provides quite a few functions to work with them. Unfortunately, some of them have rather counter-intuitive behaviour (like <computeroutput>strncpy()</computeroutput> which doesn&apos;t always terminate the resulting string with a NULL) and are in general not very safe (passing NULL to them will probably lead to program crash). Moreover, some very useful functions are not standard at all. This is why in addition to all <ref refid="classwx_string" kindref="compound">wxString</ref> functions, there are also a few global string functions which try to correct these problems: <ref refid="group__group__funcmacro__crt_1ga4d749baaa27c4c97d579733b0ac6a495" kindref="member">wxIsEmpty()</ref> verifies whether the string is empty (returning true for NULL pointers), <ref refid="group__group__funcmacro__crt_1ga8ee0fe62cfc16ac60a217e825dcf4ba5" kindref="member">wxStrlen()</ref> also handles NULL correctly and returns 0 for them and wxStricmp() is just a platform-independent version of case-insensitive string comparison function known either as <computeroutput>stricmp()</computeroutput> or <computeroutput>strcasecmp()</computeroutput> on different platforms.</para><para>The <computeroutput>&lt;<ref refid="interface_2wx_2string_8h" kindref="compound">wx/string.h</ref>&gt;</computeroutput> header also defines ::wxSnprintf and ::wxVsnprintf functions which should be used instead of the inherently dangerous standard <computeroutput>sprintf()</computeroutput> and which use <computeroutput>snprintf()</computeroutput> instead which does buffer size checks whenever possible. Of course, you may also use <ref refid="classwx_string_1a9588b7f2684b9a6a924dc3746a2b2f8d" kindref="member">wxString::Printf</ref> which is also safe.</para><para>There is another class which might be useful when working with <ref refid="classwx_string" kindref="compound">wxString</ref>: <ref refid="classwx_string_tokenizer" kindref="compound">wxStringTokenizer</ref>. It is helpful when a string must be broken into tokens and replaces the standard C library <computeroutput>strtok()</computeroutput> function.</para><para>And the very last string-related class is <ref refid="classwx_array_string" kindref="compound">wxArrayString</ref>: it is just a version of the &quot;template&quot; dynamic array class which is specialized to work with strings. Please note that this class is specially optimized (using its knowledge of the internal structure of <ref refid="classwx_string" kindref="compound">wxString</ref>) for storing strings and so it is vastly better from a performance point of view than a wxObjectArray of wxStrings.</para></sect1>
<sect1 id="overview_string_1overview_string_tuning">
<title>Tuning wxString for Your Application</title>
<para><simplesect kind="note"><para>This section is strictly about performance issues and is absolutely not necessary to read for using <ref refid="classwx_string" kindref="compound">wxString</ref> class. Please skip it unless you feel familiar with profilers and relative tools.</para></simplesect>
For the performance reasons <ref refid="classwx_string" kindref="compound">wxString</ref> doesn&apos;t allocate exactly the amount of memory needed for each string. Instead, it adds a small amount of space to each allocated block which allows it to not reallocate memory (a relatively expensive operation) too often as when, for example, a string is constructed by subsequently adding one character at a time to it, as for example in:</para><para><programlisting><codeline><highlight class="comment">//<sp/>delete<sp/>all<sp/>vowels<sp/>from<sp/>the<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>DeleteAllVowels(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref>&amp;<sp/>original)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>vowels(<sp/></highlight><highlight class="stringliteral">&quot;aeuioAEIOU&quot;</highlight><highlight class="normal"><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wxString::const_iterator<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>i<sp/>=<sp/>original.<ref refid="classwx_string_1ad59ca2dd208720b3cce07d90bcb90093" kindref="member">begin</ref>();<sp/>i<sp/>!=<sp/>original.<ref refid="classwx_string_1a6a0f235fff88df5e6b16b5f0e1e719cc" kindref="member">end</ref>();<sp/>++i<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vowels.Find(<sp/>*i<sp/>)<sp/>==<sp/><ref refid="defs_8h_1a89de5e6353fc7812991b085e12263e98" kindref="member">wxNOT_FOUND</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>+=<sp/>*i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This is quite a common situation and not allocating extra memory at all would lead to very bad performance in this case because there would be as many memory (re)allocations as there are consonants in the original string. Allocating too much extra memory would help to improve the speed in this situation, but due to a great number of <ref refid="classwx_string" kindref="compound">wxString</ref> objects typically used in a program would also increase the memory consumption too much.</para><para>The very best solution in precisely this case would be to use <ref refid="classwx_string_1a87e614d9924a1b5524334aac3fc96d38" kindref="member">wxString::Alloc()</ref> function to preallocate, for example, len bytes from the beginning - this will lead to exactly one memory allocation being performed (because the result is at most as long as the original string).</para><para>However, using <ref refid="classwx_string_1a87e614d9924a1b5524334aac3fc96d38" kindref="member">wxString::Alloc()</ref> is tedious and so <ref refid="classwx_string" kindref="compound">wxString</ref> tries to do its best. The default algorithm assumes that memory allocation is done in granularity of at least 16 bytes (which is the case on almost all of wide-spread platforms) and so nothing is lost if the amount of memory to allocate is rounded up to the next multiple of 16. Like this, no memory is lost and 15 iterations from 16 in the example above won&apos;t allocate memory but use the already allocated pool.</para><para>The default approach is quite conservative. Allocating more memory may bring important performance benefits for programs using (relatively) few very long strings. The amount of memory allocated is configured by the setting of <computeroutput>EXTRA_ALLOC</computeroutput> in the file string.cpp during compilation (be sure to understand why its default value is what it is before modifying it!). You may try setting it to greater amount (say twice nLen) or to 0 (to see performance degradation which will follow) and analyse the impact of it on your program. If you do it, you will probably find it helpful to also define <computeroutput>WXSTRING_STATISTICS</computeroutput> symbol which tells the <ref refid="classwx_string" kindref="compound">wxString</ref> class to collect performance statistics and to show them on stderr on program termination. This will show you the average length of strings your program manipulates, their average initial length and also the percent of times when memory wasn&apos;t reallocated when string concatenation was done but the already preallocated memory was used (this value should be about 98% for the default allocation policy, if it is less than 90% you should really consider fine tuning <ref refid="classwx_string" kindref="compound">wxString</ref> for your application).</para><para>It goes without saying that a profiler should be used to measure the precise difference the change to <computeroutput>EXTRA_ALLOC</computeroutput> makes to your program.</para></sect1>
<sect1 id="overview_string_1overview_string_settings">
<title>wxString Related Compilation Settings</title>
<para>Much work has been done to make existing code using ANSI string literals work as before version 3.0.</para><para>If you nonetheless need to have a <ref refid="classwx_string" kindref="compound">wxString</ref> that uses <computeroutput>wchar_t</computeroutput> on Unix and Linux, too, you can specify this on the command line with the <computeroutput>configure</computeroutput> <computeroutput>--disable-utf8</computeroutput> switch or you can consider using <ref refid="classwx_u_string" kindref="compound">wxUString</ref> or <computeroutput>std::wstring</computeroutput> instead.</para><para><computeroutput>wxUSE_UNICODE</computeroutput> is now defined as <computeroutput>1</computeroutput> by default to indicate Unicode support. If UTF-8 is used for the internal storage in <ref refid="classwx_string" kindref="compound">wxString</ref>, <computeroutput>wxUSE_UNICODE_UTF8</computeroutput> is also defined, otherwise <computeroutput>wxUSE_UNICODE_WCHAR</computeroutput> is. See also <ref refid="page_wxusedef_1page_wxusedef_important" kindref="member">Most important wxUSE symbols</ref>. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
