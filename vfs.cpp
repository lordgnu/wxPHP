/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


void php_wxFileSystem_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileSystem_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxFileSystem_php* object = static_cast<wxFileSystem_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileSystem done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxFileSystem, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxFileSystem_php();

				((wxFileSystem_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFileSystem);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFileSystem_php*) _this)->evnArray);
		
		array_init(((wxFileSystem_php*) _this)->evnArray);
		
		((wxFileSystem_php*) _this)->phpObj = getThis();
		
		((wxFileSystem_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFileSystem_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxFileSystem, URLToFileName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::URLToFileName\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::URLToFileName\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* url0;
	long url_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&url0, &url_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &url0, &url_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFileSystem::URLToFileName(wxString(url0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxFileName value_to_return1;
				value_to_return1 = wxFileSystem::URLToFileName(wxString(url0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxFileName));
				object_init_ex(return_value, php_wxFileName_entry);
				add_property_resource(return_value, _wxResource, zend_list_insert(ptr, le_wxFileName));
				((wxFileName_php*)ptr)->phpObj = return_value;
				MAKE_STD_ZVAL(((wxFileName_php*) ptr)->evnArray);
				array_init(((wxFileName_php*) ptr)->evnArray);
				((wxFileName_php*)ptr)->InitProperties();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, OpenFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::OpenFile\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::OpenFile\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* location0;
	long location_len0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&location0, &location_len0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &location0, &location_len0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileSystem::OpenFile(wxString(location0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxFSFile_php* value_to_return1;
				value_to_return1 = (wxFSFile_php*) ((wxFileSystem_php*)_this)->OpenFile(wxString(location0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFSFile_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxFSFile));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileSystem::OpenFile(wxString(location0, wxConvUTF8), (int) flags0) to return object pointer\n\n");
				#endif
				wxFSFile_php* value_to_return2;
				value_to_return2 = (wxFSFile_php*) ((wxFileSystem_php*)_this)->OpenFile(wxString(location0, wxConvUTF8), (int) flags0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFSFile_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxFSFile));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, HasHandlerForPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::HasHandlerForPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::HasHandlerForPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* location0;
	long location_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&location0, &location_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &location0, &location_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxFileSystem::HasHandlerForPath(wxString(location0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, wxFileSystem::HasHandlerForPath(wxString(location0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, GetPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::GetPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::GetPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileSystem::GetPath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileSystem_php*)_this)->GetPath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, FindNext)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::FindNext\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::FindNext\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileSystem::FindNext().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileSystem_php*)_this)->FindNext();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, FindFirst)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::FindFirst\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::FindFirst\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* wildcard0;
	long wildcard_len0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&wildcard0, &wildcard_len0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &wildcard0, &wildcard_len0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileSystem::FindFirst(wxString(wildcard0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxFileSystem_php*)_this)->FindFirst(wxString(wildcard0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileSystem::FindFirst(wxString(wildcard0, wxConvUTF8), (int) flags0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				value_to_return2 = ((wxFileSystem_php*)_this)->FindFirst(wxString(wildcard0, wxConvUTF8), (int) flags0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, FindFileInPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::FindFileInPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::FindFileInPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* pStr0;
	long pStr_len0;
	zval* pStr0_ref;
	char* path0;
	long path_len0;
	char* file0;
	long file_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sss' (&pStr0, &pStr_len0, &path0, &path_len0, &file0, &file_len0)\n");
		#endif
		char parse_parameters_string[] = "sss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pStr0, &pStr_len0, &path0, &path_len0, &file0, &file_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &pStr0_ref, &dummy, &dummy );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				wxString string_arg0_0 = wxString(pStr0, wxConvUTF8);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileSystem::FindFileInPath(&string_arg0_0, wxString(path0, wxConvUTF8), wxString(file0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileSystem_php*)_this)->FindFileInPath(&string_arg0_0, wxString(path0, wxConvUTF8), wxString(file0, wxConvUTF8)));

				char* temp_string0_0;
				temp_string0_0 = (char*)malloc(sizeof(wxChar)*(string_arg0_0.size()+1));
				strcpy (temp_string0_0, (const char *) string_arg0_0.char_str() );
				ZVAL_STRING(pStr0_ref, (char*) temp_string0_0, 1);
				free(temp_string0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, FileNameToURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::FileNameToURL\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::FileNameToURL\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* filename0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&filename0, php_wxFileName_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, php_wxFileName_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(filename0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(filename0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(filename0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxFileSystem::FileNameToURL(*(wxFileName*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = wxFileSystem::FileNameToURL(*(wxFileName*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, ChangePathTo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::ChangePathTo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::ChangePathTo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* location0;
	long location_len0;
	bool is_dir0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&location0, &location_len0, &is_dir0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &location0, &location_len0, &is_dir0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileSystem::ChangePathTo(wxString(location0, wxConvUTF8))\n\n");
				#endif
				((wxFileSystem_php*)_this)->ChangePathTo(wxString(location0, wxConvUTF8));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileSystem::ChangePathTo(wxString(location0, wxConvUTF8), is_dir0)\n\n");
				#endif
				((wxFileSystem_php*)_this)->ChangePathTo(wxString(location0, wxConvUTF8), is_dir0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystem, AddHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystem::AddHandler\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystem::AddHandler\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystem){
				references = &((wxFileSystem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* handler0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&handler0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &handler0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(handler0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(handler0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(handler0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFileSystem::AddHandler((wxFileSystemHandler*) object_pointer0_0)\n\n");
				#endif
				wxFileSystem::AddHandler((wxFileSystemHandler*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
void php_wxFileSystemHandler_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileSystemHandler_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxFileSystemHandler_php* object = static_cast<wxFileSystemHandler_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileSystemHandler done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
bool wxFileSystemHandler_php::CanOpen(const wxString& location)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxFileSystemHandler::CanOpen\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "CanOpen", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	temp_string = (char*)malloc(sizeof(wxChar)*(location.size()+1));
	strcpy(temp_string, (const char *) location.char_str());
	ZVAL_STRING(arguments[0], temp_string, 1);
	free(temp_string);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'CanOpen'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	

}
PHP_METHOD(php_wxFileSystemHandler, FindFirst)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystemHandler::FindFirst\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystemHandler::FindFirst\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystemHandler){
				references = &((wxFileSystemHandler_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* wildcard0;
	long wildcard_len0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&wildcard0, &wildcard_len0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &wildcard0, &wildcard_len0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileSystemHandler::FindFirst(wxString(wildcard0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxFileSystemHandler_php*)_this)->FindFirst(wxString(wildcard0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileSystemHandler::FindFirst(wxString(wildcard0, wxConvUTF8), (int) flags0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				value_to_return2 = ((wxFileSystemHandler_php*)_this)->FindFirst(wxString(wildcard0, wxConvUTF8), (int) flags0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystemHandler, FindNext)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystemHandler::FindNext\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystemHandler::FindNext\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystemHandler){
				references = &((wxFileSystemHandler_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileSystemHandler::FindNext().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileSystemHandler_php*)_this)->FindNext();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileSystemHandler, GetMimeTypeFromExt)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystemHandler::GetMimeTypeFromExt\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileSystemHandler::GetMimeTypeFromExt\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileSystemHandler){
				references = &((wxFileSystemHandler_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* location0;
	long location_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&location0, &location_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &location0, &location_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxFileSystemHandler::GetMimeTypeFromExt(wxString(location0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = wxFileSystemHandler::GetMimeTypeFromExt(wxString(location0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
wxFSFile* wxFileSystemHandler_php::OpenFile(wxFileSystem& fs, const wxString& location)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxFileSystemHandler::OpenFile\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OpenFile", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFileSystem_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&fs, le_wxFileSystem));
	temp_string = (char*)malloc(sizeof(wxChar)*(location.size()+1));
	strcpy(temp_string, (const char *) location.char_str());
	ZVAL_STRING(arguments[1], temp_string, 1);
	free(temp_string);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'OpenFile'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return (wxFSFile*) return_object;
	

}
PHP_METHOD(php_wxFileSystemHandler, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileSystemHandler::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxFileSystemHandler_php();

				((wxFileSystemHandler_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFileSystemHandler);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFileSystemHandler_php*) _this)->evnArray);
		
		array_init(((wxFileSystemHandler_php*) _this)->evnArray);
		
		((wxFileSystemHandler_php*) _this)->phpObj = getThis();
		
		((wxFileSystemHandler_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFileSystemHandler_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
