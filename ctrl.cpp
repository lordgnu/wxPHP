/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


void php_wxTreeListItem_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTreeListItem_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxTreeListItem_php* object = static_cast<wxTreeListItem_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTreeListItem done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxTreeListItem, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListItem::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListItem::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListItem){
				references = &((wxTreeListItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListItem::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListItem_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListItem, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListItem::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxTreeListItem_php();

				((wxTreeListItem_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxTreeListItem);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxTreeListItem_php*) _this)->evnArray);
		
		array_init(((wxTreeListItem_php*) _this)->evnArray);
		
		((wxTreeListItem_php*) _this)->phpObj = getThis();
		
		((wxTreeListItem_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxTreeListItem_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxTreeListCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTreeListCtrl_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxTreeListCtrl_php* object = static_cast<wxTreeListCtrl_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting object by calling destroy\n");
			#endif
			
			object->Destroy();
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTreeListCtrl done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxTreeListCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0);
				((wxTreeListCtrl_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0);
				((wxTreeListCtrl_php*) _this)->references.AddReference(pos0);
				((wxTreeListCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0);
				((wxTreeListCtrl_php*) _this)->references.AddReference(pos0);
				((wxTreeListCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8));

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0);
				((wxTreeListCtrl_php*) _this)->references.AddReference(pos0);
				((wxTreeListCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxTreeListCtrl_php();

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxTreeListCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxTreeListCtrl_php*) _this)->evnArray);
		
		array_init(((wxTreeListCtrl_php*) _this)->evnArray);
		
		((wxTreeListCtrl_php*) _this)->phpObj = getThis();
		
		((wxTreeListCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxTreeListCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxTreeListCtrl, WidthFor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::WidthFor\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::WidthFor\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::WidthFor(wxString(text0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->WidthFor(wxString(text0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, UpdateItemParentStateRecursively)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::UpdateItemParentStateRecursively\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::UpdateItemParentStateRecursively\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::UpdateItemParentStateRecursively(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->UpdateItemParentStateRecursively(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, UnselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::UnselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::UnselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::UnselectAll()\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->UnselectAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, Unselect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Unselect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Unselect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::Unselect(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->Unselect(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, UncheckItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::UncheckItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::UncheckItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::UncheckItem(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->UncheckItem(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, SetSortColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetSortColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetSortColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	bool ascendingOrder0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&col0, &ascendingOrder0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &ascendingOrder0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetSortColumn((unsigned) col0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetSortColumn((unsigned) col0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetSortColumn((unsigned) col0, ascendingOrder0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetSortColumn((unsigned) col0, ascendingOrder0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, SetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* item1 = 0;
	void* object_pointer1_0 = 0;
	long col1;
	char* text1;
	long text_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os' (&item0, php_wxTreeListItem_entry, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &text0, &text_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ols' (&item1, php_wxTreeListItem_entry, &col1, &text1, &text_len1)\n");
		#endif
		char parse_parameters_string[] = "Ols";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item1, php_wxTreeListItem_entry, &col1, &text1, &text_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemText(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemText(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemText(*(wxTreeListItem*) object_pointer1_0, (unsigned) col1, wxString(text1, wxConvUTF8))\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemText(*(wxTreeListItem*) object_pointer1_0, (unsigned) col1, wxString(text1, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, SetItemImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetItemImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetItemImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long closed0;
	long opened0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|l' (&item0, php_wxTreeListItem_entry, &closed0, &opened0)\n");
		#endif
		char parse_parameters_string[] = "Ol|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &closed0, &opened0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemImage(*(wxTreeListItem*) object_pointer0_0, (int) closed0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemImage(*(wxTreeListItem*) object_pointer0_0, (int) closed0);


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemImage(*(wxTreeListItem*) object_pointer0_0, (int) closed0, (int) opened0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemImage(*(wxTreeListItem*) object_pointer0_0, (int) closed0, (int) opened0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, SetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* data0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oz' (&item0, php_wxTreeListItem_entry, &data0)\n");
		#endif
		char parse_parameters_string[] = "Oz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemData(*(wxTreeListItem*) object_pointer0_0, (wxClientData*) object_pointer0_1)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemData(*(wxTreeListItem*) object_pointer0_0, (wxClientData*) object_pointer0_1);

				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, SetColumnWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetColumnWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetColumnWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&col0, &width0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetColumnWidth((unsigned) col0, (int) width0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetColumnWidth((unsigned) col0, (int) width0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SelectAll()\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SelectAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, Select)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Select\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Select\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::Select(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->Select(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, PrependItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::PrependItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::PrependItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long imageClosed0;
	long imageOpened0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return2;
				value_to_return2 = ((wxTreeListCtrl_php*)_this)->PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return3;
				value_to_return3 = ((wxTreeListCtrl_php*)_this)->PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return4;
				value_to_return4 = ((wxTreeListCtrl_php*)_this)->PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return5;
				value_to_return5 = ((wxTreeListCtrl_php*)_this)->PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));

				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::IsSelected(*(wxTreeListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->IsSelected(*(wxTreeListItem*) object_pointer0_0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, IsExpanded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::IsExpanded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::IsExpanded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::IsExpanded(*(wxTreeListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->IsExpanded(*(wxTreeListItem*) object_pointer0_0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, InsertItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::InsertItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::InsertItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	zval* previous0 = 0;
	void* object_pointer0_1 = 0;
	char* text0;
	long text_len0;
	long imageClosed0;
	long imageOpened0;
	zval* data0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOs|llz' (&parent0, php_wxTreeListItem_entry, &previous0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0)\n");
		#endif
		char parse_parameters_string[] = "OOs|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeListItem_entry, &previous0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(previous0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(previous0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(previous0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return3;
				value_to_return3 = ((wxTreeListCtrl_php*)_this)->InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return4;
				value_to_return4 = ((wxTreeListCtrl_php*)_this)->InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return5;
				value_to_return5 = ((wxTreeListCtrl_php*)_this)->InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_5) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return6;
				value_to_return6 = ((wxTreeListCtrl_php*)_this)->InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_5);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return6, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));

				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetView)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetView\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetView\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetView() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxTreeListCtrl_php*)_this)->GetView();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetSortColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetSortColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetSortColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long* col0;
	zval* col0_ref;
	bool* ascendingOrder0;
	zval* ascendingOrder0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (col0, ascendingOrder0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, col0, ascendingOrder0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &col0_ref, &ascendingOrder0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::GetSortColumn((unsigned*) col0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->GetSortColumn((unsigned*) col0));

				size_t elements_returned0_0 = sizeof(col0)/sizeof(*col0);
				array_init(col0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(col0_ref, col0[i]);
				}

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::GetSortColumn((unsigned*) col0, ascendingOrder0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->GetSortColumn((unsigned*) col0, ascendingOrder0));

				size_t elements_returned0_0 = sizeof(col0)/sizeof(*col0);
				array_init(col0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(col0_ref, col0[i]);
				}
				size_t elements_returned0_1 = sizeof(ascendingOrder0)/sizeof(*ascendingOrder0);
				array_init(ascendingOrder0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(ascendingOrder0_ref, ascendingOrder0[i]);
				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetSelection() to return new object\n\n");
				#endif
				wxTreeListItem value_to_return0;
				value_to_return0 = ((wxTreeListCtrl_php*)_this)->GetSelection();
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetRootItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetRootItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetRootItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetRootItem() to return new object\n\n");
				#endif
				wxTreeListItem value_to_return0;
				value_to_return0 = ((wxTreeListCtrl_php*)_this)->GetRootItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetNextSibling)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetNextSibling\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetNextSibling\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetNextSibling(*(wxTreeListItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetNextSibling(*(wxTreeListItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetNextItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetNextItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetNextItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetNextItem(*(wxTreeListItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetNextItem(*(wxTreeListItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&item0, php_wxTreeListItem_entry, &col0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTreeListCtrl::GetItemText(*(wxTreeListItem*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetItemText(*(wxTreeListItem*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTreeListCtrl::GetItemText(*(wxTreeListItem*) object_pointer0_0, (unsigned) col0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				value_to_return2 = ((wxTreeListCtrl_php*)_this)->GetItemText(*(wxTreeListItem*) object_pointer0_0, (unsigned) col0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetItemParent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetItemParent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetItemParent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetItemParent(*(wxTreeListItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetItemParent(*(wxTreeListItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetFirstItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetFirstItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetFirstItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetFirstItem() to return new object\n\n");
				#endif
				wxTreeListItem value_to_return0;
				value_to_return0 = ((wxTreeListCtrl_php*)_this)->GetFirstItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetFirstChild)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetFirstChild\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetFirstChild\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetFirstChild(*(wxTreeListItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetFirstChild(*(wxTreeListItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetDataView)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetDataView\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetDataView\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetDataView() to return object pointer\n\n");
				#endif
				wxDataViewCtrl_php* value_to_return0;
				value_to_return0 = (wxDataViewCtrl_php*) ((wxTreeListCtrl_php*)_this)->GetDataView();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetColumnWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetColumnWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetColumnWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::GetColumnWidth((unsigned) col0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->GetColumnWidth((unsigned) col0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, GetCheckedState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetCheckedState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetCheckedState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::GetCheckedState(*(wxTreeListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->GetCheckedState(*(wxTreeListItem*) object_pointer0_0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, Expand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Expand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Expand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::Expand(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->Expand(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, DeleteItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::DeleteItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::DeleteItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::DeleteItem(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->DeleteItem(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, DeleteColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::DeleteColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::DeleteColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::DeleteColumn((unsigned) col0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->DeleteColumn((unsigned) col0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::DeleteAllItems()\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->DeleteAllItems();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, Collapse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Collapse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Collapse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::Collapse(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->Collapse(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, ClearColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::ClearColumns\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::ClearColumns\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::ClearColumns()\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->ClearColumns();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, CheckItemRecursively)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::CheckItemRecursively\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::CheckItemRecursively\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&item0, php_wxTreeListItem_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::CheckItemRecursively(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->CheckItemRecursively(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::CheckItemRecursively(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->CheckItemRecursively(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, CheckItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::CheckItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::CheckItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&item0, php_wxTreeListItem_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::CheckItem(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->CheckItem(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::CheckItem(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->CheckItem(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, AssignImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::AssignImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::AssignImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AssignImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->AssignImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, AreAllChildrenInState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::AreAllChildrenInState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::AreAllChildrenInState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&item0, php_wxTreeListItem_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::AreAllChildrenInState(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->AreAllChildrenInState(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, AppendItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::AppendItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::AppendItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long imageClosed0;
	long imageOpened0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return2;
				value_to_return2 = ((wxTreeListCtrl_php*)_this)->AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return3;
				value_to_return3 = ((wxTreeListCtrl_php*)_this)->AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return4;
				value_to_return4 = ((wxTreeListCtrl_php*)_this)->AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return5;
				value_to_return5 = ((wxTreeListCtrl_php*)_this)->AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));

				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeListCtrl, AppendColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::AppendColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::AppendColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* title0;
	long title_len0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|lll' (&title0, &title_len0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &title0, &title_len0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::AppendColumn(wxString(title0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->AppendColumn(wxString(title0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::AppendColumn(wxString(title0, wxConvUTF8), (int) width0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->AppendColumn(wxString(title0, wxConvUTF8), (int) width0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::AppendColumn(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->AppendColumn(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::AppendColumn(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0, (int) flags0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->AppendColumn(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0, (int) flags0));


				return;
				break;
			}
		}
	}

		
}
void php_wxAnimationCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxAnimationCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAnimationCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* anim0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOOls' (&parent0, &id0, &anim0, php_wxAnimation_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &anim0, php_wxAnimation_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(anim0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(anim0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(anim0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(anim0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(anim0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(anim0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(anim0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(anim0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, GetAnimation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::GetAnimation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::GetAnimation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::GetAnimation() to return new object\n\n");
				#endif
				wxAnimation value_to_return0;
				value_to_return0 = ((wxAnimationCtrl_php*)_this)->GetAnimation();
				void* ptr = safe_emalloc(1, sizeof(wxAnimation_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxAnimation));
				object_init_ex(return_value, php_wxAnimation_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxAnimation));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, GetInactiveBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::GetInactiveBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::GetInactiveBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::GetInactiveBitmap() to return new object\n\n");
				#endif
				wxBitmap value_to_return0;
				value_to_return0 = ((wxAnimationCtrl_php*)_this)->GetInactiveBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, IsPlaying)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::IsPlaying\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::IsPlaying\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::IsPlaying())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->IsPlaying());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::LoadFile\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* file0;
	long file_len0;
	long animType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&file0, &file_len0, &animType0)\n");
		#endif
		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file0, &file_len0, &animType0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::LoadFile(wxString(file0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->LoadFile(wxString(file0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::LoadFile(wxString(file0, wxConvUTF8), (wxAnimationType) animType0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->LoadFile(wxString(file0, wxConvUTF8), (wxAnimationType) animType0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, Play)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::Play\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::Play\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Play())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Play());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, SetAnimation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::SetAnimation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::SetAnimation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* anim0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&anim0, php_wxAnimation_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &anim0, php_wxAnimation_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(anim0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(anim0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(anim0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::SetAnimation(*(wxAnimation*) object_pointer0_0)\n\n");
				#endif
				((wxAnimationCtrl_php*)_this)->SetAnimation(*(wxAnimation*) object_pointer0_0);

				references->AddReference(anim0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, SetInactiveBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::SetInactiveBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::SetInactiveBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmp0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::SetInactiveBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxAnimationCtrl_php*)_this)->SetInactiveBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, Stop)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::Stop\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::Stop\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::Stop()\n\n");
				#endif
				((wxAnimationCtrl_php*)_this)->Stop();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAnimationCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* anim0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOOls' (&parent0, &id0, &anim0, php_wxAnimation_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &anim0, php_wxAnimation_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(anim0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(anim0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(anim0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(pos0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(pos0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8));

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(pos0);
				((wxAnimationCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAnimationCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxAnimationCtrl_php*) _this)->evnArray);
		
		array_init(((wxAnimationCtrl_php*) _this)->evnArray);
		
		((wxAnimationCtrl_php*) _this)->phpObj = getThis();
		
		((wxAnimationCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAnimationCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAnimationCtrl, Load)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::Load\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::Load\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* file0 = 0;
	void* object_pointer0_0 = 0;
	long animType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&file0, php_wxInputStream_entry, &animType0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file0, php_wxInputStream_entry, &animType0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(file0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(file0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(file0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Load(*(wxInputStream*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Load(*(wxInputStream*) object_pointer0_0));

				references->AddReference(file0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Load(*(wxInputStream*) object_pointer0_0, (wxAnimationType) animType0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Load(*(wxInputStream*) object_pointer0_0, (wxAnimationType) animType0));

				references->AddReference(file0);

				return;
				break;
			}
		}
	}

		
}
void php_wxBitmapButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxBitmapButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxBitmapButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapButton){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* bitmap0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOlOs' (&parent0, &id0, &bitmap0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &bitmap0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(bitmap0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(bitmap0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(bitmap0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(bitmap0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(bitmap0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(bitmap0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* bitmap1 = 0;
	void* object_pointer1_2 = 0;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOlOs' (&parent1, &id1, &bitmap1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &bitmap1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxBitmapButton_php();

				((wxBitmapButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1);
				((wxBitmapButton_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1);
				((wxBitmapButton_php*) _this)->references.AddReference(pos1);
				((wxBitmapButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1);
				((wxBitmapButton_php*) _this)->references.AddReference(pos1);
				((wxBitmapButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1);
				((wxBitmapButton_php*) _this)->references.AddReference(pos1);
				((wxBitmapButton_php*) _this)->references.AddReference(size1);
				((wxBitmapButton_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1);
				((wxBitmapButton_php*) _this)->references.AddReference(pos1);
				((wxBitmapButton_php*) _this)->references.AddReference(size1);
				((wxBitmapButton_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxBitmapButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxBitmapButton_php*) _this)->evnArray);
		
		array_init(((wxBitmapButton_php*) _this)->evnArray);
		
		((wxBitmapButton_php*) _this)->phpObj = getThis();
		
		((wxBitmapButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxBitmapButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxBitmapComboBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxBitmapComboBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxBitmapComboBox, Append)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::Append\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::Append\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	zval* bitmap0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|O' (&item0, &item_len0, &bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "s|O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmapComboBox::Append(wxString(item0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxBitmapComboBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmapComboBox::Append(wxString(item0, wxConvUTF8), *(wxBitmap*) object_pointer0_1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxBitmapComboBox_php*)_this)->Append(wxString(item0, wxConvUTF8), *(wxBitmap*) object_pointer0_1));

				references->AddReference(bitmap0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapComboBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long n1;
	zval* choices1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_8 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 6  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|lOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 7  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOla|lOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOla|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_5;
		bool strings_continue0_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 8:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 9:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		int array_count1_6 = 1;
		HashTable* arr_hash1_6;
		if(arguments_received > 6)
		{
			arr_hash1_6 = Z_ARRVAL_P(choices1);
			array_count1_6 = zend_hash_num_elements(arr_hash1_6);
		}
		wxString* strings_array1_6 = new wxString[array_count1_6];
		bool strings_continue1_6 = true;

		switch(arguments_received)
		{
			case 7:
			{
				int array_index1_6 = 0;
				zval** temp_array_value1_6 = 0;
				while(strings_continue1_6)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_6, (void**)&temp_array_value1_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_6);
						strings_array1_6[array_index1_6] = wxString(Z_STRVAL_PP(temp_array_value1_6), wxConvUTF8);
						array_index1_6++;
					}
					else
					{
						strings_continue1_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_6;

				return;
				break;
			}
			case 8:
			{
				int array_index1_6 = 0;
				zval** temp_array_value1_6 = 0;
				while(strings_continue1_6)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_6, (void**)&temp_array_value1_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_6);
						strings_array1_6[array_index1_6] = wxString(Z_STRVAL_PP(temp_array_value1_6), wxConvUTF8);
						array_index1_6++;
					}
					else
					{
						strings_continue1_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_6;

				return;
				break;
			}
			case 9:
			{
				int array_index1_6 = 0;
				zval** temp_array_value1_6 = 0;
				while(strings_continue1_6)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_6, (void**)&temp_array_value1_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_6);
						strings_array1_6[array_index1_6] = wxString(Z_STRVAL_PP(temp_array_value1_6), wxConvUTF8);
						array_index1_6++;
					}
					else
					{
						strings_continue1_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1, *(wxValidator*) object_pointer1_8))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1, *(wxValidator*) object_pointer1_8));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_6;
				references->AddReference(validator1);

				return;
				break;
			}
			case 10:
			{
				int array_index1_6 = 0;
				zval** temp_array_value1_6 = 0;
				while(strings_continue1_6)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_6, (void**)&temp_array_value1_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_6);
						strings_array1_6[array_index1_6] = wxString(Z_STRVAL_PP(temp_array_value1_6), wxConvUTF8);
						array_index1_6++;
					}
					else
					{
						strings_continue1_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_6;
				references->AddReference(validator1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapComboBox, GetBitmapSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::GetBitmapSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::GetBitmapSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapComboBox::GetBitmapSize() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetBitmapSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapComboBox, GetItemBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::GetItemBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::GetItemBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapComboBox::GetItemBitmap((unsigned int) n0) to return new object\n\n");
				#endif
				wxBitmap value_to_return1;
				value_to_return1 = ((wxBitmapComboBox_php*)_this)->GetItemBitmap((unsigned int) n0);
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapComboBox, Insert)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::Insert\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::Insert\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	zval* bitmap0 = 0;
	void* object_pointer0_1 = 0;
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sOl' (&item0, &item_len0, &bitmap0, php_wxBitmap_entry, &pos0)\n");
		#endif
		char parse_parameters_string[] = "sOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0, &bitmap0, php_wxBitmap_entry, &pos0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmapComboBox::Insert(wxString(item0, wxConvUTF8), *(wxBitmap*) object_pointer0_1, (unsigned int) pos0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxBitmapComboBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), *(wxBitmap*) object_pointer0_1, (unsigned int) pos0));

				references->AddReference(bitmap0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapComboBox, SetItemBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::SetItemBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::SetItemBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	zval* bitmap0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&n0, &bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapComboBox::SetItemBitmap((unsigned int) n0, *(wxBitmap*) object_pointer0_1)\n\n");
				#endif
				((wxBitmapComboBox_php*)_this)->SetItemBitmap((unsigned int) n0, *(wxBitmap*) object_pointer0_1);

				references->AddReference(bitmap0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapComboBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_7 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 7  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOal|Os' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOal|Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxBitmapComboBox_php();

				((wxBitmapComboBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_5;
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1)\n");
				#endif
				_this = new wxBitmapComboBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1);

				((wxBitmapComboBox_php*) _this)->references.Initialize();
				((wxBitmapComboBox_php*) _this)->references.AddReference(parent1);
				((wxBitmapComboBox_php*) _this)->references.AddReference(pos1);
				((wxBitmapComboBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7)\n");
				#endif
				_this = new wxBitmapComboBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7);

				((wxBitmapComboBox_php*) _this)->references.Initialize();
				((wxBitmapComboBox_php*) _this)->references.AddReference(parent1);
				((wxBitmapComboBox_php*) _this)->references.AddReference(pos1);
				((wxBitmapComboBox_php*) _this)->references.AddReference(size1);
				((wxBitmapComboBox_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxBitmapComboBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8));

				((wxBitmapComboBox_php*) _this)->references.Initialize();
				((wxBitmapComboBox_php*) _this)->references.AddReference(parent1);
				((wxBitmapComboBox_php*) _this)->references.AddReference(pos1);
				((wxBitmapComboBox_php*) _this)->references.AddReference(size1);
				((wxBitmapComboBox_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxBitmapComboBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxBitmapComboBox_php*) _this)->evnArray);
		
		array_init(((wxBitmapComboBox_php*) _this)->evnArray);
		
		((wxBitmapComboBox_php*) _this)->phpObj = getThis();
		
		((wxBitmapComboBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxBitmapComboBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8))\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8));

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0);
				((wxButton_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0);
				((wxButton_php*) _this)->references.AddReference(pos0);
				((wxButton_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0);
				((wxButton_php*) _this)->references.AddReference(pos0);
				((wxButton_php*) _this)->references.AddReference(size0);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0);
				((wxButton_php*) _this)->references.AddReference(pos0);
				((wxButton_php*) _this)->references.AddReference(size0);
				((wxButton_php*) _this)->references.AddReference(validator0);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0);
				((wxButton_php*) _this)->references.AddReference(pos0);
				((wxButton_php*) _this)->references.AddReference(size0);
				((wxButton_php*) _this)->references.AddReference(validator0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxButton_php();

				((wxButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxButton_php*) _this)->evnArray);
		
		array_init(((wxButton_php*) _this)->evnArray);
		
		((wxButton_php*) _this)->phpObj = getThis();
		
		((wxButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxButton, SetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::SetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::SetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&label0, &label_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxButton::SetLabel(wxString(label0, wxConvUTF8))\n\n");
				#endif
				((wxButton_php*)_this)->SetLabel(wxString(label0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxButton, GetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::GetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::GetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxButton::GetLabel().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxButton_php*)_this)->GetLabel();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxButton, SetDefault)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::SetDefault\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::SetDefault\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxButton::SetDefault() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxButton_php*)_this)->SetDefault();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxButton, SetAuthNeeded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::SetAuthNeeded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::SetAuthNeeded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool needed0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&needed0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &needed0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxButton::SetAuthNeeded()\n\n");
				#endif
				((wxButton_php*)_this)->SetAuthNeeded();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxButton::SetAuthNeeded(needed0)\n\n");
				#endif
				((wxButton_php*)_this)->SetAuthNeeded(needed0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxButton, GetDefaultSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::GetDefaultSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::GetDefaultSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxButton::GetDefaultSize() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = wxButton::GetDefaultSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, _wxResource, zend_list_insert(ptr, le_wxSize));
				((wxSize_php*)ptr)->phpObj = return_value;
				MAKE_STD_ZVAL(((wxSize_php*) ptr)->evnArray);
				array_init(((wxSize_php*) ptr)->evnArray);
				((wxSize_php*)ptr)->InitProperties();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxButton, GetAuthNeeded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::GetAuthNeeded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::GetAuthNeeded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::GetAuthNeeded())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->GetAuthNeeded());


				return;
				break;
			}
		}
	}

		
}
void php_wxCalendarCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxCalendarCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxCalendarCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	long date0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|lOOls' (&parent0, &id0, &date0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &date0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, EnableHolidayDisplay)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::EnableHolidayDisplay\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::EnableHolidayDisplay\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool display0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&display0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &display0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::EnableHolidayDisplay()\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->EnableHolidayDisplay();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::EnableHolidayDisplay(display0)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->EnableHolidayDisplay(display0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, EnableMonthChange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::EnableMonthChange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::EnableMonthChange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::EnableMonthChange())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->EnableMonthChange());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::EnableMonthChange(enable0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->EnableMonthChange(enable0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetAttr\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long day0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&day0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetAttr((size_t) day0) to return object pointer\n\n");
				#endif
				wxCalendarDateAttr_php* value_to_return1;
				value_to_return1 = (wxCalendarDateAttr_php*) ((wxCalendarCtrl_php*)_this)->GetAttr((size_t) day0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxCalendarDateAttr_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxCalendarDateAttr));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetDate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetDate\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetDate\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetDate() to return timestamp\n\n");
				#endif
				long value_to_return0;
				value_to_return0 = ((wxCalendarCtrl_php*)_this)->GetDate().GetTicks();
				ZVAL_LONG(return_value, value_to_return0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetDateRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetDateRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetDateRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long lowerdate0;
	zval* lowerdate0_ref;
	long upperdate0;
	zval* upperdate0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&lowerdate0, &upperdate0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lowerdate0, &upperdate0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &lowerdate0_ref, &upperdate0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				wxDateTime date_time0_0 = wxDateTime(lowerdate0);
				wxDateTime date_time0_1 = wxDateTime(upperdate0);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::GetDateRange(&date_time0_0, &date_time0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->GetDateRange(&date_time0_0, &date_time0_1));

				ZVAL_LONG(lowerdate0_ref, date_time0_0.GetTicks());
				ZVAL_LONG(upperdate0_ref, date_time0_1.GetTicks());

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetHeaderColourBg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHeaderColourBg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHeaderColourBg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHeaderColourBg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHeaderColourBg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetHeaderColourFg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHeaderColourFg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHeaderColourFg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHeaderColourFg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHeaderColourFg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetHighlightColourBg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHighlightColourBg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHighlightColourBg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHighlightColourBg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHighlightColourBg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetHighlightColourFg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHighlightColourFg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHighlightColourFg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHighlightColourFg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHighlightColourFg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetHolidayColourBg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHolidayColourBg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHolidayColourBg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHolidayColourBg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHolidayColourBg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, GetHolidayColourFg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHolidayColourFg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHolidayColourFg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHolidayColourFg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHolidayColourFg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, HitTest)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::HitTest\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::HitTest\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* pos0 = 0;
	void* object_pointer0_0 = 0;
	long date0;
	zval* date0_ref;
	long* wd0;
	zval* wd0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|ll' (&pos0, php_wxPoint_entry, &date0, wd0)\n");
		#endif
		char parse_parameters_string[] = "O|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, php_wxPoint_entry, &date0, wd0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z|zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &date0_ref, &wd0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCalendarCtrl::HitTest(*(wxPoint*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxCalendarCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0));

				references->AddReference(pos0);

				return;
				break;
			}
			case 2:
			{
				wxDateTime date_time0_1 = wxDateTime(date0);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCalendarCtrl::HitTest(*(wxPoint*) object_pointer0_0, &date_time0_1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxCalendarCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0, &date_time0_1));

				references->AddReference(pos0);
				ZVAL_LONG(date0_ref, date_time0_1.GetTicks());

				return;
				break;
			}
			case 3:
			{
				wxDateTime date_time0_1 = wxDateTime(date0);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCalendarCtrl::HitTest(*(wxPoint*) object_pointer0_0, &date_time0_1, (wxDateTime::WeekDay*) wd0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxCalendarCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0, &date_time0_1, (wxDateTime::WeekDay*) wd0));

				references->AddReference(pos0);
				ZVAL_LONG(date0_ref, date_time0_1.GetTicks());
				size_t elements_returned0_2 = sizeof(wd0)/sizeof(*wd0);
				array_init(wd0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(wd0_ref, wd0[i]);
				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, Mark)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::Mark\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::Mark\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long day0;
	bool mark0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&day0, &mark0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0, &mark0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::Mark((size_t) day0, mark0)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->Mark((size_t) day0, mark0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, ResetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::ResetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::ResetAttr\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long day0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&day0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::ResetAttr((size_t) day0)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->ResetAttr((size_t) day0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, SetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetAttr\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long day0;
	zval* attr0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lz' (&day0, &attr0)\n");
		#endif
		char parse_parameters_string[] = "lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0, &attr0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(attr0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(attr0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetAttr((size_t) day0, (wxCalendarDateAttr*) object_pointer0_1)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetAttr((size_t) day0, (wxCalendarDateAttr*) object_pointer0_1);

				references->AddReference(attr0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, SetDate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetDate\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetDate\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long date0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&date0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &date0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::SetDate(wxDateTime(date0)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->SetDate(wxDateTime(date0)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, SetDateRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetDateRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetDateRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long lowerdate0;
	long upperdate0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&lowerdate0, &upperdate0)\n");
		#endif
		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lowerdate0, &upperdate0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::SetDateRange())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->SetDateRange());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::SetDateRange(wxDateTime(lowerdate0)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->SetDateRange(wxDateTime(lowerdate0)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::SetDateRange(wxDateTime(lowerdate0), wxDateTime(upperdate0)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->SetDateRange(wxDateTime(lowerdate0), wxDateTime(upperdate0)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, SetHeaderColours)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetHeaderColours\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetHeaderColours\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* colFg0 = 0;
	void* object_pointer0_0 = 0;
	zval* colBg0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colFg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colFg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colFg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colBg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetHeaderColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetHeaderColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(colFg0);
				references->AddReference(colBg0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, SetHighlightColours)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetHighlightColours\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetHighlightColours\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* colFg0 = 0;
	void* object_pointer0_0 = 0;
	zval* colBg0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colFg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colFg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colFg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colBg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetHighlightColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetHighlightColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(colFg0);
				references->AddReference(colBg0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, SetHoliday)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetHoliday\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetHoliday\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long day0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&day0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetHoliday((size_t) day0)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetHoliday((size_t) day0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, SetHolidayColours)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetHolidayColours\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetHolidayColours\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* colFg0 = 0;
	void* object_pointer0_0 = 0;
	zval* colBg0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colFg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colFg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colFg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colBg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetHolidayColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetHolidayColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(colFg0);
				references->AddReference(colBg0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCalendarCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	long date1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|lOOls' (&parent1, &id1, &date1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &date1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxCalendarCtrl_php();

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1))\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1));

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3);

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1);
				((wxCalendarCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1);
				((wxCalendarCtrl_php*) _this)->references.AddReference(pos1);
				((wxCalendarCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1);
				((wxCalendarCtrl_php*) _this)->references.AddReference(pos1);
				((wxCalendarCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1);
				((wxCalendarCtrl_php*) _this)->references.AddReference(pos1);
				((wxCalendarCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxCalendarCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxCalendarCtrl_php*) _this)->evnArray);
		
		array_init(((wxCalendarCtrl_php*) _this)->evnArray);
		
		((wxCalendarCtrl_php*) _this)->phpObj = getThis();
		
		((wxCalendarCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxCalendarCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxCheckBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxCheckBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxCheckBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8))\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8));

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3)\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3);

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0);
				((wxCheckBox_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4)\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0);
				((wxCheckBox_php*) _this)->references.AddReference(pos0);
				((wxCheckBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0)\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0);

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0);
				((wxCheckBox_php*) _this)->references.AddReference(pos0);
				((wxCheckBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0);
				((wxCheckBox_php*) _this)->references.AddReference(pos0);
				((wxCheckBox_php*) _this)->references.AddReference(size0);
				((wxCheckBox_php*) _this)->references.AddReference(validator0);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0);
				((wxCheckBox_php*) _this)->references.AddReference(pos0);
				((wxCheckBox_php*) _this)->references.AddReference(size0);
				((wxCheckBox_php*) _this)->references.AddReference(validator0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxCheckBox_php();

				((wxCheckBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxCheckBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxCheckBox_php*) _this)->evnArray);
		
		array_init(((wxCheckBox_php*) _this)->evnArray);
		
		((wxCheckBox_php*) _this)->phpObj = getThis();
		
		((wxCheckBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxCheckBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxCheckBox, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&state0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCheckBox::SetValue(state0)\n\n");
				#endif
				((wxCheckBox_php*)_this)->SetValue(state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckBox, Set3StateValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Set3StateValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Set3StateValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&state0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCheckBox::Set3StateValue((wxCheckBoxState) state0)\n\n");
				#endif
				((wxCheckBox_php*)_this)->Set3StateValue((wxCheckBoxState) state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckBox, IsChecked)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::IsChecked\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::IsChecked\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::IsChecked())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->IsChecked());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckBox, Is3rdStateAllowedForUser)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Is3rdStateAllowedForUser\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Is3rdStateAllowedForUser\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Is3rdStateAllowedForUser())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Is3rdStateAllowedForUser());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckBox, Is3State)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Is3State\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Is3State\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Is3State())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Is3State());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckBox, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::GetValue())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckBox, Get3StateValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Get3StateValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Get3StateValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCheckBox::Get3StateValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxCheckBox_php*)_this)->Get3StateValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
void php_wxCheckListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxCheckListBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxCheckListBox, Check)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckListBox::Check\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckListBox::Check\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckListBox){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool check0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&item0, &check0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &check0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCheckListBox::Check((unsigned int) item0)\n\n");
				#endif
				((wxCheckListBox_php*)_this)->Check((unsigned int) item0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCheckListBox::Check((unsigned int) item0, check0)\n\n");
				#endif
				((wxCheckListBox_php*)_this)->Check((unsigned int) item0, check0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckListBox){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long n0;
	zval* choices0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlalOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_5 = 1;
		HashTable* arr_hash0_5;
		if(arguments_received > 5)
		{
			arr_hash0_5 = Z_ARRVAL_P(choices0);
			array_count0_5 = zend_hash_num_elements(arr_hash0_5);
		}
		wxString* strings_array0_5 = new wxString[array_count0_5];
		bool strings_continue0_5 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_5;

				return;
				break;
			}
			case 7:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_5;

				return;
				break;
			}
			case 8:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_5;
				references->AddReference(validator0);

				return;
				break;
			}
			case 9:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_5;
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_4;
		bool strings_continue1_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 6:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 7:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				references->AddReference(validator1);

				return;
				break;
			}
			case 8:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				references->AddReference(validator1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckListBox, IsChecked)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckListBox::IsChecked\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckListBox::IsChecked\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckListBox){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::IsChecked((unsigned int) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->IsChecked((unsigned int) item0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCheckListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxCheckListBox_php();

				((wxCheckListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_4;
		bool strings_continue1_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4)\n");
				#endif
				_this = new wxCheckListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4);

				((wxCheckListBox_php*) _this)->references.Initialize();
				((wxCheckListBox_php*) _this)->references.AddReference(parent1);
				((wxCheckListBox_php*) _this)->references.AddReference(pos1);
				((wxCheckListBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1)\n");
				#endif
				_this = new wxCheckListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1);

				((wxCheckListBox_php*) _this)->references.Initialize();
				((wxCheckListBox_php*) _this)->references.AddReference(parent1);
				((wxCheckListBox_php*) _this)->references.AddReference(pos1);
				((wxCheckListBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxCheckListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxCheckListBox_php*) _this)->references.Initialize();
				((wxCheckListBox_php*) _this)->references.AddReference(parent1);
				((wxCheckListBox_php*) _this)->references.AddReference(pos1);
				((wxCheckListBox_php*) _this)->references.AddReference(size1);
				((wxCheckListBox_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 8:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxCheckListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxCheckListBox_php*) _this)->references.Initialize();
				((wxCheckListBox_php*) _this)->references.AddReference(parent1);
				((wxCheckListBox_php*) _this)->references.AddReference(pos1);
				((wxCheckListBox_php*) _this)->references.AddReference(size1);
				((wxCheckListBox_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxCheckListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxCheckListBox_php*) _this)->evnArray);
		
		array_init(((wxCheckListBox_php*) _this)->evnArray);
		
		((wxCheckListBox_php*) _this)->phpObj = getThis();
		
		((wxCheckListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxCheckListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxChoice_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxChoice_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxChoice, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxChoice_php();

				((wxChoice_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_4;
		bool strings_continue1_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4)\n");
				#endif
				_this = new wxChoice_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4);

				((wxChoice_php*) _this)->references.Initialize();
				((wxChoice_php*) _this)->references.AddReference(parent1);
				((wxChoice_php*) _this)->references.AddReference(pos1);
				((wxChoice_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1)\n");
				#endif
				_this = new wxChoice_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1);

				((wxChoice_php*) _this)->references.Initialize();
				((wxChoice_php*) _this)->references.AddReference(parent1);
				((wxChoice_php*) _this)->references.AddReference(pos1);
				((wxChoice_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxChoice_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxChoice_php*) _this)->references.Initialize();
				((wxChoice_php*) _this)->references.AddReference(parent1);
				((wxChoice_php*) _this)->references.AddReference(pos1);
				((wxChoice_php*) _this)->references.AddReference(size1);
				((wxChoice_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 8:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxChoice_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxChoice_php*) _this)->references.Initialize();
				((wxChoice_php*) _this)->references.AddReference(parent1);
				((wxChoice_php*) _this)->references.AddReference(pos1);
				((wxChoice_php*) _this)->references.AddReference(size1);
				((wxChoice_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxChoice);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxChoice_php*) _this)->evnArray);
		
		array_init(((wxChoice_php*) _this)->evnArray);
		
		((wxChoice_php*) _this)->phpObj = getThis();
		
		((wxChoice_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxChoice_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxChoice, SetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::SetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&n0, &string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxChoice::SetString((unsigned int) n0, wxString(string0, wxConvUTF8))\n\n");
				#endif
				((wxChoice_php*)_this)->SetString((unsigned int) n0, wxString(string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxChoice::SetSelection((int) n0)\n\n");
				#endif
				((wxChoice_php*)_this)->SetSelection((int) n0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, SetColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::SetColumns\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::SetColumns\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxChoice::SetColumns()\n\n");
				#endif
				((wxChoice_php*)_this)->SetColumns();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxChoice::SetColumns((int) n0)\n\n");
				#endif
				((wxChoice_php*)_this)->SetColumns((int) n0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, IsSorted)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::IsSorted\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::IsSorted\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::IsSorted())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->IsSorted());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxChoice::GetString((unsigned int) n0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxChoice_php*)_this)->GetString((unsigned int) n0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, GetCurrentSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetCurrentSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetCurrentSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::GetCurrentSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->GetCurrentSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, GetColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetColumns\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetColumns\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::GetColumns())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->GetColumns());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool caseSensitive0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &caseSensitive0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &caseSensitive0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->FindString(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::FindString(wxString(string0, wxConvUTF8), caseSensitive0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxChoice, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long n1;
	zval* choices1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_7 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlalOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_4;
		bool strings_continue0_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		int array_count1_5 = 1;
		HashTable* arr_hash1_5;
		if(arguments_received > 5)
		{
			arr_hash1_5 = Z_ARRVAL_P(choices1);
			array_count1_5 = zend_hash_num_elements(arr_hash1_5);
		}
		wxString* strings_array1_5 = new wxString[array_count1_5];
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1));

				references->AddReference(parent1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2));

				references->AddReference(parent1);
				references->AddReference(pos1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_5;

				return;
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_5;

				return;
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_5;
				references->AddReference(validator1);

				return;
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_5;
				references->AddReference(validator1);

				return;
				break;
			}
		}
	}

		
}
void php_wxCollapsiblePane_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxCollapsiblePane_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxCollapsiblePane, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8))\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8));

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3)\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3);

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4)\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0)\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0);

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(size0);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(size0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(validator0);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(size0);
				((wxCollapsiblePane_php*) _this)->references.AddReference(validator0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxCollapsiblePane_php();

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxCollapsiblePane);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxCollapsiblePane_php*) _this)->evnArray);
		
		array_init(((wxCollapsiblePane_php*) _this)->evnArray);
		
		((wxCollapsiblePane_php*) _this)->phpObj = getThis();
		
		((wxCollapsiblePane_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxCollapsiblePane_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxCollapsiblePane, IsExpanded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::IsExpanded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::IsExpanded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::IsExpanded())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->IsExpanded());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCollapsiblePane, IsCollapsed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::IsCollapsed\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::IsCollapsed\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::IsCollapsed())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->IsCollapsed());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCollapsiblePane, GetPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::GetPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::GetPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCollapsiblePane::GetPane() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxCollapsiblePane_php*)_this)->GetPane();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCollapsiblePane, Expand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::Expand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::Expand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCollapsiblePane::Expand()\n\n");
				#endif
				((wxCollapsiblePane_php*)_this)->Expand();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCollapsiblePane, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxCollapsiblePane, Collapse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::Collapse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::Collapse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool collapse0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&collapse0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &collapse0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCollapsiblePane::Collapse()\n\n");
				#endif
				((wxCollapsiblePane_php*)_this)->Collapse();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCollapsiblePane::Collapse(collapse0)\n\n");
				#endif
				((wxCollapsiblePane_php*)_this)->Collapse(collapse0);


				return;
				break;
			}
		}
	}

		
}
void php_wxComboPopup_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxComboPopup_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxComboPopup_php* object = static_cast<wxComboPopup_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxComboPopup done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxComboPopup, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxComboPopup_php();

				((wxComboPopup_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxComboPopup);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxComboPopup_php*) _this)->evnArray);
		
		array_init(((wxComboPopup_php*) _this)->evnArray);
		
		((wxComboPopup_php*) _this)->phpObj = getThis();
		
		((wxComboPopup_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxComboPopup_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxComboPopup, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::__get\n");
	php_printf("===========================================\n");
	#endif
	
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	
	char* name;
	int name_len;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::wxComboPopup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("m_combo", name) == 0)
	{
	}
	else
	{
		RETVAL_NULL();
	}
	
}
PHP_METHOD(php_wxComboPopup, SetStringValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::SetStringValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::SetStringValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::SetStringValue(wxString(value0, wxConvUTF8))\n\n");
				#endif
				((wxComboPopup_php*)_this)->SetStringValue(wxString(value0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboPopup, PaintComboControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::PaintComboControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::PaintComboControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* rect0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&dc0, php_wxDC_entry, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::PaintComboControl(*(wxDC*) object_pointer0_0, *(wxRect*) object_pointer0_1)\n\n");
				#endif
				((wxComboPopup_php*)_this)->PaintComboControl(*(wxDC*) object_pointer0_0, *(wxRect*) object_pointer0_1);

				references->AddReference(dc0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
void wxComboPopup_php::OnPopup()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::OnPopup\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnPopup", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboPopup::OnPopup();

}
void wxComboPopup_php::OnDismiss()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::OnDismiss\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDismiss", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboPopup::OnDismiss();

}
void wxComboPopup_php::OnComboKeyEvent(wxKeyEvent& event)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::OnComboKeyEvent\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnComboKeyEvent", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxKeyEvent_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&event, le_wxKeyEvent));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboPopup::OnComboKeyEvent(event);

}
void wxComboPopup_php::OnComboDoubleClick()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::OnComboDoubleClick\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnComboDoubleClick", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboPopup::OnComboDoubleClick();

}
PHP_METHOD(php_wxComboPopup, LazyCreate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::LazyCreate\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::LazyCreate\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboPopup::LazyCreate())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboPopup_php*)_this)->LazyCreate());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboPopup, IsCreated)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::IsCreated\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::IsCreated\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboPopup::IsCreated())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboPopup_php*)_this)->IsCreated());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboPopup, Init)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::Init\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::Init\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::Init()\n\n");
				#endif
				((wxComboPopup_php*)_this)->Init();


				return;
				break;
			}
		}
	}

		
}
wxString wxComboPopup_php::GetStringValue()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::GetStringValue\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetStringValue", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetStringValue'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	

}
wxWindow* wxComboPopup_php::GetControl()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::GetControl\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetControl", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetControl'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return (wxWindow*) return_object;
	

}
PHP_METHOD(php_wxComboPopup, GetComboCtrl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::GetComboCtrl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::GetComboCtrl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::GetComboCtrl() to return object pointer\n\n");
				#endif
				wxComboCtrl_php* value_to_return0;
				value_to_return0 = (wxComboCtrl_php*) ((wxComboPopup_php*)_this)->GetComboCtrl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxComboCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxComboCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboPopup, GetAdjustedSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::GetAdjustedSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::GetAdjustedSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long minWidth0;
	long prefHeight0;
	long maxHeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&minWidth0, &prefHeight0, &maxHeight0)\n");
		#endif
		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minWidth0, &prefHeight0, &maxHeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::GetAdjustedSize((int) minWidth0, (int) prefHeight0, (int) maxHeight0) to return new object\n\n");
				#endif
				wxSize value_to_return3;
				value_to_return3 = ((wxComboPopup_php*)_this)->GetAdjustedSize((int) minWidth0, (int) prefHeight0, (int) maxHeight0);
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboPopup, FindItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::FindItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::FindItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	char* trueItem0;
	long trueItem_len0;
	zval* trueItem0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|s' (&item0, &item_len0, &trueItem0, &trueItem_len0)\n");
		#endif
		char parse_parameters_string[] = "s|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0, &trueItem0, &trueItem_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &trueItem0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboPopup::FindItem(wxString(item0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboPopup_php*)_this)->FindItem(wxString(item0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				wxString string_arg0_1 = wxString(trueItem0, wxConvUTF8);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboPopup::FindItem(wxString(item0, wxConvUTF8), &string_arg0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboPopup_php*)_this)->FindItem(wxString(item0, wxConvUTF8), &string_arg0_1));

				char* temp_string0_1;
				temp_string0_1 = (char*)malloc(sizeof(wxChar)*(string_arg0_1.size()+1));
				strcpy (temp_string0_1, (const char *) string_arg0_1.char_str() );
				ZVAL_STRING(trueItem0_ref, (char*) temp_string0_1, 1);
				free(temp_string0_1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboPopup, Dismiss)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::Dismiss\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::Dismiss\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::Dismiss()\n\n");
				#endif
				((wxComboPopup_php*)_this)->Dismiss();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboPopup, DestroyPopup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::DestroyPopup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::DestroyPopup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::DestroyPopup()\n\n");
				#endif
				((wxComboPopup_php*)_this)->DestroyPopup();


				return;
				break;
			}
		}
	}

		
}
bool wxComboPopup_php::Create(wxWindow* parent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Create", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)parent, le_wxWindow));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'Create'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	

}
void php_wxComboCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxComboCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxComboCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxComboCtrl_php();

				((wxComboCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1);
				((wxComboCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1);
				((wxComboCtrl_php*) _this)->references.AddReference(pos1);
				((wxComboCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1);
				((wxComboCtrl_php*) _this)->references.AddReference(pos1);
				((wxComboCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1);
				((wxComboCtrl_php*) _this)->references.AddReference(pos1);
				((wxComboCtrl_php*) _this)->references.AddReference(size1);
				((wxComboCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1);
				((wxComboCtrl_php*) _this)->references.AddReference(pos1);
				((wxComboCtrl_php*) _this)->references.AddReference(size1);
				((wxComboCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxComboCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxComboCtrl_php*) _this)->evnArray);
		
		array_init(((wxComboCtrl_php*) _this)->evnArray);
		
		((wxComboCtrl_php*) _this)->phpObj = getThis();
		
		((wxComboCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxComboCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxComboCtrl, UseAltPopupWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::UseAltPopupWindow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::UseAltPopupWindow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::UseAltPopupWindow()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->UseAltPopupWindow();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::UseAltPopupWindow(enable0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->UseAltPopupWindow(enable0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, Undo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Undo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Undo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Undo()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Undo();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, ShowPopup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::ShowPopup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::ShowPopup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::ShowPopup()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->ShowPopup();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetValue(wxString(value0, wxConvUTF8))\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetValue(wxString(value0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetTextIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetTextIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetTextIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long indent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&indent0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &indent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetTextIndent((int) indent0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetTextIndent((int) indent0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetTextCtrlStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetTextCtrlStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetTextCtrlStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetTextCtrlStyle((int) style0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetTextCtrlStyle((int) style0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetText(wxString(value0, wxConvUTF8))\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetText(wxString(value0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetSelection((long) from0, (long) to0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetSelection((long) from0, (long) to0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetPopupMinWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupMinWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupMinWidth((int) width0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupMinWidth((int) width0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetPopupMaxHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupMaxHeight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupMaxHeight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupMaxHeight((int) height0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupMaxHeight((int) height0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetPopupExtents)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupExtents\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupExtents\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long extLeft0;
	long extRight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&extLeft0, &extRight0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extLeft0, &extRight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupExtents((int) extLeft0, (int) extRight0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupExtents((int) extLeft0, (int) extRight0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetPopupControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* popup0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&popup0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &popup0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(popup0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(popup0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(popup0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupControl((wxComboPopup*) object_pointer0_0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupControl((wxComboPopup*) object_pointer0_0);

				references->AddReference(popup0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetPopupAnchor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupAnchor\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupAnchor\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long anchorSide0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&anchorSide0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &anchorSide0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupAnchor((int) anchorSide0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupAnchor((int) anchorSide0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long left0;
	long top0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&left0, &top0)\n");
		#endif
		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &left0, &top0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::SetMargins((wxCoord) left0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->SetMargins((wxCoord) left0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::SetMargins((wxCoord) left0, (wxCoord) top0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::SetMargins(*(wxPoint*) object_pointer1_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));

				references->AddReference(pt1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetInsertionPointEnd)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetInsertionPointEnd\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetInsertionPointEnd\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetInsertionPointEnd()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetInsertionPointEnd();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetInsertionPoint((long) pos0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetInsertionPoint((long) pos0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetCustomPaintWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetCustomPaintWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetCustomPaintWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetCustomPaintWidth((int) width0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetCustomPaintWidth((int) width0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetButtonPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetButtonPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetButtonPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long width0;
	long height0;
	long side0;
	long spacingX0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|llll' (&width0, &height0, &side0, &spacingX0)\n");
		#endif
		char parse_parameters_string[] = "|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &height0, &side0, &spacingX0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition((int) width0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition((int) width0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition((int) width0, (int) height0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition((int) width0, (int) height0);


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition((int) width0, (int) height0, (int) side0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition((int) width0, (int) height0, (int) side0);


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition((int) width0, (int) height0, (int) side0, (int) spacingX0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition((int) width0, (int) height0, (int) side0, (int) spacingX0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, SetButtonBitmaps)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetButtonBitmaps\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetButtonBitmaps\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* bmpNormal0 = 0;
	void* object_pointer0_0 = 0;
	bool pushButtonBg0;
	zval* bmpPressed0 = 0;
	void* object_pointer0_2 = 0;
	zval* bmpHover0 = 0;
	void* object_pointer0_3 = 0;
	zval* bmpDisabled0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|bOOO' (&bmpNormal0, php_wxBitmap_entry, &pushButtonBg0, &bmpPressed0, php_wxBitmap_entry, &bmpHover0, php_wxBitmap_entry, &bmpDisabled0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O|bOOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmpNormal0, php_wxBitmap_entry, &pushButtonBg0, &bmpPressed0, php_wxBitmap_entry, &bmpHover0, php_wxBitmap_entry, &bmpDisabled0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmpNormal0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmpNormal0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmpNormal0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(bmpPressed0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmpPressed0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmpPressed0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(bmpHover0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmpHover0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmpHover0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(bmpDisabled0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmpDisabled0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmpDisabled0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmpNormal0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0);

				references->AddReference(bmpNormal0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2);

				references->AddReference(bmpNormal0);
				references->AddReference(bmpPressed0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2, *(wxBitmap*) object_pointer0_3)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2, *(wxBitmap*) object_pointer0_3);

				references->AddReference(bmpNormal0);
				references->AddReference(bmpPressed0);
				references->AddReference(bmpHover0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2, *(wxBitmap*) object_pointer0_3, *(wxBitmap*) object_pointer0_4)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2, *(wxBitmap*) object_pointer0_3, *(wxBitmap*) object_pointer0_4);

				references->AddReference(bmpNormal0);
				references->AddReference(bmpPressed0);
				references->AddReference(bmpHover0);
				references->AddReference(bmpDisabled0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, Replace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Replace\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Replace\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls' (&from0, &to0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "lls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Replace((long) from0, (long) to0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Replace((long) from0, (long) to0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, Remove)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Remove\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Remove\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Remove((long) from0, (long) to0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Remove((long) from0, (long) to0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, Popup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Popup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Popup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Popup()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Popup();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, Paste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Paste\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Paste\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Paste()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Paste();


				return;
				break;
			}
		}
	}

		
}
void wxComboCtrl_php::OnButtonClick()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboCtrl::OnButtonClick\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnButtonClick", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboCtrl::OnButtonClick();

}
PHP_METHOD(php_wxComboCtrl, IsPopupWindowState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::IsPopupWindowState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::IsPopupWindowState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&state0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::IsPopupWindowState((int) state0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->IsPopupWindowState((int) state0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, IsPopupShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::IsPopupShown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::IsPopupShown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::IsPopupShown())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->IsPopupShown());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, HidePopup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::HidePopup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::HidePopup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool generateEvent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&generateEvent0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &generateEvent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::HidePopup()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->HidePopup();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::HidePopup(generateEvent0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->HidePopup(generateEvent0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxComboCtrl::GetValue().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxComboCtrl_php*)_this)->GetValue();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetTextRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetTextRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetTextRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetTextRect() to return object reference\n\n");
				#endif
				wxRect_php* value_to_return0;
				value_to_return0 = (wxRect_php*) &((wxComboCtrl_php*)_this)->GetTextRect();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxRect));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetTextIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetTextIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetTextIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetTextIndent())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboCtrl_php*)_this)->GetTextIndent());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetTextCtrl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetTextCtrl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetTextCtrl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetTextCtrl() to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return0;
				value_to_return0 = (wxTextCtrl_php*) ((wxComboCtrl_php*)_this)->GetTextCtrl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetPopupWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetPopupWindow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetPopupWindow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetPopupWindow() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxComboCtrl_php*)_this)->GetPopupWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetPopupControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetPopupControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetPopupControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetPopupControl() to return object pointer\n\n");
				#endif
				wxComboPopup_php* value_to_return0;
				value_to_return0 = (wxComboPopup_php*) ((wxComboCtrl_php*)_this)->GetPopupControl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxComboPopup_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxComboPopup));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetMargins() to return new object\n\n");
				#endif
				wxPoint value_to_return0;
				value_to_return0 = ((wxComboCtrl_php*)_this)->GetMargins();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetLastPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetLastPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetLastPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetLastPosition())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboCtrl_php*)_this)->GetLastPosition());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetInsertionPoint())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboCtrl_php*)_this)->GetInsertionPoint());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxComboCtrl::GetHint().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxComboCtrl_php*)_this)->GetHint();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetFeatures)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetFeatures\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetFeatures\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetFeatures())\n\n");
				#endif
				ZVAL_LONG(return_value, wxComboCtrl::GetFeatures());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetCustomPaintWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetCustomPaintWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetCustomPaintWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetCustomPaintWidth())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboCtrl_php*)_this)->GetCustomPaintWidth());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetButtonSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetButtonSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetButtonSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetButtonSize() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = ((wxComboCtrl_php*)_this)->GetButtonSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetBitmapPressed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetBitmapPressed\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetBitmapPressed\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetBitmapPressed() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxComboCtrl_php*)_this)->GetBitmapPressed();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetBitmapNormal)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetBitmapNormal\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetBitmapNormal\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetBitmapNormal() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxComboCtrl_php*)_this)->GetBitmapNormal();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetBitmapHover)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetBitmapHover\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetBitmapHover\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetBitmapHover() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxComboCtrl_php*)_this)->GetBitmapHover();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, GetBitmapDisabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetBitmapDisabled\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetBitmapDisabled\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetBitmapDisabled() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxComboCtrl_php*)_this)->GetBitmapDisabled();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, EnablePopupAnimation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::EnablePopupAnimation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::EnablePopupAnimation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::EnablePopupAnimation()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->EnablePopupAnimation();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::EnablePopupAnimation(enable0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->EnablePopupAnimation(enable0);


				return;
				break;
			}
		}
	}

		
}
void wxComboCtrl_php::DoShowPopup(const wxRect& rect, int flags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboCtrl::DoShowPopup\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DoShowPopup", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxRect_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[1], flags);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboCtrl::DoShowPopup(rect, flags);

}
void wxComboCtrl_php::DoSetPopupControl(wxComboPopup* popup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboCtrl::DoSetPopupControl\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DoSetPopupControl", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxComboPopup_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)popup, le_wxComboPopup));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboCtrl::DoSetPopupControl(popup);

}
PHP_METHOD(php_wxComboCtrl, Dismiss)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Dismiss\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Dismiss\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Dismiss()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Dismiss();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, Cut)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Cut\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Cut\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Cut()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Cut();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboCtrl, Copy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Copy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Copy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Copy()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Copy();


				return;
				break;
			}
		}
	}

		
}
bool wxComboCtrl_php::AnimateShow(const wxRect& rect, int flags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboCtrl::AnimateShow\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "AnimateShow", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxRect_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[1], flags);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxComboCtrl::AnimateShow(rect, flags);

}
PHP_METHOD(php_wxComboCtrl, SetHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* hint0;
	long hint_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&hint0, &hint_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &hint0, &hint_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::SetHint(wxString(hint0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
void php_wxComboBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxComboBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxComboBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long n0;
	zval* choices0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_8 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_7 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlalOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_8 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 6  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|lOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_6 = 1;
		HashTable* arr_hash0_6;
		if(arguments_received > 6)
		{
			arr_hash0_6 = Z_ARRVAL_P(choices0);
			array_count0_6 = zend_hash_num_elements(arr_hash0_6);
		}
		wxString* strings_array0_6 = new wxString[array_count0_6];
		bool strings_continue0_6 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;

				return;
				break;
			}
			case 8:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;

				return;
				break;
			}
			case 9:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0, *(wxValidator*) object_pointer0_8))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0, *(wxValidator*) object_pointer0_8));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;
				references->AddReference(validator0);

				return;
				break;
			}
			case 10:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0, *(wxValidator*) object_pointer0_8, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0, *(wxValidator*) object_pointer0_8, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_5;
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				references->AddReference(validator1);

				return;
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				references->AddReference(validator1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, Dismiss)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::Dismiss\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::Dismiss\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::Dismiss()\n\n");
				#endif
				((wxComboBox_php*)_this)->Dismiss();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool caseSensitive0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &caseSensitive0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &caseSensitive0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->FindString(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::FindString(wxString(string0, wxConvUTF8), caseSensitive0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, GetCurrentSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetCurrentSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetCurrentSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::GetCurrentSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetCurrentSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, GetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::GetInsertionPoint())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetInsertionPoint());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long* from1;
	zval* from1_ref;
	long* to1;
	zval* to1_ref;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (from1, to1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, from1, to1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &from1_ref, &to1_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::GetSelection((long*) from1, (long*) to1)\n\n");
				#endif
				((wxComboBox_php*)_this)->GetSelection((long*) from1, (long*) to1);

				size_t elements_returned1_0 = sizeof(from1)/sizeof(*from1);
				array_init(from1_ref);
				for(size_t i=0; i<elements_returned1_0; i++)
				{
					add_next_index_long(from1_ref, from1[i]);
				}
				size_t elements_returned1_1 = sizeof(to1)/sizeof(*to1);
				array_init(to1_ref);
				for(size_t i=0; i<elements_returned1_1; i++)
				{
					add_next_index_long(to1_ref, to1[i]);
				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxComboBox::GetString((unsigned int) n0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxComboBox_php*)_this)->GetString((unsigned int) n0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, GetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxComboBox::GetStringSelection().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxComboBox_php*)_this)->GetStringSelection();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, IsListEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::IsListEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::IsListEmpty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::IsListEmpty())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->IsListEmpty());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, IsTextEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::IsTextEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::IsTextEmpty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::IsTextEmpty())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->IsTextEmpty());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, Popup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::Popup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::Popup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::Popup()\n\n");
				#endif
				((wxComboBox_php*)_this)->Popup();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
	//Parameters for overload 1
	long from1;
	long to1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from1, &to1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from1, &to1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::SetSelection((int) n0)\n\n");
				#endif
				((wxComboBox_php*)_this)->SetSelection((int) n0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::SetSelection((long) from1, (long) to1)\n\n");
				#endif
				((wxComboBox_php*)_this)->SetSelection((long) from1, (long) to1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::SetValue(wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxComboBox_php*)_this)->SetValue(wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxComboBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 6  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|lOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_5;
		bool strings_continue0_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5)\n");
				#endif
				_this = new wxComboBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5);

				((wxComboBox_php*) _this)->references.Initialize();
				((wxComboBox_php*) _this)->references.AddReference(parent0);
				((wxComboBox_php*) _this)->references.AddReference(pos0);
				((wxComboBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 7:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0)\n");
				#endif
				_this = new wxComboBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0);

				((wxComboBox_php*) _this)->references.Initialize();
				((wxComboBox_php*) _this)->references.AddReference(parent0);
				((wxComboBox_php*) _this)->references.AddReference(pos0);
				((wxComboBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 8:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7)\n");
				#endif
				_this = new wxComboBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7);

				((wxComboBox_php*) _this)->references.Initialize();
				((wxComboBox_php*) _this)->references.AddReference(parent0);
				((wxComboBox_php*) _this)->references.AddReference(pos0);
				((wxComboBox_php*) _this)->references.AddReference(size0);
				((wxComboBox_php*) _this)->references.AddReference(validator0);
				break;
			}
			case 9:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxComboBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8));

				((wxComboBox_php*) _this)->references.Initialize();
				((wxComboBox_php*) _this)->references.AddReference(parent0);
				((wxComboBox_php*) _this)->references.AddReference(pos0);
				((wxComboBox_php*) _this)->references.AddReference(size0);
				((wxComboBox_php*) _this)->references.AddReference(validator0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxComboBox_php();

				((wxComboBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxComboBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxComboBox_php*) _this)->evnArray);
		
		array_init(((wxComboBox_php*) _this)->evnArray);
		
		((wxComboBox_php*) _this)->phpObj = getThis();
		
		((wxComboBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxComboBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxComboBox, SetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::SetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&n0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::SetString((unsigned int) n0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxComboBox_php*)_this)->SetString((unsigned int) n0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
void php_wxControl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxControl_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxControl_php* object = static_cast<wxControl_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting object by calling destroy\n");
			#endif
			
			object->Destroy();
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxControl done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxControl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxControl_php();

				((wxControl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1);
				((wxControl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1);
				((wxControl_php*) _this)->references.AddReference(pos1);
				((wxControl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1);
				((wxControl_php*) _this)->references.AddReference(pos1);
				((wxControl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1);
				((wxControl_php*) _this)->references.AddReference(pos1);
				((wxControl_php*) _this)->references.AddReference(size1);
				((wxControl_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8));

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1);
				((wxControl_php*) _this)->references.AddReference(pos1);
				((wxControl_php*) _this)->references.AddReference(size1);
				((wxControl_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxControl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxControl_php*) _this)->evnArray);
		
		array_init(((wxControl_php*) _this)->evnArray);
		
		((wxControl_php*) _this)->phpObj = getThis();
		
		((wxControl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxControl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxControl, GetLabelText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::GetLabelText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::GetLabelText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	char* label1;
	long label_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&label1, &label_len1)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, &label_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxControl::GetLabelText().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxControl_php*)_this)->GetLabelText();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxControl::GetLabelText(wxString(label1, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = wxControl::GetLabelText(wxString(label1, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxControl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxControl, SetLabelMarkup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::SetLabelMarkup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::SetLabelMarkup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* markup0;
	long markup_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&markup0, &markup_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &markup0, &markup_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::SetLabelMarkup(wxString(markup0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->SetLabelMarkup(wxString(markup0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxControl, SetLabelText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::SetLabelText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::SetLabelText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxControl::SetLabelText(wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxControl_php*)_this)->SetLabelText(wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxControl, RemoveMnemonics)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::RemoveMnemonics\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::RemoveMnemonics\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* str0;
	long str_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&str0, &str_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &str0, &str_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxControl::RemoveMnemonics(wxString(str0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = wxControl::RemoveMnemonics(wxString(str0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxControl, SetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::SetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::SetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&label0, &label_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxControl::SetLabel(wxString(label0, wxConvUTF8))\n\n");
				#endif
				((wxControl_php*)_this)->SetLabel(wxString(label0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxControl, GetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::GetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::GetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxControl::GetLabel().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxControl_php*)_this)->GetLabel();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxControl, EscapeMnemonics)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::EscapeMnemonics\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::EscapeMnemonics\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxControl::EscapeMnemonics(wxString(text0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = wxControl::EscapeMnemonics(wxString(text0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxControl, Command)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::Command\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::Command\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* event0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&event0, php_wxCommandEvent_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &event0, php_wxCommandEvent_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(event0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(event0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(event0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxControl::Command(*(wxCommandEvent*) object_pointer0_0)\n\n");
				#endif
				((wxControl_php*)_this)->Command(*(wxCommandEvent*) object_pointer0_0);

				references->AddReference(event0);

				return;
				break;
			}
		}
	}

		
}
void php_wxItemContainerImmutable_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxItemContainerImmutable_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxItemContainerImmutable_php* object = static_cast<wxItemContainerImmutable_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxItemContainerImmutable done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxItemContainerImmutable, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainerImmutable::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainerImmutable::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainerImmutable){
				references = &((wxItemContainerImmutable_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxItemContainer) && (!reference_type_found)){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool caseSensitive0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &caseSensitive0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &caseSensitive0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainerImmutable::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->FindString(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->FindString(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->FindString(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					ZVAL_LONG(return_value, ((wxItemContainerImmutable_php*)_this)->FindString(wxString(string0, wxConvUTF8)));
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainerImmutable::FindString(wxString(string0, wxConvUTF8), caseSensitive0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					ZVAL_LONG(return_value, ((wxItemContainerImmutable_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));
				}


				return;
				break;
			}
		}
	}

		
}
wxString wxItemContainerImmutable_php::GetString(unsigned int n)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetString", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetString'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	

}
unsigned int wxItemContainerImmutable_php::GetCount()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetCount", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetCount'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (unsigned int) Z_LVAL_P(return_value);
	

}
int wxItemContainerImmutable_php::GetSelection()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetSelection", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetSelection'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	

}
PHP_METHOD(php_wxItemContainerImmutable, GetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainerImmutable::GetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainerImmutable::GetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainerImmutable){
				references = &((wxItemContainerImmutable_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxItemContainer) && (!reference_type_found)){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxItemContainerImmutable::GetStringSelection().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxItemContainer)
				{
					value_to_return0 = ((wxItemContainer_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					value_to_return0 = ((wxControlWithItems_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					value_to_return0 = ((wxListBox_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					value_to_return0 = ((wxCheckListBox_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					value_to_return0 = ((wxRearrangeList_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					value_to_return0 = ((wxChoice_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					value_to_return0 = ((wxSimpleHtmlListBox_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxRadioBox)
				{
					value_to_return0 = ((wxRadioBox_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					value_to_return0 = ((wxItemContainerImmutable_php*)_this)->GetStringSelection();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxItemContainerImmutable, GetStrings)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainerImmutable::GetStrings\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainerImmutable::GetStrings\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainerImmutable){
				references = &((wxItemContainerImmutable_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxItemContainer) && (!reference_type_found)){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxItemContainerImmutable::GetStrings() to return strings array\n\n");
				#endif
				wxArrayString value_to_return0;
				if(parent_rsrc_type == le_wxItemContainer)
				{
					value_to_return0 = ((wxItemContainer_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					value_to_return0 = ((wxControlWithItems_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					value_to_return0 = ((wxListBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					value_to_return0 = ((wxCheckListBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					value_to_return0 = ((wxRearrangeList_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					value_to_return0 = ((wxChoice_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return0 = ((wxComboBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					value_to_return0 = ((wxSimpleHtmlListBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxRadioBox)
				{
					value_to_return0 = ((wxRadioBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					value_to_return0 = ((wxItemContainerImmutable_php*)_this)->GetStrings();
				}
				char* temp_string0;
				array_init(return_value);
				for(size_t i=0; i<value_to_return0.GetCount(); i++)
				{
					temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0[i].size()+1));
					strcpy (temp_string0, (const char *) value_to_return0[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string0, 1);
					free(temp_string0);
				}


				return;
				break;
			}
		}
	}

		
}
void wxItemContainerImmutable_php::SetSelection(int n)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetSelection", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetSelection'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxItemContainerImmutable_php::SetString(unsigned int n, const wxString& string)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetString", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
	temp_string = (char*)malloc(sizeof(wxChar)*(string.size()+1));
	strcpy(temp_string, (const char *) string.char_str());
	ZVAL_STRING(arguments[1], temp_string, 1);
	free(temp_string);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetString'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
PHP_METHOD(php_wxItemContainerImmutable, SetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainerImmutable::SetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainerImmutable::SetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainerImmutable){
				references = &((wxItemContainerImmutable_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxItemContainer) && (!reference_type_found)){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxItemContainerImmutable::SetStringSelection(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_BOOL(return_value, ((wxItemContainer_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_BOOL(return_value, ((wxControlWithItems_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxRadioBox)
				{
					ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					ZVAL_BOOL(return_value, ((wxItemContainerImmutable_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxItemContainer_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxItemContainer_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxItemContainer_php* object = static_cast<wxItemContainer_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxItemContainer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxItemContainer, Append)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Append\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Append\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* items1 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&item0, &item_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&items1)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &items1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainer::Append(wxString(item0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					ZVAL_LONG(return_value, ((wxListBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					ZVAL_LONG(return_value, ((wxCheckListBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					ZVAL_LONG(return_value, ((wxRearrangeList_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_LONG(return_value, ((wxChoice_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_0;
		bool strings_continue1_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index1_0 = 0;
				zval** temp_array_value1_0 = 0;
				while(strings_continue1_0)
				{
					if(zend_hash_index_find(HASH_OF(items1), array_index1_0, (void**)&temp_array_value1_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_0);
						strings_array1_0.Add(wxString(Z_STRVAL_PP(temp_array_value1_0), wxConvUTF8));
						array_index1_0++;
					}
					else
					{
						strings_continue1_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainer::Append(strings_array1_0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					ZVAL_LONG(return_value, ((wxListBox_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					ZVAL_LONG(return_value, ((wxCheckListBox_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					ZVAL_LONG(return_value, ((wxRearrangeList_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_LONG(return_value, ((wxChoice_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->Append(strings_array1_0));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxItemContainer, Delete)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Delete\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Delete\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxItemContainer::Delete((unsigned int) n0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					((wxControlWithItems_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					((wxListBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					((wxCheckListBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					((wxRearrangeList_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					((wxChoice_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					((wxSimpleHtmlListBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					((wxItemContainer_php*)_this)->Delete((unsigned int) n0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxItemContainer, Insert)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Insert\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Insert\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	long pos0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* items1 = 0;
	long pos1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl' (&item0, &item_len0, &pos0)\n");
		#endif
		char parse_parameters_string[] = "sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'al' (&items1, &pos1)\n");
		#endif
		char parse_parameters_string[] = "al";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &items1, &pos1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainer::Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					ZVAL_LONG(return_value, ((wxListBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					ZVAL_LONG(return_value, ((wxCheckListBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					ZVAL_LONG(return_value, ((wxRearrangeList_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_LONG(return_value, ((wxChoice_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_0;
		bool strings_continue1_0 = true;

		switch(arguments_received)
		{
			case 2:
			{
				int array_index1_0 = 0;
				zval** temp_array_value1_0 = 0;
				while(strings_continue1_0)
				{
					if(zend_hash_index_find(HASH_OF(items1), array_index1_0, (void**)&temp_array_value1_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_0);
						strings_array1_0.Add(wxString(Z_STRVAL_PP(temp_array_value1_0), wxConvUTF8));
						array_index1_0++;
					}
					else
					{
						strings_continue1_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainer::Insert(strings_array1_0, (unsigned int) pos1))\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					ZVAL_LONG(return_value, ((wxListBox_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					ZVAL_LONG(return_value, ((wxCheckListBox_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					ZVAL_LONG(return_value, ((wxRearrangeList_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_LONG(return_value, ((wxChoice_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxItemContainer, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Clear\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxItemContainer::Clear()\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					((wxControlWithItems_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					((wxListBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					((wxCheckListBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					((wxRearrangeList_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					((wxChoice_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					((wxSimpleHtmlListBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					((wxItemContainer_php*)_this)->Clear();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxItemContainer, Set)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Set\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Set\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* items0 = 0;
	char* clientData0;
	long clientData_len0;
	zval* clientData0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'as' (&items0, &clientData0, &clientData_len0)\n");
		#endif
		char parse_parameters_string[] = "as";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &items0, &clientData0, &clientData_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &clientData0_ref );
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 2:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(items0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxItemContainer::Set(strings_array0_0, (void**) 0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					((wxControlWithItems_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					((wxListBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					((wxCheckListBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					((wxRearrangeList_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					((wxChoice_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					((wxSimpleHtmlListBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					((wxItemContainer_php*)_this)->Set(strings_array0_0, (void**) 0);
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxControlWithItems_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxControlWithItems_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
void php_wxDataViewCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxDataViewCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxDataViewCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(size0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(validator0);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8));

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(size0);
				((wxDataViewCtrl_php*) _this)->references.AddReference(validator0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxDataViewCtrl_php();

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxDataViewCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxDataViewCtrl_php*) _this)->evnArray);
		
		array_init(((wxDataViewCtrl_php*) _this)->evnArray);
		
		((wxDataViewCtrl_php*) _this)->phpObj = getThis();
		
		((wxDataViewCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxDataViewCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxDataViewCtrl, UnselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::UnselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::UnselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::UnselectAll()\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->UnselectAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, Unselect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Unselect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Unselect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::Unselect(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->Unselect(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, SetRowHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SetRowHeight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SetRowHeight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long rowHeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&rowHeight0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rowHeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::SetRowHeight((int) rowHeight0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->SetRowHeight((int) rowHeight0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, SetIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SetIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SetIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long indent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&indent0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &indent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::SetIndent((int) indent0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->SetIndent((int) indent0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, SetExpanderColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SetExpanderColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SetExpanderColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&col0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::SetExpanderColumn((wxDataViewColumn*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->SetExpanderColumn((wxDataViewColumn*) object_pointer0_0);

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, SetCurrentItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SetCurrentItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SetCurrentItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::SetCurrentItem(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->SetCurrentItem(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::SelectAll()\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->SelectAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, Select)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Select\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Select\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::Select(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->Select(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, PrependColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::PrependColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::PrependColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&col0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::PrependColumn((wxDataViewColumn*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->PrependColumn((wxDataViewColumn*) object_pointer0_0));

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::IsSelected(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->IsSelected(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, IsExpanded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::IsExpanded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::IsExpanded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::IsExpanded(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->IsExpanded(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, InsertColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::InsertColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::InsertColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lz' (&pos0, &col0)\n");
		#endif
		char parse_parameters_string[] = "lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::InsertColumn((unsigned int) pos0, (wxDataViewColumn*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->InsertColumn((unsigned int) pos0, (wxDataViewColumn*) object_pointer0_1));

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, HitTest)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::HitTest\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::HitTest\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* point0 = 0;
	void* object_pointer0_0 = 0;
	zval* item0 = 0;
	void* object_pointer0_1 = 0;
	zval* col0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOz' (&point0, php_wxPoint_entry, &item0, php_wxDataViewItem_entry, &col0)\n");
		#endif
		char parse_parameters_string[] = "OOz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &point0, php_wxPoint_entry, &item0, php_wxDataViewItem_entry, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(point0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(point0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(point0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::HitTest(*(wxPoint*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, (wxDataViewColumn*&) object_pointer0_2)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, (wxDataViewColumn*&) object_pointer0_2);

				references->AddReference(point0);
				references->AddReference(item0);
				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, HasSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::HasSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::HasSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::HasSelection())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->HasSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetSortingColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetSortingColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetSortingColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetSortingColumn() to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return0;
				value_to_return0 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->GetSortingColumn();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, AppendBitmapColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendBitmapColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendBitmapColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, AppendColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&col0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::AppendColumn((wxDataViewColumn*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->AppendColumn((wxDataViewColumn*) object_pointer0_0));

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, AppendDateColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendDateColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendDateColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, AppendIconTextColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendIconTextColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendIconTextColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, AppendProgressColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendProgressColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendProgressColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, AppendTextColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendTextColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendTextColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, AppendToggleColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendToggleColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendToggleColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(label1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, AssociateModel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AssociateModel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AssociateModel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* model0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&model0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &model0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(model0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(model0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxDataViewListModel && rsrc_type != le_wxDataViewIndexListModel && rsrc_type != le_wxDataViewListStore && rsrc_type != le_wxDataViewVirtualListModel && rsrc_type != le_wxDataViewTreeStore))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(model0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::AssociateModel((wxDataViewModel*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->AssociateModel((wxDataViewModel*) object_pointer0_0));

				references->AddReference(model0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, ClearColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::ClearColumns\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::ClearColumns\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::ClearColumns())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->ClearColumns());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, Collapse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Collapse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Collapse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::Collapse(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->Collapse(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, DeleteColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::DeleteColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::DeleteColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* column0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&column0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::DeleteColumn((wxDataViewColumn*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->DeleteColumn((wxDataViewColumn*) object_pointer0_0));

				references->AddReference(column0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, EnableDragSource)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::EnableDragSource\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::EnableDragSource\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* format0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&format0, php_wxDataFormat_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(format0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::EnableDragSource(*(wxDataFormat*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->EnableDragSource(*(wxDataFormat*) object_pointer0_0));

				references->AddReference(format0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, EnableDropTarget)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::EnableDropTarget\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::EnableDropTarget\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* format0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&format0, php_wxDataFormat_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(format0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::EnableDropTarget(*(wxDataFormat*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->EnableDropTarget(*(wxDataFormat*) object_pointer0_0));

				references->AddReference(format0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, EnsureVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::EnsureVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::EnsureVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* column0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|z' (&item0, php_wxDataViewItem_entry, &column0)\n");
		#endif
		char parse_parameters_string[] = "O|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &column0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::EnsureVisible(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->EnsureVisible(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::EnsureVisible(*(wxDataViewItem*) object_pointer0_0, (const wxDataViewColumn*) object_pointer0_1)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->EnsureVisible(*(wxDataViewItem*) object_pointer0_0, (const wxDataViewColumn*) object_pointer0_1);

				references->AddReference(item0);
				references->AddReference(column0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, Expand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Expand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Expand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::Expand(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->Expand(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, ExpandAncestors)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::ExpandAncestors\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::ExpandAncestors\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::ExpandAncestors(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->ExpandAncestors(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetColumn((unsigned int) pos0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->GetColumn((unsigned int) pos0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewCtrl::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewCtrl_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetColumnPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetColumnPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetColumnPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* column0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&column0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewCtrl::GetColumnPosition((const wxDataViewColumn*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewCtrl_php*)_this)->GetColumnPosition((const wxDataViewColumn*) object_pointer0_0));

				references->AddReference(column0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetCurrentItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetCurrentItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetCurrentItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetCurrentItem() to return new object\n\n");
				#endif
				wxDataViewItem value_to_return0;
				value_to_return0 = ((wxDataViewCtrl_php*)_this)->GetCurrentItem();
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetExpanderColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetExpanderColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetExpanderColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetExpanderColumn() to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return0;
				value_to_return0 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->GetExpanderColumn();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewCtrl::GetIndent())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewCtrl_php*)_this)->GetIndent());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|z' (&item0, php_wxDataViewItem_entry, &col0)\n");
		#endif
		char parse_parameters_string[] = "O|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetItemRect(*(wxDataViewItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxRect value_to_return1;
				value_to_return1 = ((wxDataViewCtrl_php*)_this)->GetItemRect(*(wxDataViewItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetItemRect(*(wxDataViewItem*) object_pointer0_0, (const wxDataViewColumn*) object_pointer0_1) to return new object\n\n");
				#endif
				wxRect value_to_return2;
				value_to_return2 = ((wxDataViewCtrl_php*)_this)->GetItemRect(*(wxDataViewItem*) object_pointer0_0, (const wxDataViewColumn*) object_pointer0_1);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));

				references->AddReference(item0);
				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetModel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetModel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetModel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetModel() to return object pointer\n\n");
				#endif
				wxDataViewModel_php* value_to_return0;
				value_to_return0 = (wxDataViewModel_php*) ((wxDataViewCtrl_php*)_this)->GetModel();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewModel_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewModel));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetSelectedItemsCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetSelectedItemsCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetSelectedItemsCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewCtrl::GetSelectedItemsCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewCtrl_php*)_this)->GetSelectedItemsCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewCtrl, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetSelection() to return new object\n\n");
				#endif
				wxDataViewItem value_to_return0;
				value_to_return0 = ((wxDataViewCtrl_php*)_this)->GetSelection();
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));


				return;
				break;
			}
		}
	}

		
}
void php_wxDataViewListCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxDataViewListCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxDataViewListCtrl, AppendColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* column0 = 0;
	void* object_pointer0_0 = 0;
	char* varianttype0;
	long varianttype_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zs' (&column0, &varianttype0, &varianttype_len0)\n");
		#endif
		char parse_parameters_string[] = "zs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0, &varianttype0, &varianttype_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendColumn((wxDataViewColumn*) object_pointer0_0, wxString(varianttype0, wxConvUTF8))\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->AppendColumn((wxDataViewColumn*) object_pointer0_0, wxString(varianttype0, wxConvUTF8));

				references->AddReference(column0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, AppendIconTextColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendIconTextColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendIconTextColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llll' (&label0, &label_len0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, AppendProgressColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendProgressColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendProgressColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llll' (&label0, &label_len0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, AppendTextColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendTextColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendTextColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llll' (&label0, &label_len0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, AppendToggleColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendToggleColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendToggleColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llll' (&label0, &label_len0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlO' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::DeleteAllItems()\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->DeleteAllItems();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, DeleteItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::DeleteItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::DeleteItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::DeleteItem((unsigned) row0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->DeleteItem((unsigned) row0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, GetSelectedRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetSelectedRow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetSelectedRow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewListCtrl::GetSelectedRow())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewListCtrl_php*)_this)->GetSelectedRow());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, GetStore)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetStore\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetStore\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::GetStore() to return object pointer\n\n");
				#endif
				wxDataViewListStore_php* value_to_return0;
				value_to_return0 = (wxDataViewListStore_php*) ((wxDataViewListCtrl_php*)_this)->GetStore();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewListStore_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewListStore));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::GetStore() to return object pointer\n\n");
				#endif
				wxDataViewListStore_php* value_to_return0;
				value_to_return0 = (wxDataViewListStore_php*) ((wxDataViewListCtrl_php*)_this)->GetStore();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewListStore_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewListStore));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, GetTextValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetTextValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetTextValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxDataViewListCtrl::GetTextValue((unsigned int) row0, (unsigned int) col0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				value_to_return2 = ((wxDataViewListCtrl_php*)_this)->GetTextValue((unsigned int) row0, (unsigned int) col0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, GetToggleValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetToggleValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetToggleValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::GetToggleValue((unsigned int) row0, (unsigned int) col0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->GetToggleValue((unsigned int) row0, (unsigned int) col0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* value0 = 0;
	void* object_pointer0_0 = 0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oll' (&value0, php_wxVariant_entry, &row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "Oll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, php_wxVariant_entry, &row0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(value0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(value0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(value0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::GetValue(*(wxVariant*) object_pointer0_0, (unsigned int) row0, (unsigned int) col0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->GetValue(*(wxVariant*) object_pointer0_0, (unsigned int) row0, (unsigned int) col0);

				references->AddReference(value0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, InsertColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::InsertColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::InsertColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	zval* column0 = 0;
	void* object_pointer0_1 = 0;
	char* varianttype0;
	long varianttype_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lzs' (&pos0, &column0, &varianttype0, &varianttype_len0)\n");
		#endif
		char parse_parameters_string[] = "lzs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &column0, &varianttype0, &varianttype_len0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::InsertColumn((unsigned int) pos0, (wxDataViewColumn*) object_pointer0_1, wxString(varianttype0, wxConvUTF8))\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->InsertColumn((unsigned int) pos0, (wxDataViewColumn*) object_pointer0_1, wxString(varianttype0, wxConvUTF8));

				references->AddReference(column0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, IsRowSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::IsRowSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::IsRowSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::IsRowSelected((unsigned) row0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->IsRowSelected((unsigned) row0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, ItemToRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::ItemToRow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::ItemToRow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewListCtrl::ItemToRow(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewListCtrl_php*)_this)->ItemToRow(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, PrependColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::PrependColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::PrependColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* column0 = 0;
	void* object_pointer0_0 = 0;
	char* varianttype0;
	long varianttype_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zs' (&column0, &varianttype0, &varianttype_len0)\n");
		#endif
		char parse_parameters_string[] = "zs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0, &varianttype0, &varianttype_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::PrependColumn((wxDataViewColumn*) object_pointer0_0, wxString(varianttype0, wxConvUTF8))\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->PrependColumn((wxDataViewColumn*) object_pointer0_0, wxString(varianttype0, wxConvUTF8));

				references->AddReference(column0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, RowToItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::RowToItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::RowToItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::RowToItem((int) row0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return1;
				value_to_return1 = ((wxDataViewListCtrl_php*)_this)->RowToItem((int) row0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, SelectRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::SelectRow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::SelectRow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::SelectRow((unsigned) row0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->SelectRow((unsigned) row0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, SetTextValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::SetTextValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::SetTextValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sll' (&value0, &value_len0, &row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "sll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::SetTextValue(wxString(value0, wxConvUTF8), (unsigned int) row0, (unsigned int) col0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->SetTextValue(wxString(value0, wxConvUTF8), (unsigned int) row0, (unsigned int) col0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, SetToggleValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::SetToggleValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::SetToggleValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool value0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'bll' (&value0, &row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "bll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::SetToggleValue(value0, (unsigned int) row0, (unsigned int) col0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->SetToggleValue(value0, (unsigned int) row0, (unsigned int) col0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* value0 = 0;
	void* object_pointer0_0 = 0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oll' (&value0, php_wxVariant_entry, &row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "Oll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, php_wxVariant_entry, &row0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(value0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(value0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(value0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::SetValue(*(wxVariant*) object_pointer0_0, (unsigned int) row0, (unsigned int) col0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->SetValue(*(wxVariant*) object_pointer0_0, (unsigned int) row0, (unsigned int) col0);

				references->AddReference(value0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, UnselectRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::UnselectRow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::UnselectRow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::UnselectRow((unsigned) row0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->UnselectRow((unsigned) row0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewListCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlO' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxDataViewListCtrl_php();

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1);
				((wxDataViewListCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1);
				((wxDataViewListCtrl_php*) _this)->references.AddReference(pos1);
				((wxDataViewListCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1);
				((wxDataViewListCtrl_php*) _this)->references.AddReference(pos1);
				((wxDataViewListCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1);
				((wxDataViewListCtrl_php*) _this)->references.AddReference(pos1);
				((wxDataViewListCtrl_php*) _this)->references.AddReference(size1);
				((wxDataViewListCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxDataViewListCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxDataViewListCtrl_php*) _this)->evnArray);
		
		array_init(((wxDataViewListCtrl_php*) _this)->evnArray);
		
		((wxDataViewListCtrl_php*) _this)->phpObj = getThis();
		
		((wxDataViewListCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxDataViewListCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxDataViewTreeCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxDataViewTreeCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxDataViewTreeCtrl, AppendContainer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::AppendContainer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::AppendContainer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long icon0;
	long expanded0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return5;
				value_to_return5 = ((wxDataViewTreeCtrl_php*)_this)->AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, AppendItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::AppendItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::AppendItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long icon0;
	zval* data0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|lz' (&parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_3) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_3);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlO' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::DeleteAllItems()\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->DeleteAllItems();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, DeleteChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::DeleteChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::DeleteChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::DeleteChildren(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->DeleteChildren(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, DeleteItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::DeleteItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::DeleteItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::DeleteItem(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->DeleteItem(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, GetChildCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetChildCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetChildCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&parent0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewTreeCtrl::GetChildCount(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewTreeCtrl_php*)_this)->GetChildCount(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, GetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetImageList() to return object pointer\n\n");
				#endif
				wxImageList_php* value_to_return0;
				value_to_return0 = (wxImageList_php*) ((wxDataViewTreeCtrl_php*)_this)->GetImageList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImageList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxImageList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, GetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetItemData(*(wxDataViewItem*) object_pointer0_0) to return object pointer\n\n");
				#endif
				wxClientData_php* value_to_return1;
				value_to_return1 = (wxClientData_php*) ((wxDataViewTreeCtrl_php*)_this)->GetItemData(*(wxDataViewItem*) object_pointer0_0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxClientData_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxClientData));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, GetItemExpandedIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetItemExpandedIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetItemExpandedIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetItemExpandedIcon(*(wxDataViewItem*) object_pointer0_0) to return object reference\n\n");
				#endif
				wxIcon_php* value_to_return1;
				value_to_return1 = (wxIcon_php*) &((wxDataViewTreeCtrl_php*)_this)->GetItemExpandedIcon(*(wxDataViewItem*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxIcon_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxIcon));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, GetItemIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetItemIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetItemIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetItemIcon(*(wxDataViewItem*) object_pointer0_0) to return object reference\n\n");
				#endif
				wxIcon_php* value_to_return1;
				value_to_return1 = (wxIcon_php*) &((wxDataViewTreeCtrl_php*)_this)->GetItemIcon(*(wxDataViewItem*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxIcon_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxIcon));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, GetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxDataViewTreeCtrl::GetItemText(*(wxDataViewItem*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxDataViewTreeCtrl_php*)_this)->GetItemText(*(wxDataViewItem*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, GetNthChild)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetNthChild\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetNthChild\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&parent0, php_wxDataViewItem_entry, &pos0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &pos0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetNthChild(*(wxDataViewItem*) object_pointer0_0, (unsigned int) pos0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->GetNthChild(*(wxDataViewItem*) object_pointer0_0, (unsigned int) pos0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, GetStore)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetStore\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetStore\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetStore() to return object pointer\n\n");
				#endif
				wxDataViewTreeStore_php* value_to_return0;
				value_to_return0 = (wxDataViewTreeStore_php*) ((wxDataViewTreeCtrl_php*)_this)->GetStore();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewTreeStore_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewTreeStore));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetStore() to return object pointer\n\n");
				#endif
				wxDataViewTreeStore_php* value_to_return0;
				value_to_return0 = (wxDataViewTreeStore_php*) ((wxDataViewTreeCtrl_php*)_this)->GetStore();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewTreeStore_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewTreeStore));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, InsertContainer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::InsertContainer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::InsertContainer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	zval* previous0 = 0;
	void* object_pointer0_1 = 0;
	char* text0;
	long text_len0;
	long icon0;
	long expanded0;
	zval* data0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOs|llz' (&parent0, php_wxDataViewItem_entry, &previous0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0)\n");
		#endif
		char parse_parameters_string[] = "OOs|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &previous0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(previous0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(previous0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(previous0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(previous0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(previous0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return5;
				value_to_return5 = ((wxDataViewTreeCtrl_php*)_this)->InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(previous0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_5) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return6;
				value_to_return6 = ((wxDataViewTreeCtrl_php*)_this)->InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_5);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return6, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(previous0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, InsertItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::InsertItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::InsertItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	zval* previous0 = 0;
	void* object_pointer0_1 = 0;
	char* text0;
	long text_len0;
	long icon0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOs|lz' (&parent0, php_wxDataViewItem_entry, &previous0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0)\n");
		#endif
		char parse_parameters_string[] = "OOs|lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &previous0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(previous0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(previous0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(previous0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(previous0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(previous0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return5;
				value_to_return5 = ((wxDataViewTreeCtrl_php*)_this)->InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(previous0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, IsContainer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::IsContainer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::IsContainer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::IsContainer(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->IsContainer(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, PrependContainer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::PrependContainer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::PrependContainer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long icon0;
	long expanded0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return5;
				value_to_return5 = ((wxDataViewTreeCtrl_php*)_this)->PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, PrependItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::PrependItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::PrependItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long icon0;
	zval* data0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|lz' (&parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_3) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_3);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imagelist0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imagelist0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imagelist0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imagelist0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imagelist0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imagelist0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imagelist0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, SetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* data0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oz' (&item0, php_wxDataViewItem_entry, &data0)\n");
		#endif
		char parse_parameters_string[] = "Oz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetItemData(*(wxDataViewItem*) object_pointer0_0, (wxClientData*) object_pointer0_1)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetItemData(*(wxDataViewItem*) object_pointer0_0, (wxClientData*) object_pointer0_1);

				references->AddReference(item0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, SetItemExpandedIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetItemExpandedIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetItemExpandedIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* icon0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxDataViewItem_entry, &icon0, php_wxIcon_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &icon0, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(icon0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(icon0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(icon0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetItemExpandedIcon(*(wxDataViewItem*) object_pointer0_0, *(wxIcon*) object_pointer0_1)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetItemExpandedIcon(*(wxDataViewItem*) object_pointer0_0, *(wxIcon*) object_pointer0_1);

				references->AddReference(item0);
				references->AddReference(icon0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, SetItemIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetItemIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetItemIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* icon0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxDataViewItem_entry, &icon0, php_wxIcon_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &icon0, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(icon0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(icon0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(icon0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetItemIcon(*(wxDataViewItem*) object_pointer0_0, *(wxIcon*) object_pointer0_1)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetItemIcon(*(wxDataViewItem*) object_pointer0_0, *(wxIcon*) object_pointer0_1);

				references->AddReference(item0);
				references->AddReference(icon0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, SetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os' (&item0, php_wxDataViewItem_entry, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &text0, &text_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetItemText(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetItemText(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataViewTreeCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlO' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxDataViewTreeCtrl_php();

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(pos1);
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(pos1);
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(pos1);
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(size1);
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxDataViewTreeCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxDataViewTreeCtrl_php*) _this)->evnArray);
		
		array_init(((wxDataViewTreeCtrl_php*) _this)->evnArray);
		
		((wxDataViewTreeCtrl_php*) _this)->phpObj = getThis();
		
		((wxDataViewTreeCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxDataViewTreeCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxGenericDirCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxGenericDirCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxGenericDirCtrl, CollapsePath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::CollapsePath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::CollapsePath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::CollapsePath(wxString(path0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->CollapsePath(wxString(path0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, CollapseTree)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::CollapseTree\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::CollapseTree\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::CollapseTree()\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->CollapseTree();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* dir0;
	long dir_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* filter0;
	long filter_len0;
	long defaultFilter0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlsls' (&parent0, &id0, &dir0, &dir_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &filter0, &filter_len0, &defaultFilter0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlsls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &dir0, &dir_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &filter0, &filter_len0, &defaultFilter0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8), (int) defaultFilter0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8), (int) defaultFilter0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8), (int) defaultFilter0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8), (int) defaultFilter0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, ExpandPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::ExpandPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::ExpandPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::ExpandPath(wxString(path0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->ExpandPath(wxString(path0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetDefaultPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetDefaultPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetDefaultPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGenericDirCtrl::GetDefaultPath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetDefaultPath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetFilePath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetFilePath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetFilePath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGenericDirCtrl::GetFilePath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetFilePath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetFilePaths)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetFilePaths\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetFilePaths\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* paths0 = 0;
	zval* paths0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&paths0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paths0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(paths0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::GetFilePaths(strings_array0_0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->GetFilePaths(strings_array0_0);

				char* temp_string0_0;
				array_init(paths0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(paths0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetFilter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetFilter\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetFilter\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGenericDirCtrl::GetFilter().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetFilter();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetFilterIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetFilterIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetFilterIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGenericDirCtrl::GetFilterIndex())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGenericDirCtrl_php*)_this)->GetFilterIndex());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGenericDirCtrl::GetPath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetPath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetPaths)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetPaths\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetPaths\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* paths0 = 0;
	zval* paths0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&paths0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paths0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(paths0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::GetPaths(strings_array0_0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->GetPaths(strings_array0_0);

				char* temp_string0_0;
				array_init(paths0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(paths0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetRootId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetRootId\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetRootId\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::GetRootId() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetRootId();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, GetTreeCtrl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetTreeCtrl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetTreeCtrl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::GetTreeCtrl() to return object pointer\n\n");
				#endif
				wxTreeCtrl_php* value_to_return0;
				value_to_return0 = (wxTreeCtrl_php*) ((wxGenericDirCtrl_php*)_this)->GetTreeCtrl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTreeCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTreeCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, Init)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::Init\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::Init\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::Init()\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->Init();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, ReCreateTree)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::ReCreateTree\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::ReCreateTree\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::ReCreateTree()\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->ReCreateTree();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, SelectPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SelectPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SelectPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool select0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&path0, &path_len0, &select0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0, &select0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SelectPath(wxString(path0, wxConvUTF8))\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SelectPath(wxString(path0, wxConvUTF8));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SelectPath(wxString(path0, wxConvUTF8), select0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SelectPath(wxString(path0, wxConvUTF8), select0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, SelectPaths)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SelectPaths\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SelectPaths\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* paths0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&paths0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paths0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(paths0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SelectPaths(strings_array0_0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SelectPaths(strings_array0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, SetDefaultPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SetDefaultPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SetDefaultPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SetDefaultPath(wxString(path0, wxConvUTF8))\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SetDefaultPath(wxString(path0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, SetFilter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SetFilter\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SetFilter\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* filter0;
	long filter_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filter0, &filter_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filter0, &filter_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SetFilter(wxString(filter0, wxConvUTF8))\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SetFilter(wxString(filter0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, SetFilterIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SetFilterIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SetFilterIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SetFilterIndex((int) n0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SetFilterIndex((int) n0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, SetPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SetPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SetPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SetPath(wxString(path0, wxConvUTF8))\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SetPath(wxString(path0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, ShowHidden)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::ShowHidden\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::ShowHidden\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::ShowHidden(show0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->ShowHidden(show0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, UnselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::UnselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::UnselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::UnselectAll()\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->UnselectAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGenericDirCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* dir1;
	long dir_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* filter1;
	long filter_len1;
	long defaultFilter1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlsls' (&parent1, &id1, &dir1, &dir_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &filter1, &filter_len1, &defaultFilter1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlsls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &dir1, &dir_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &filter1, &filter_len1, &defaultFilter1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxGenericDirCtrl_php();

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8))\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8));

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8))\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8));

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8), (int) defaultFilter1)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8), (int) defaultFilter1);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8), (int) defaultFilter1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8), (int) defaultFilter1, wxString(name1, wxConvUTF8));

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1);
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxGenericDirCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxGenericDirCtrl_php*) _this)->evnArray);
		
		array_init(((wxGenericDirCtrl_php*) _this)->evnArray);
		
		((wxGenericDirCtrl_php*) _this)->phpObj = getThis();
		
		((wxGenericDirCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxGenericDirCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxEditableListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxEditableListBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxEditableListBox, GetStrings)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxEditableListBox::GetStrings\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxEditableListBox::GetStrings\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxEditableListBox){
				references = &((wxEditableListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* strings0 = 0;
	zval* strings0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&strings0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &strings0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(strings0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxEditableListBox::GetStrings(strings_array0_0)\n\n");
				#endif
				((wxEditableListBox_php*)_this)->GetStrings(strings_array0_0);

				char* temp_string0_0;
				array_init(strings0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(strings0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxEditableListBox, SetStrings)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxEditableListBox::SetStrings\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxEditableListBox::SetStrings\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxEditableListBox){
				references = &((wxEditableListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* strings0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&strings0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &strings0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(strings0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxEditableListBox::SetStrings(strings_array0_0)\n\n");
				#endif
				((wxEditableListBox_php*)_this)->SetStrings(strings_array0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxEditableListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxEditableListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxEditableListBox_php();

				((wxEditableListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1);
				((wxEditableListBox_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1);
				((wxEditableListBox_php*) _this)->references.AddReference(pos1);
				((wxEditableListBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1);
				((wxEditableListBox_php*) _this)->references.AddReference(pos1);
				((wxEditableListBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1);
				((wxEditableListBox_php*) _this)->references.AddReference(pos1);
				((wxEditableListBox_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxEditableListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxEditableListBox_php*) _this)->evnArray);
		
		array_init(((wxEditableListBox_php*) _this)->evnArray);
		
		((wxEditableListBox_php*) _this)->phpObj = getThis();
		
		((wxEditableListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxEditableListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxEditableListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxEditableListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxEditableListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxEditableListBox){
				references = &((wxEditableListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
void php_wxFileCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxFileCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxFileCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxFileCtrl_php();

				((wxFileCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFileCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFileCtrl_php*) _this)->evnArray);
		
		array_init(((wxFileCtrl_php*) _this)->evnArray);
		
		((wxFileCtrl_php*) _this)->phpObj = getThis();
		
		((wxFileCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFileCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxFileCtrl, ShowHidden)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::ShowHidden\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::ShowHidden\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::ShowHidden(show0)\n\n");
				#endif
				((wxFileCtrl_php*)_this)->ShowHidden(show0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, SetWildcard)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::SetWildcard\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::SetWildcard\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* wildCard0;
	long wildCard_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&wildCard0, &wildCard_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &wildCard0, &wildCard_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::SetWildcard(wxString(wildCard0, wxConvUTF8))\n\n");
				#endif
				((wxFileCtrl_php*)_this)->SetWildcard(wxString(wildCard0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, SetFilterIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::SetFilterIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::SetFilterIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long filterIndex0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&filterIndex0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filterIndex0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::SetFilterIndex((int) filterIndex0)\n\n");
				#endif
				((wxFileCtrl_php*)_this)->SetFilterIndex((int) filterIndex0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, SetFilename)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::SetFilename\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::SetFilename\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filename0, &filename_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::SetFilename(wxString(filename0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->SetFilename(wxString(filename0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, SetDirectory)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::SetDirectory\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::SetDirectory\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* directory0;
	long directory_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&directory0, &directory_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &directory0, &directory_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::SetDirectory(wxString(directory0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->SetDirectory(wxString(directory0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, GetWildcard)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetWildcard\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetWildcard\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileCtrl::GetWildcard().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileCtrl_php*)_this)->GetWildcard();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, GetPaths)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetPaths\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetPaths\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* paths0 = 0;
	zval* paths0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&paths0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paths0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(paths0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::GetPaths(strings_array0_0)\n\n");
				#endif
				((wxFileCtrl_php*)_this)->GetPaths(strings_array0_0);

				char* temp_string0_0;
				array_init(paths0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(paths0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, GetPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileCtrl::GetPath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileCtrl_php*)_this)->GetPath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, GetFilterIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetFilterIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetFilterIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFileCtrl::GetFilterIndex())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxFileCtrl_php*)_this)->GetFilterIndex());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, GetFilenames)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetFilenames\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetFilenames\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* filenames0 = 0;
	zval* filenames0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&filenames0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filenames0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(filenames0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::GetFilenames(strings_array0_0)\n\n");
				#endif
				((wxFileCtrl_php*)_this)->GetFilenames(strings_array0_0);

				char* temp_string0_0;
				array_init(filenames0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(filenames0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, GetFilename)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetFilename\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetFilename\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileCtrl::GetFilename().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileCtrl_php*)_this)->GetFilename();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, GetDirectory)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetDirectory\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetDirectory\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileCtrl::GetDirectory().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileCtrl_php*)_this)->GetDirectory();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* defaultDirectory0;
	long defaultDirectory_len0;
	char* defaultFilename0;
	long defaultFilename_len0;
	char* wildCard0;
	long wildCard_len0;
	long style0;
	zval* pos0 = 0;
	void* object_pointer0_6 = 0;
	zval* size0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|ssslOOs' (&parent0, &id0, &defaultDirectory0, &defaultDirectory_len0, &defaultFilename0, &defaultFilename_len0, &wildCard0, &wildCard_len0, &style0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|ssslOOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &defaultDirectory0, &defaultDirectory_len0, &defaultFilename0, &defaultFilename_len0, &wildCard0, &wildCard_len0, &style0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6, *(wxSize*) object_pointer0_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6, *(wxSize*) object_pointer0_7));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6, *(wxSize*) object_pointer0_7, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6, *(wxSize*) object_pointer0_7, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
void php_wxGauge_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxGauge_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxGauge, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	long range0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zll|OOlOs' (&parent0, &id0, &range0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zll|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &range0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, GetBezelFace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::GetBezelFace\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::GetBezelFace\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGauge::GetBezelFace())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGauge_php*)_this)->GetBezelFace());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, GetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::GetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::GetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGauge::GetRange())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGauge_php*)_this)->GetRange());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, GetShadowWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::GetShadowWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::GetShadowWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGauge::GetShadowWidth())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGauge_php*)_this)->GetShadowWidth());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGauge::GetValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGauge_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, IsVertical)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::IsVertical\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::IsVertical\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::IsVertical())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->IsVertical());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, Pulse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::Pulse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::Pulse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::Pulse()\n\n");
				#endif
				((wxGauge_php*)_this)->Pulse();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, SetBezelFace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::SetBezelFace\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::SetBezelFace\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::SetBezelFace((int) width0)\n\n");
				#endif
				((wxGauge_php*)_this)->SetBezelFace((int) width0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long range0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&range0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &range0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::SetRange((int) range0)\n\n");
				#endif
				((wxGauge_php*)_this)->SetRange((int) range0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, SetShadowWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::SetShadowWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::SetShadowWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::SetShadowWidth((int) width0)\n\n");
				#endif
				((wxGauge_php*)_this)->SetShadowWidth((int) width0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::SetValue((int) pos0)\n\n");
				#endif
				((wxGauge_php*)_this)->SetValue((int) pos0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxGauge, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	long range1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zll|OOlOs' (&parent1, &id1, &range1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zll|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &range1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxGauge_php();

				((wxGauge_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1);
				((wxGauge_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1);
				((wxGauge_php*) _this)->references.AddReference(pos1);
				((wxGauge_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1);
				((wxGauge_php*) _this)->references.AddReference(pos1);
				((wxGauge_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1);
				((wxGauge_php*) _this)->references.AddReference(pos1);
				((wxGauge_php*) _this)->references.AddReference(size1);
				((wxGauge_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1);
				((wxGauge_php*) _this)->references.AddReference(pos1);
				((wxGauge_php*) _this)->references.AddReference(size1);
				((wxGauge_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxGauge);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxGauge_php*) _this)->evnArray);
		
		array_init(((wxGauge_php*) _this)->evnArray);
		
		((wxGauge_php*) _this)->phpObj = getThis();
		
		((wxGauge_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxGauge_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxHeaderColumn_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxHeaderColumn_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxHeaderColumn_php* object = static_cast<wxHeaderColumn_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxHeaderColumn done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
wxAlignment wxHeaderColumn_php::GetAlignment()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetAlignment", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetAlignment'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (wxAlignment) Z_LVAL_P(return_value);
	

}
wxBitmap wxHeaderColumn_php::GetBitmap()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetBitmap", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetBitmap'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxBitmap*) return_object;
	

}
int wxHeaderColumn_php::GetFlags()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFlags", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetFlags'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	

}
int wxHeaderColumn_php::GetMinWidth()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetMinWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetMinWidth'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	

}
wxString wxHeaderColumn_php::GetTitle()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetTitle\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetTitle", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetTitle'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	

}
int wxHeaderColumn_php::GetWidth()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetWidth'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	

}
PHP_METHOD(php_wxHeaderColumn, HasFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::HasFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::HasFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::HasFlag((int) flag0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->HasFlag((int) flag0));
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->HasFlag((int) flag0));
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->HasFlag((int) flag0));
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->HasFlag((int) flag0));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumn, IsHidden)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsHidden\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsHidden\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsHidden())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsHidden());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsHidden());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsHidden());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsHidden());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumn, IsReorderable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsReorderable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsReorderable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsReorderable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsReorderable());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsReorderable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsReorderable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsReorderable());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumn, IsResizeable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsResizeable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsResizeable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsResizeable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsResizeable());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsResizeable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsResizeable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsResizeable());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumn, IsShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsShown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsShown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsShown())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsShown());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsShown());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsShown());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsShown());
				}


				return;
				break;
			}
		}
	}

		
}
bool wxHeaderColumn_php::IsSortKey()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::IsSortKey\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "IsSortKey", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'IsSortKey'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	

}
bool wxHeaderColumn_php::IsSortOrderAscending()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::IsSortOrderAscending\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "IsSortOrderAscending", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'IsSortOrderAscending'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	

}
PHP_METHOD(php_wxHeaderColumn, IsSortable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsSortable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsSortable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsSortable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsSortable());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsSortable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsSortable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsSortable());
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxSettableHeaderColumn_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxSettableHeaderColumn_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxSettableHeaderColumn_php* object = static_cast<wxSettableHeaderColumn_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxSettableHeaderColumn done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxSettableHeaderColumn, UnsetAsSortKey)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::UnsetAsSortKey\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::UnsetAsSortKey\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::UnsetAsSortKey()\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->UnsetAsSortKey();
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->UnsetAsSortKey();
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->UnsetAsSortKey();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSettableHeaderColumn, ToggleSortOrder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::ToggleSortOrder\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::ToggleSortOrder\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::ToggleSortOrder()\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->ToggleSortOrder();
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->ToggleSortOrder();
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->ToggleSortOrder();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSettableHeaderColumn, ToggleFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::ToggleFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::ToggleFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::ToggleFlag((int) flag0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->ToggleFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->ToggleFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->ToggleFlag((int) flag0);
				}


				return;
				break;
			}
		}
	}

		
}
void wxSettableHeaderColumn_php::SetWidth(int width)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], width);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetWidth'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxSettableHeaderColumn_php::SetTitle(const wxString& title)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetTitle\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetTitle", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	temp_string = (char*)malloc(sizeof(wxChar)*(title.size()+1));
	strcpy(temp_string, (const char *) title.char_str());
	ZVAL_STRING(arguments[0], temp_string, 1);
	free(temp_string);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetTitle'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
PHP_METHOD(php_wxSettableHeaderColumn, SetSortable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetSortable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetSortable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool sortable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&sortable0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sortable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetSortable(sortable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetSortable(sortable0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetSortable(sortable0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetSortable(sortable0);
				}


				return;
				break;
			}
		}
	}

		
}
void wxSettableHeaderColumn_php::SetSortOrder(bool ascending)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetSortOrder\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetSortOrder", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_BOOL(arguments[0], ascending);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetSortOrder'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
PHP_METHOD(php_wxSettableHeaderColumn, SetResizeable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetResizeable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetResizeable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool resizable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&resizable0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &resizable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetResizeable(resizable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetResizeable(resizable0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetResizeable(resizable0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetResizeable(resizable0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSettableHeaderColumn, SetReorderable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetReorderable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetReorderable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool reorderable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&reorderable0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &reorderable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetReorderable(reorderable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetReorderable(reorderable0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetReorderable(reorderable0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetReorderable(reorderable0);
				}


				return;
				break;
			}
		}
	}

		
}
void wxSettableHeaderColumn_php::SetMinWidth(int minWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetMinWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], minWidth);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetMinWidth'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
PHP_METHOD(php_wxSettableHeaderColumn, SetHidden)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetHidden\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetHidden\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool hidden0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&hidden0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &hidden0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetHidden(hidden0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetHidden(hidden0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetHidden(hidden0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetHidden(hidden0);
				}


				return;
				break;
			}
		}
	}

		
}
void wxSettableHeaderColumn_php::SetFlags(int flags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFlags", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], flags);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetFlags'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
PHP_METHOD(php_wxSettableHeaderColumn, SetFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetFlag((int) flag0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetFlag((int) flag0);
				}


				return;
				break;
			}
		}
	}

		
}
void wxSettableHeaderColumn_php::SetBitmap(const wxBitmap& bitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetBitmap", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxBitmap_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&bitmap, le_wxBitmap));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetBitmap'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxSettableHeaderColumn_php::SetAlignment(wxAlignment align)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetAlignment", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], align);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetAlignment'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
PHP_METHOD(php_wxSettableHeaderColumn, ClearFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::ClearFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::ClearFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::ClearFlag((int) flag0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->ClearFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->ClearFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->ClearFlag((int) flag0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSettableHeaderColumn, ChangeFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::ChangeFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::ChangeFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flag0;
	bool set0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&flag0, &set0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0, &set0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::ChangeFlag((int) flag0, set0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->ChangeFlag((int) flag0, set0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->ChangeFlag((int) flag0, set0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->ChangeFlag((int) flag0, set0);
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxHeaderColumnSimple_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxHeaderColumnSimple_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxHeaderColumnSimple_php* object = static_cast<wxHeaderColumnSimple_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxHeaderColumnSimple done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxHeaderColumnSimple, GetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetAlignment\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderColumnSimple::GetAlignment())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderColumnSimple_php*)_this)->GetAlignment());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::GetBitmap() to return new object\n\n");
				#endif
				wxBitmap value_to_return0;
				value_to_return0 = ((wxHeaderColumnSimple_php*)_this)->GetBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, GetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetFlags\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderColumnSimple::GetFlags())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderColumnSimple_php*)_this)->GetFlags());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, GetMinWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetMinWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderColumnSimple::GetMinWidth())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderColumnSimple_php*)_this)->GetMinWidth());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, GetTitle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetTitle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetTitle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxHeaderColumnSimple::GetTitle().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxHeaderColumnSimple_php*)_this)->GetTitle();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderColumnSimple::GetWidth())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderColumnSimple_php*)_this)->GetWidth());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, IsSortKey)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::IsSortKey\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::IsSortKey\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumnSimple::IsSortKey())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsSortKey());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, IsSortOrderAscending)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::IsSortOrderAscending\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::IsSortOrderAscending\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumnSimple::IsSortOrderAscending())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsSortOrderAscending());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, SetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetAlignment\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long align0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&align0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &align0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetAlignment((wxAlignment) align0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetAlignment((wxAlignment) align0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, SetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, SetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetFlags\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flags0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetFlags((int) flags0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetFlags((int) flags0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, SetMinWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetMinWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long minWidth0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&minWidth0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minWidth0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetMinWidth((int) minWidth0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetMinWidth((int) minWidth0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, SetSortOrder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetSortOrder\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetSortOrder\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool ascending0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&ascending0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &ascending0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetSortOrder(ascending0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetSortOrder(ascending0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, SetTitle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetTitle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetTitle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* title0;
	long title_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&title0, &title_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &title0, &title_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetTitle(wxString(title0, wxConvUTF8))\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetTitle(wxString(title0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetWidth((int) width0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderColumnSimple, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	char* title0;
	long title_len0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* bitmap1 = 0;
	void* object_pointer1_0 = 0;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|lll' (&title0, &title_len0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &title0, &title_len0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|lll' (&bitmap1, php_wxBitmap_entry, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "O|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap1, php_wxBitmap_entry, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8))\n");
				#endif
				_this = new wxHeaderColumnSimple_php(wxString(title0, wxConvUTF8));

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), (int) width0)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(wxString(title0, wxConvUTF8), (int) width0);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0, (int) flags0)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0, (int) flags0);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(*(wxBitmap*) object_pointer1_0);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				((wxHeaderColumnSimple_php*) _this)->references.AddReference(bitmap1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0, (int) width1)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(*(wxBitmap*) object_pointer1_0, (int) width1);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				((wxHeaderColumnSimple_php*) _this)->references.AddReference(bitmap1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0, (int) width1, (wxAlignment) align1)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(*(wxBitmap*) object_pointer1_0, (int) width1, (wxAlignment) align1);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				((wxHeaderColumnSimple_php*) _this)->references.AddReference(bitmap1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0, (int) width1, (wxAlignment) align1, (int) flags1)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(*(wxBitmap*) object_pointer1_0, (int) width1, (wxAlignment) align1, (int) flags1);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				((wxHeaderColumnSimple_php*) _this)->references.AddReference(bitmap1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHeaderColumnSimple);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxHeaderColumnSimple_php*) _this)->evnArray);
		
		array_init(((wxHeaderColumnSimple_php*) _this)->evnArray);
		
		((wxHeaderColumnSimple_php*) _this)->phpObj = getThis();
		
		((wxHeaderColumnSimple_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHeaderColumnSimple_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxHeaderCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxHeaderCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxHeaderCtrl, AddColumnsItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::AddColumnsItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::AddColumnsItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* menu0 = 0;
	void* object_pointer0_0 = 0;
	long idColumnsBase0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&menu0, php_wxMenu_entry, &idColumnsBase0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &menu0, php_wxMenu_entry, &idColumnsBase0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(menu0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(menu0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(menu0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::AddColumnsItems(*(wxMenu*) object_pointer0_0)\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->AddColumnsItems(*(wxMenu*) object_pointer0_0);

				references->AddReference(menu0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::AddColumnsItems(*(wxMenu*) object_pointer0_0, (int) idColumnsBase0)\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->AddColumnsItems(*(wxMenu*) object_pointer0_0, (int) idColumnsBase0);

				references->AddReference(menu0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long winid0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &winid0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &winid0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
const wxHeaderColumn& wxHeaderCtrl_php::GetColumn(unsigned int idx)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrl::GetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetColumn", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], idx);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetColumn'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxHeaderColumn*) return_object;
	

}
PHP_METHOD(php_wxHeaderCtrl, GetColumnAt)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::GetColumnAt\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::GetColumnAt\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderCtrl::GetColumnAt((unsigned int) pos0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderCtrl_php*)_this)->GetColumnAt((unsigned int) pos0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrl, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderCtrl::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderCtrl_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrl, GetColumnPos)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::GetColumnPos\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::GetColumnPos\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderCtrl::GetColumnPos((unsigned int) idx0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderCtrl_php*)_this)->GetColumnPos((unsigned int) idx0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrl, IsEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::IsEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::IsEmpty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::IsEmpty())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->IsEmpty());


				return;
				break;
			}
		}
	}

		
}
void wxHeaderCtrl_php::OnColumnCountChanging(unsigned int count)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrl::OnColumnCountChanging\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnColumnCountChanging", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], count);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxHeaderCtrl::OnColumnCountChanging(count);

}
PHP_METHOD(php_wxHeaderCtrl, ResetColumnsOrder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::ResetColumnsOrder\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::ResetColumnsOrder\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::ResetColumnsOrder()\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->ResetColumnsOrder();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrl, SetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::SetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::SetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long count0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&count0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &count0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::SetColumnCount((unsigned int) count0)\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->SetColumnCount((unsigned int) count0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrl, ShowColumnsMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::ShowColumnsMenu\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::ShowColumnsMenu\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* pt0 = 0;
	void* object_pointer0_0 = 0;
	char* title0;
	long title_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|s' (&pt0, php_wxPoint_entry, &title0, &title_len0)\n");
		#endif
		char parse_parameters_string[] = "O|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint_entry, &title0, &title_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::ShowColumnsMenu(*(wxPoint*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->ShowColumnsMenu(*(wxPoint*) object_pointer0_0));

				references->AddReference(pt0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::ShowColumnsMenu(*(wxPoint*) object_pointer0_0, wxString(title0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->ShowColumnsMenu(*(wxPoint*) object_pointer0_0, wxString(title0, wxConvUTF8)));

				references->AddReference(pt0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrl, ShowCustomizeDialog)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::ShowCustomizeDialog\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::ShowCustomizeDialog\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::ShowCustomizeDialog())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->ShowCustomizeDialog());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrl, UpdateColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::UpdateColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::UpdateColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::UpdateColumn((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->UpdateColumn((unsigned int) idx0);


				return;
				break;
			}
		}
	}

		
}
void wxHeaderCtrl_php::UpdateColumnVisibility(unsigned int idx, bool show)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrl::UpdateColumnVisibility\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "UpdateColumnVisibility", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], idx);
	ZVAL_BOOL(arguments[1], show);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxHeaderCtrl::UpdateColumnVisibility(idx, show);

}
bool wxHeaderCtrl_php::UpdateColumnWidthToFit(unsigned int idx, int widthTitle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrl::UpdateColumnWidthToFit\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "UpdateColumnWidthToFit", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], idx);
	ZVAL_LONG(arguments[1], widthTitle);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHeaderCtrl::UpdateColumnWidthToFit(idx, widthTitle);

}
PHP_METHOD(php_wxHeaderCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long winid1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxHeaderCtrl_php();

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1);
				((wxHeaderCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1);
				((wxHeaderCtrl_php*) _this)->references.AddReference(pos1);
				((wxHeaderCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1);
				((wxHeaderCtrl_php*) _this)->references.AddReference(pos1);
				((wxHeaderCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1);
				((wxHeaderCtrl_php*) _this)->references.AddReference(pos1);
				((wxHeaderCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHeaderCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxHeaderCtrl_php*) _this)->evnArray);
		
		array_init(((wxHeaderCtrl_php*) _this)->evnArray);
		
		((wxHeaderCtrl_php*) _this)->phpObj = getThis();
		
		((wxHeaderCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHeaderCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxHeaderCtrlSimple_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxHeaderCtrlSimple_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxHeaderCtrlSimple, AppendColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::AppendColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::AppendColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxHeaderColumnSimple_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxHeaderColumnSimple_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::AppendColumn(*(wxHeaderColumnSimple*) object_pointer0_0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->AppendColumn(*(wxHeaderColumnSimple*) object_pointer0_0);

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrlSimple, DeleteColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::DeleteColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::DeleteColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::DeleteColumn((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->DeleteColumn((unsigned int) idx0);


				return;
				break;
			}
		}
	}

		
}
int wxHeaderCtrlSimple_php::GetBestFittingWidth(unsigned int idx)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrlSimple::GetBestFittingWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetBestFittingWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], idx);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHeaderCtrlSimple::GetBestFittingWidth(idx);

}
PHP_METHOD(php_wxHeaderCtrlSimple, HideColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::HideColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::HideColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::HideColumn((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->HideColumn((unsigned int) idx0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrlSimple, InsertColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::InsertColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::InsertColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&col0, php_wxHeaderColumnSimple_entry, &idx0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxHeaderColumnSimple_entry, &idx0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::InsertColumn(*(wxHeaderColumnSimple*) object_pointer0_0, (unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->InsertColumn(*(wxHeaderColumnSimple*) object_pointer0_0, (unsigned int) idx0);

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrlSimple, RemoveSortIndicator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::RemoveSortIndicator\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::RemoveSortIndicator\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::RemoveSortIndicator()\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->RemoveSortIndicator();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrlSimple, ShowColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::ShowColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::ShowColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long idx0;
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&idx0, &show0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::ShowColumn((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->ShowColumn((unsigned int) idx0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::ShowColumn((unsigned int) idx0, show0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->ShowColumn((unsigned int) idx0, show0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrlSimple, ShowSortIndicator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::ShowSortIndicator\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::ShowSortIndicator\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long idx0;
	bool sortOrder0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&idx0, &sortOrder0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0, &sortOrder0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::ShowSortIndicator((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->ShowSortIndicator((unsigned int) idx0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::ShowSortIndicator((unsigned int) idx0, sortOrder0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->ShowSortIndicator((unsigned int) idx0, sortOrder0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHeaderCtrlSimple, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long winid1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxHeaderCtrlSimple_php();

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1);
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1);
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(pos1);
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1);
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(pos1);
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1);
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(pos1);
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHeaderCtrlSimple);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxHeaderCtrlSimple_php*) _this)->evnArray);
		
		array_init(((wxHeaderCtrlSimple_php*) _this)->evnArray);
		
		((wxHeaderCtrlSimple_php*) _this)->phpObj = getThis();
		
		((wxHeaderCtrlSimple_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHeaderCtrlSimple_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxHtmlListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxHtmlListBox_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxHtmlListBox_php* object = static_cast<wxHtmlListBox_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxHtmlListBox done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxHtmlListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHtmlListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxHtmlListBox_php();

				((wxHtmlListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1);
				((wxHtmlListBox_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1);
				((wxHtmlListBox_php*) _this)->references.AddReference(pos1);
				((wxHtmlListBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1);
				((wxHtmlListBox_php*) _this)->references.AddReference(pos1);
				((wxHtmlListBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1);
				((wxHtmlListBox_php*) _this)->references.AddReference(pos1);
				((wxHtmlListBox_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHtmlListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxHtmlListBox_php*) _this)->evnArray);
		
		array_init(((wxHtmlListBox_php*) _this)->evnArray);
		
		((wxHtmlListBox_php*) _this)->phpObj = getThis();
		
		((wxHtmlListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHtmlListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void wxHtmlListBox_php::OnLinkClicked(size_t n, const wxHtmlLinkInfo& link)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::OnLinkClicked\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnLinkClicked", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
	object_init_ex(arguments[1], php_wxHtmlLinkInfo_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&link, le_wxHtmlLinkInfo));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxHtmlListBox::OnLinkClicked(n, link);

}
wxColour wxHtmlListBox_php::GetSelectedTextColour(const wxColour& colFg)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::GetSelectedTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetSelectedTextColour", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxColour_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&colFg, le_wxColour));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxColour*) return_object;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHtmlListBox::GetSelectedTextColour(colFg);

}
wxColour wxHtmlListBox_php::GetSelectedTextBgColour(const wxColour& colBg)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::GetSelectedTextBgColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetSelectedTextBgColour", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxColour_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&colBg, le_wxColour));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxColour*) return_object;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHtmlListBox::GetSelectedTextBgColour(colBg);

}
wxString wxHtmlListBox_php::OnGetItemMarkup(size_t n)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::OnGetItemMarkup\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemMarkup", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHtmlListBox::OnGetItemMarkup(n);

}
wxString wxHtmlListBox_php::OnGetItem(size_t n)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::OnGetItem\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItem", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'OnGetItem'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	

}
PHP_METHOD(php_wxHtmlListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHtmlListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHtmlListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHtmlListBox){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
void php_wxSimpleHtmlListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxSimpleHtmlListBox_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxSimpleHtmlListBox_php* object = static_cast<wxSimpleHtmlListBox_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxSimpleHtmlListBox done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxSimpleHtmlListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSimpleHtmlListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSimpleHtmlListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSimpleHtmlListBox){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long n0;
	zval* choices0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlalOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_5 = 1;
		HashTable* arr_hash0_5;
		if(arguments_received > 5)
		{
			arr_hash0_5 = Z_ARRVAL_P(choices0);
			array_count0_5 = zend_hash_num_elements(arr_hash0_5);
		}
		wxString* strings_array0_5 = new wxString[array_count0_5];
		bool strings_continue0_5 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_5;

				return;
				break;
			}
			case 7:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_5;

				return;
				break;
			}
			case 8:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_5;
				references->AddReference(validator0);

				return;
				break;
			}
			case 9:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_5;
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_4;
		bool strings_continue1_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 6:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 7:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				references->AddReference(validator1);

				return;
				break;
			}
			case 8:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				references->AddReference(validator1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSimpleHtmlListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSimpleHtmlListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_4;
		bool strings_continue0_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4)\n");
				#endif
				_this = new wxSimpleHtmlListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4);

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(parent0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(pos0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0)\n");
				#endif
				_this = new wxSimpleHtmlListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0);

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(parent0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(pos0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 7:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxSimpleHtmlListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(parent0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(pos0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(size0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(validator0);
				break;
			}
			case 8:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxSimpleHtmlListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(parent0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(pos0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(size0);
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(validator0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSimpleHtmlListBox_php();

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSimpleHtmlListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxSimpleHtmlListBox_php*) _this)->evnArray);
		
		array_init(((wxSimpleHtmlListBox_php*) _this)->evnArray);
		
		((wxSimpleHtmlListBox_php*) _this)->phpObj = getThis();
		
		((wxSimpleHtmlListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSimpleHtmlListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxHyperlinkCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxHyperlinkCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxHyperlinkCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	char* url0;
	long url_len0;
	zval* pos0 = 0;
	void* object_pointer0_4 = 0;
	zval* size0 = 0;
	void* object_pointer0_5 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlss|OOls' (&parent0, &id0, &label0, &label_len0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlss|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHyperlinkCtrl, GetHoverColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::GetHoverColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::GetHoverColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::GetHoverColour() to return new object\n\n");
				#endif
				wxColour value_to_return0;
				value_to_return0 = ((wxHyperlinkCtrl_php*)_this)->GetHoverColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHyperlinkCtrl, GetNormalColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::GetNormalColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::GetNormalColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::GetNormalColour() to return new object\n\n");
				#endif
				wxColour value_to_return0;
				value_to_return0 = ((wxHyperlinkCtrl_php*)_this)->GetNormalColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHyperlinkCtrl, GetURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::GetURL\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::GetURL\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxHyperlinkCtrl::GetURL().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxHyperlinkCtrl_php*)_this)->GetURL();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
bool wxHyperlinkCtrl_php::GetVisited()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHyperlinkCtrl::GetVisited\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetVisited", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetVisited'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	

}
PHP_METHOD(php_wxHyperlinkCtrl, GetVisitedColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::GetVisitedColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::GetVisitedColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::GetVisitedColour() to return new object\n\n");
				#endif
				wxColour value_to_return0;
				value_to_return0 = ((wxHyperlinkCtrl_php*)_this)->GetVisitedColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHyperlinkCtrl, SetHoverColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::SetHoverColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::SetHoverColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* colour0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colour0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::SetHoverColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxHyperlinkCtrl_php*)_this)->SetHoverColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHyperlinkCtrl, SetNormalColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::SetNormalColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::SetNormalColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* colour0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colour0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::SetNormalColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxHyperlinkCtrl_php*)_this)->SetNormalColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHyperlinkCtrl, SetURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::SetURL\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::SetURL\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* url0;
	long url_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&url0, &url_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &url0, &url_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::SetURL(wxString(url0, wxConvUTF8))\n\n");
				#endif
				((wxHyperlinkCtrl_php*)_this)->SetURL(wxString(url0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
void wxHyperlinkCtrl_php::SetVisited(bool visited)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHyperlinkCtrl::SetVisited\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetVisited", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_BOOL(arguments[0], visited);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetVisited'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
PHP_METHOD(php_wxHyperlinkCtrl, SetVisitedColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::SetVisitedColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::SetVisitedColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* colour0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colour0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::SetVisitedColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxHyperlinkCtrl_php*)_this)->SetVisitedColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxHyperlinkCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	char* url0;
	long url_len0;
	zval* pos0 = 0;
	void* object_pointer0_4 = 0;
	zval* size0 = 0;
	void* object_pointer0_5 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlss|OOls' (&parent0, &id0, &label0, &label_len0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlss|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8))\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8));

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4)\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4);

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0);
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5)\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5);

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0);
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(pos0);
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0)\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0);

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0);
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(pos0);
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0, wxString(name0, wxConvUTF8));

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0);
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(pos0);
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(size0);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHyperlinkCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxHyperlinkCtrl_php*) _this)->evnArray);
		
		array_init(((wxHyperlinkCtrl_php*) _this)->evnArray);
		
		((wxHyperlinkCtrl_php*) _this)->phpObj = getThis();
		
		((wxHyperlinkCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHyperlinkCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxListBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_4;
		bool strings_continue0_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4)\n");
				#endif
				_this = new wxListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4);

				((wxListBox_php*) _this)->references.Initialize();
				((wxListBox_php*) _this)->references.AddReference(parent0);
				((wxListBox_php*) _this)->references.AddReference(pos0);
				((wxListBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0)\n");
				#endif
				_this = new wxListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0);

				((wxListBox_php*) _this)->references.Initialize();
				((wxListBox_php*) _this)->references.AddReference(parent0);
				((wxListBox_php*) _this)->references.AddReference(pos0);
				((wxListBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 7:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxListBox_php*) _this)->references.Initialize();
				((wxListBox_php*) _this)->references.AddReference(parent0);
				((wxListBox_php*) _this)->references.AddReference(pos0);
				((wxListBox_php*) _this)->references.AddReference(size0);
				((wxListBox_php*) _this)->references.AddReference(validator0);
				break;
			}
			case 8:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxListBox_php*) _this)->references.Initialize();
				((wxListBox_php*) _this)->references.AddReference(parent0);
				((wxListBox_php*) _this)->references.AddReference(pos0);
				((wxListBox_php*) _this)->references.AddReference(size0);
				((wxListBox_php*) _this)->references.AddReference(validator0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxListBox_php();

				((wxListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxListBox_php*) _this)->evnArray);
		
		array_init(((wxListBox_php*) _this)->evnArray);
		
		((wxListBox_php*) _this)->phpObj = getThis();
		
		((wxListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxListBox, SetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::SetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::SetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* s1;
	long s_len1;
	bool select1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sb' (&s1, &s_len1, &select1)\n");
		#endif
		char parse_parameters_string[] = "sb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s1, &s_len1, &select1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::SetStringSelection(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::SetStringSelection(wxString(s1, wxConvUTF8), select1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->SetStringSelection(wxString(s1, wxConvUTF8), select1));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, SetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::SetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&n0, &string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::SetString((unsigned int) n0, wxString(string0, wxConvUTF8))\n\n");
				#endif
				((wxListBox_php*)_this)->SetString((unsigned int) n0, wxString(string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::SetSelection((int) n0)\n\n");
				#endif
				((wxListBox_php*)_this)->SetSelection((int) n0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, SetFirstItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::SetFirstItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::SetFirstItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	long n1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n1)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::SetFirstItem(wxString(string0, wxConvUTF8))\n\n");
				#endif
				((wxListBox_php*)_this)->SetFirstItem(wxString(string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::SetFirstItem((int) n1)\n\n");
				#endif
				((wxListBox_php*)_this)->SetFirstItem((int) n1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, IsSorted)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::IsSorted\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::IsSorted\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::IsSorted())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->IsSorted());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, InsertItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::InsertItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::InsertItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* items0 = 0;
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'al' (&items0, &pos0)\n");
		#endif
		char parse_parameters_string[] = "al";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &items0, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 2:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(items0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::InsertItems(strings_array0_0, (unsigned int) pos0)\n\n");
				#endif
				((wxListBox_php*)_this)->InsertItems(strings_array0_0, (unsigned int) pos0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::IsSelected((int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->IsSelected((int) n0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, HitTest)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::HitTest\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::HitTest\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* point1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&point1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &point1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(point1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(point1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(point1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::HitTest((int) x0, (int) y0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->HitTest((int) x0, (int) y0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::HitTest(*(wxPoint*) object_pointer1_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->HitTest(*(wxPoint*) object_pointer1_0));

				references->AddReference(point1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::GetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxListBox::GetString((unsigned int) n0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxListBox_php*)_this)->GetString((unsigned int) n0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool caseSensitive0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &caseSensitive0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &caseSensitive0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->FindString(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::FindString(wxString(string0, wxConvUTF8), caseSensitive0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, EnsureVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::EnsureVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::EnsureVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::EnsureVisible((int) n0)\n\n");
				#endif
				((wxListBox_php*)_this)->EnsureVisible((int) n0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, Deselect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::Deselect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::Deselect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::Deselect((int) n0)\n\n");
				#endif
				((wxListBox_php*)_this)->Deselect((int) n0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long n1;
	zval* choices1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_7 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlalOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_4;
		bool strings_continue0_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		int array_count1_5 = 1;
		HashTable* arr_hash1_5;
		if(arguments_received > 5)
		{
			arr_hash1_5 = Z_ARRVAL_P(choices1);
			array_count1_5 = zend_hash_num_elements(arr_hash1_5);
		}
		wxString* strings_array1_5 = new wxString[array_count1_5];
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1));

				references->AddReference(parent1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2));

				references->AddReference(parent1);
				references->AddReference(pos1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_5;

				return;
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_5;

				return;
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_5;
				references->AddReference(validator1);

				return;
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				delete[] strings_array1_5;
				references->AddReference(validator1);

				return;
				break;
			}
		}
	}

		
}
void php_wxListCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxListCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxListCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxListCtrl_php();

				((wxListCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1);
				((wxListCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1);
				((wxListCtrl_php*) _this)->references.AddReference(pos1);
				((wxListCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1);
				((wxListCtrl_php*) _this)->references.AddReference(pos1);
				((wxListCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1);
				((wxListCtrl_php*) _this)->references.AddReference(pos1);
				((wxListCtrl_php*) _this)->references.AddReference(size1);
				((wxListCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8));

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1);
				((wxListCtrl_php*) _this)->references.AddReference(pos1);
				((wxListCtrl_php*) _this)->references.AddReference(size1);
				((wxListCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxListCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxListCtrl_php*) _this)->evnArray);
		
		array_init(((wxListCtrl_php*) _this)->evnArray);
		
		((wxListCtrl_php*) _this)->phpObj = getThis();
		
		((wxListCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxListCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxListCtrl, SetWindowStyleFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetWindowStyleFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetWindowStyleFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetWindowStyleFlag((long) style0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetWindowStyleFlag((long) style0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetSingleStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetSingleStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetSingleStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long style0;
	bool add0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&style0, &add0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0, &add0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetSingleStyle((long) style0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetSingleStyle((long) style0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetSingleStyle((long) style0, add0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetSingleStyle((long) style0, add0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemTextColour((long) item0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemTextColour((long) item0, *(wxColour*) object_pointer0_1);

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&item0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemText((long) item0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemText((long) item0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	long state0;
	long stateMask0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&item0, &state0, &stateMask0)\n");
		#endif
		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &state0, &stateMask0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItemState((long) item0, (long) state0, (long) stateMask0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItemState((long) item0, (long) state0, (long) stateMask0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	zval* pos0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &pos0, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &pos0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItemPosition((long) item0, *(wxPoint*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItemPosition((long) item0, *(wxPoint*) object_pointer0_1));

				references->AddReference(pos0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	zval* font0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemFont((long) item0, *(wxFont*) object_pointer0_1)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemFont((long) item0, *(wxFont*) object_pointer0_1);

				references->AddReference(font0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	long data0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&item0, &data0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &data0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItemData((long) item0, (long) data0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItemData((long) item0, (long) data0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long count0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&count0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &count0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemCount((long) count0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemCount((long) count0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemColumnImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemColumnImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemColumnImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	long column0;
	long image0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&item0, &column0, &image0)\n");
		#endif
		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &column0, &image0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItemColumnImage((long) item0, (long) column0, (int) image0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItemColumnImage((long) item0, (long) column0, (int) image0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItemBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemBackgroundColour((long) item0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemBackgroundColour((long) item0, *(wxColour*) object_pointer0_1);

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long index0;
	long column0;
	char* label0;
	long label_len0;
	long imageId0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* info1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls|l' (&index0, &column0, &label0, &label_len0, &imageId0)\n");
		#endif
		char parse_parameters_string[] = "lls|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0, &column0, &label0, &label_len0, &imageId0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&info1, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info1, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(info1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(info1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(info1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::SetItem((long) index0, (int) column0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->SetItem((long) index0, (int) column0, wxString(label0, wxConvUTF8)));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::SetItem((long) index0, (int) column0, wxString(label0, wxConvUTF8), (int) imageId0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->SetItem((long) index0, (int) column0, wxString(label0, wxConvUTF8), (int) imageId0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItem(*(wxListItem*) object_pointer1_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItem(*(wxListItem*) object_pointer1_0));

				references->AddReference(info1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&imageList0, &which0)\n");
		#endif
		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0, &which0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetImageList((wxImageList*) object_pointer0_0, (int) which0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetImageList((wxImageList*) object_pointer0_0, (int) which0);

				references->AddReference(imageList0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetColumnWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetColumnWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetColumnWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&col0, &width0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetColumnWidth((int) col0, (int) width0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetColumnWidth((int) col0, (int) width0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	zval* item0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&col0, &item0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &item0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetColumn((int) col0, *(wxListItem*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetColumn((int) col0, *(wxListItem*) object_pointer0_1));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, SetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetBackgroundColour(*(wxColour*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetBackgroundColour(*(wxColour*) object_pointer0_0));

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, ScrollList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::ScrollList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::ScrollList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long dx0;
	long dy0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&dx0, &dy0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dx0, &dy0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::ScrollList((int) dx0, (int) dy0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->ScrollList((int) dx0, (int) dy0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, RefreshItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::RefreshItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::RefreshItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long itemFrom0;
	long itemTo0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&itemFrom0, &itemTo0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &itemFrom0, &itemTo0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::RefreshItems((long) itemFrom0, (long) itemTo0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->RefreshItems((long) itemFrom0, (long) itemTo0);


				return;
				break;
			}
		}
	}

		
}
wxString wxListCtrl_php::OnGetItemText(long item, long column)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxListCtrl::OnGetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemText", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], item);
	ZVAL_LONG(arguments[1], column);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxListCtrl::OnGetItemText(item, column);

}
PHP_METHOD(php_wxListCtrl, RefreshItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::RefreshItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::RefreshItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::RefreshItem((long) item0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->RefreshItem((long) item0);


				return;
				break;
			}
		}
	}

		
}
int wxListCtrl_php::OnGetItemImage(long item)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxListCtrl::OnGetItemImage\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemImage", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], item);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxListCtrl::OnGetItemImage(item);

}
int wxListCtrl_php::OnGetItemColumnImage(long item, long column)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxListCtrl::OnGetItemColumnImage\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemColumnImage", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], item);
	ZVAL_LONG(arguments[1], column);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxListCtrl::OnGetItemColumnImage(item, column);

}
wxListItemAttr* wxListCtrl_php::OnGetItemAttr(long item)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxListCtrl::OnGetItemAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemAttr", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], item);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return (wxListItemAttr*) return_object;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxListCtrl::OnGetItemAttr(item);

}
PHP_METHOD(php_wxListCtrl, InsertItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::InsertItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::InsertItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* info0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	long index1;
	char* label1;
	long label_len1;
	bool overload1_called = false;
	//Parameters for overload 2
	long index2;
	long imageIndex2;
	bool overload2_called = false;
	//Parameters for overload 3
	long index3;
	char* label3;
	long label_len3;
	long imageIndex3;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&info0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(info0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(info0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(info0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&index1, &label1, &label_len1)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index1, &label1, &label_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&index2, &imageIndex2)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index2, &imageIndex2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lsl' (&index3, &label3, &label_len3, &imageIndex3)\n");
		#endif
		char parse_parameters_string[] = "lsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index3, &label3, &label_len3, &imageIndex3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertItem(*(wxListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertItem(*(wxListItem*) object_pointer0_0));

				references->AddReference(info0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertItem((long) index1, wxString(label1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertItem((long) index1, wxString(label1, wxConvUTF8)));


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertItem((long) index2, (int) imageIndex2))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertItem((long) index2, (int) imageIndex2));


				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertItem((long) index3, wxString(label3, wxConvUTF8), (int) imageIndex3))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertItem((long) index3, wxString(label3, wxConvUTF8), (int) imageIndex3));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetViewRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetViewRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetViewRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetViewRect() to return new object\n\n");
				#endif
				wxRect value_to_return0;
				value_to_return0 = ((wxListCtrl_php*)_this)->GetViewRect();
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetTopItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetTopItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetTopItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetTopItem())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetTopItem());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetTextColour() to return new object\n\n");
				#endif
				wxColour value_to_return0;
				value_to_return0 = ((wxListCtrl_php*)_this)->GetTextColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetSubItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetSubItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetSubItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	long subItem0;
	zval* rect0 = 0;
	void* object_pointer0_2 = 0;
	long code0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llO|l' (&item0, &subItem0, &rect0, php_wxRect_entry, &code0)\n");
		#endif
		char parse_parameters_string[] = "llO|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &subItem0, &rect0, php_wxRect_entry, &code0 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetSubItemRect((long) item0, (long) subItem0, *(wxRect*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetSubItemRect((long) item0, (long) subItem0, *(wxRect*) object_pointer0_2));

				references->AddReference(rect0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetSubItemRect((long) item0, (long) subItem0, *(wxRect*) object_pointer0_2, (int) code0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetSubItemRect((long) item0, (long) subItem0, *(wxRect*) object_pointer0_2, (int) code0));

				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetSelectedItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetSelectedItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetSelectedItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetSelectedItemCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetSelectedItemCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, Arrange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::Arrange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::Arrange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Arrange())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Arrange());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Arrange((int) flag0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Arrange((int) flag0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, AssignImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::AssignImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::AssignImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&imageList0, &which0)\n");
		#endif
		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0, &which0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::AssignImageList((wxImageList*) object_pointer0_0, (int) which0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->AssignImageList((wxImageList*) object_pointer0_0, (int) which0);

				references->AddReference(imageList0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, ClearAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::ClearAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::ClearAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::ClearAll()\n\n");
				#endif
				((wxListCtrl_php*)_this)->ClearAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::DeleteAllItems())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->DeleteAllItems());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, DeleteColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::DeleteColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::DeleteColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::DeleteColumn((int) col0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->DeleteColumn((int) col0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, DeleteItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::DeleteItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::DeleteItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::DeleteItem((long) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->DeleteItem((long) item0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, EditLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::EditLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::EditLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	zval* textControlClass0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|z' (&item0, &textControlClass0)\n");
		#endif
		char parse_parameters_string[] = "l|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &textControlClass0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(textControlClass0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(textControlClass0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(textControlClass0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::EditLabel((long) item0) to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return1;
				value_to_return1 = (wxTextCtrl_php*) ((wxListCtrl_php*)_this)->EditLabel((long) item0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::EditLabel((long) item0, (wxClassInfo*) object_pointer0_1) to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return2;
				value_to_return2 = (wxTextCtrl_php*) ((wxListCtrl_php*)_this)->EditLabel((long) item0, (wxClassInfo*) object_pointer0_1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(textControlClass0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, EnsureVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::EnsureVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::EnsureVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::EnsureVisible((long) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->EnsureVisible((long) item0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, FindItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::FindItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::FindItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long start0;
	char* str0;
	long str_len0;
	bool partial0;
	bool overload0_called = false;
	//Parameters for overload 1
	long start1;
	long data1;
	bool overload1_called = false;
	//Parameters for overload 2
	long start2;
	zval* pt2 = 0;
	void* object_pointer2_1 = 0;
	long direction2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls|b' (&start0, &str0, &str_len0, &partial0)\n");
		#endif
		char parse_parameters_string[] = "ls|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &start0, &str0, &str_len0, &partial0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&start1, &data1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &start1, &data1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lOl' (&start2, &pt2, php_wxPoint_entry, &direction2)\n");
		#endif
		char parse_parameters_string[] = "lOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &start2, &pt2, php_wxPoint_entry, &direction2 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(pt2) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt2), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer2_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer2_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt2) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::FindItem((long) start0, wxString(str0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->FindItem((long) start0, wxString(str0, wxConvUTF8)));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::FindItem((long) start0, wxString(str0, wxConvUTF8), partial0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->FindItem((long) start0, wxString(str0, wxConvUTF8), partial0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::FindItem((long) start1, (wxUIntPtr) data1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->FindItem((long) start1, (wxUIntPtr) data1));


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::FindItem((long) start2, *(wxPoint*) object_pointer2_1, (int) direction2))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->FindItem((long) start2, *(wxPoint*) object_pointer2_1, (int) direction2));

				references->AddReference(pt2);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	zval* item0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&col0, &item0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &item0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetColumn((int) col0, *(wxListItem*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetColumn((int) col0, *(wxListItem*) object_pointer0_1));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetColumnWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetColumnWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetColumnWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetColumnWidth((int) col0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetColumnWidth((int) col0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetCountPerPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetCountPerPage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetCountPerPage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetCountPerPage())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetCountPerPage());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetEditControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetEditControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetEditControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetEditControl() to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return0;
				value_to_return0 = (wxTextCtrl_php*) ((wxListCtrl_php*)_this)->GetEditControl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&which0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &which0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetImageList((int) which0) to return object pointer\n\n");
				#endif
				wxImageList_php* value_to_return1;
				value_to_return1 = (wxImageList_php*) ((wxListCtrl_php*)_this)->GetImageList((int) which0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImageList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxImageList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* info0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&info0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(info0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(info0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(info0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetItem(*(wxListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetItem(*(wxListItem*) object_pointer0_0));

				references->AddReference(info0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetItemBackgroundColour((long) item0) to return new object\n\n");
				#endif
				wxColour value_to_return1;
				value_to_return1 = ((wxListCtrl_php*)_this)->GetItemBackgroundColour((long) item0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetItemCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetItemCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetItemFont((long) item0) to return new object\n\n");
				#endif
				wxFont value_to_return1;
				value_to_return1 = ((wxListCtrl_php*)_this)->GetItemFont((long) item0);
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxFont));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	zval* pos0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &pos0, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &pos0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetItemPosition((long) item0, *(wxPoint*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetItemPosition((long) item0, *(wxPoint*) object_pointer0_1));

				references->AddReference(pos0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	zval* rect0 = 0;
	void* object_pointer0_1 = 0;
	long code0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO|l' (&item0, &rect0, php_wxRect_entry, &code0)\n");
		#endif
		char parse_parameters_string[] = "lO|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &rect0, php_wxRect_entry, &code0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetItemRect((long) item0, *(wxRect*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetItemRect((long) item0, *(wxRect*) object_pointer0_1));

				references->AddReference(rect0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetItemRect((long) item0, *(wxRect*) object_pointer0_1, (int) code0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetItemRect((long) item0, *(wxRect*) object_pointer0_1, (int) code0));

				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemSpacing)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemSpacing\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemSpacing\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetItemSpacing() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = ((wxListCtrl_php*)_this)->GetItemSpacing();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	long stateMask0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&item0, &stateMask0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &stateMask0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetItemState((long) item0, (long) stateMask0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetItemState((long) item0, (long) stateMask0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&item0, &col0)\n");
		#endif
		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxListCtrl::GetItemText((long) item0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxListCtrl_php*)_this)->GetItemText((long) item0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxListCtrl::GetItemText((long) item0, (int) col0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				value_to_return2 = ((wxListCtrl_php*)_this)->GetItemText((long) item0, (int) col0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetItemTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetItemTextColour((long) item0) to return new object\n\n");
				#endif
				wxColour value_to_return1;
				value_to_return1 = ((wxListCtrl_php*)_this)->GetItemTextColour((long) item0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, GetNextItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetNextItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetNextItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	long geometry0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|ll' (&item0, &geometry0, &state0)\n");
		#endif
		char parse_parameters_string[] = "l|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &geometry0, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetNextItem((long) item0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetNextItem((long) item0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetNextItem((long) item0, (int) geometry0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetNextItem((long) item0, (int) geometry0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetNextItem((long) item0, (int) geometry0, (int) state0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetNextItem((long) item0, (int) geometry0, (int) state0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListCtrl, InsertColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::InsertColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::InsertColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	zval* info0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	long col1;
	char* heading1;
	long heading_len1;
	long format1;
	long width1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&col0, &info0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &info0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(info0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(info0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(info0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls|ll' (&col1, &heading1, &heading_len1, &format1, &width1)\n");
		#endif
		char parse_parameters_string[] = "ls|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col1, &heading1, &heading_len1, &format1, &width1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertColumn((long) col0, *(wxListItem*) object_pointer0_1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertColumn((long) col0, *(wxListItem*) object_pointer0_1));

				references->AddReference(info0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertColumn((long) col1, wxString(heading1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertColumn((long) col1, wxString(heading1, wxConvUTF8)));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertColumn((long) col1, wxString(heading1, wxConvUTF8), (int) format1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertColumn((long) col1, wxString(heading1, wxConvUTF8), (int) format1));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertColumn((long) col1, wxString(heading1, wxConvUTF8), (int) format1, (int) width1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertColumn((long) col1, wxString(heading1, wxConvUTF8), (int) format1, (int) width1));


				return;
				break;
			}
		}
	}

		
}
void php_wxListView_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxListView_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxListView, ClearColumnImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::ClearColumnImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::ClearColumnImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::ClearColumnImage((int) col0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->ClearColumnImage((int) col0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListView, Focus)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::Focus\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::Focus\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&index0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::Focus((long) index0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->Focus((long) index0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListView, GetFirstSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::GetFirstSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::GetFirstSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListView::GetFirstSelected())\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					ZVAL_LONG(return_value, ((wxListView_php*)_this)->GetFirstSelected());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListView, GetFocusedItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::GetFocusedItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::GetFocusedItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListView::GetFocusedItem())\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					ZVAL_LONG(return_value, ((wxListView_php*)_this)->GetFocusedItem());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListView, GetNextSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::GetNextSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::GetNextSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListView::GetNextSelected((long) item0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					ZVAL_LONG(return_value, ((wxListView_php*)_this)->GetNextSelected((long) item0));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListView, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&index0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListView::IsSelected((long) index0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					ZVAL_BOOL(return_value, ((wxListView_php*)_this)->IsSelected((long) index0));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListView, Select)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::Select\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::Select\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool on0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&n0, &on0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &on0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::Select((long) n0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->Select((long) n0);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::Select((long) n0, on0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->Select((long) n0, on0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxListView, SetColumnImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::SetColumnImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::SetColumnImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long col0;
	long image0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&col0, &image0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &image0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::SetColumnImage((int) col0, (int) image0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->SetColumnImage((int) col0, (int) image0);
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxRadioBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxRadioBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxRadioBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long n0;
	zval* choices0;
	long majorDimension0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_9 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	zval* choices1 = 0;
	long majorDimension1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_8 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 11)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlallOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &majorDimension0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlallOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &majorDimension0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 10){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_9 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_9 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 6  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|llOs' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &majorDimension1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|llOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &majorDimension1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_6 = 1;
		HashTable* arr_hash0_6;
		if(arguments_received > 6)
		{
			arr_hash0_6 = Z_ARRVAL_P(choices0);
			array_count0_6 = zend_hash_num_elements(arr_hash0_6);
		}
		wxString* strings_array0_6 = new wxString[array_count0_6];
		bool strings_continue0_6 = true;

		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;

				return;
				break;
			}
			case 8:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;

				return;
				break;
			}
			case 9:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;

				return;
				break;
			}
			case 10:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0, *(wxValidator*) object_pointer0_9))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0, *(wxValidator*) object_pointer0_9));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;
				references->AddReference(validator0);

				return;
				break;
			}
			case 11:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0, *(wxValidator*) object_pointer0_9, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0, *(wxValidator*) object_pointer0_9, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				delete[] strings_array0_6;
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_5;
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);

				return;
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				references->AddReference(validator1);

				return;
				break;
			}
			case 10:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1);
				references->AddReference(pos1);
				references->AddReference(size1);
				references->AddReference(validator1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, Enable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::Enable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::Enable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&n0, &enable0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Enable((unsigned int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Enable((unsigned int) n0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Enable((unsigned int) n0, enable0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Enable((unsigned int) n0, enable0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool bCase0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &bCase0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &bCase0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->FindString(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::FindString(wxString(string0, wxConvUTF8), bCase0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->FindString(wxString(string0, wxConvUTF8), bCase0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, GetItemFromPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetItemFromPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetItemFromPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* pt0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetItemFromPoint(*(wxPoint*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetItemFromPoint(*(wxPoint*) object_pointer0_0));

				references->AddReference(pt0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, GetItemHelpText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetItemHelpText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetItemHelpText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxRadioBox::GetItemHelpText((unsigned int) item0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxRadioBox_php*)_this)->GetItemHelpText((unsigned int) item0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, GetItemToolTip)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetItemToolTip\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetItemToolTip\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::GetItemToolTip((unsigned int) item0) to return object pointer\n\n");
				#endif
				wxToolTip_php* value_to_return1;
				value_to_return1 = (wxToolTip_php*) ((wxRadioBox_php*)_this)->GetItemToolTip((unsigned int) item0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxToolTip_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxToolTip));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, GetRowCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetRowCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetRowCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetRowCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetRowCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxRadioBox::GetString((unsigned int) n0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxRadioBox_php*)_this)->GetString((unsigned int) n0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, IsItemEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::IsItemEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::IsItemEnabled\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::IsItemEnabled((unsigned int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->IsItemEnabled((unsigned int) n0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, IsItemShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::IsItemShown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::IsItemShown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::IsItemShown((unsigned int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->IsItemShown((unsigned int) n0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, SetItemHelpText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::SetItemHelpText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::SetItemHelpText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	char* helptext0;
	long helptext_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&item0, &helptext0, &helptext_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &helptext0, &helptext_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::SetItemHelpText((unsigned int) item0, wxString(helptext0, wxConvUTF8))\n\n");
				#endif
				((wxRadioBox_php*)_this)->SetItemHelpText((unsigned int) item0, wxString(helptext0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, SetItemToolTip)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::SetItemToolTip\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::SetItemToolTip\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&item0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::SetItemToolTip((unsigned int) item0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxRadioBox_php*)_this)->SetItemToolTip((unsigned int) item0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::SetSelection((int) n0)\n\n");
				#endif
				((wxRadioBox_php*)_this)->SetSelection((int) n0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, SetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::SetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&n0, &string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::SetString((unsigned int) n0, wxString(string0, wxConvUTF8))\n\n");
				#endif
				((wxRadioBox_php*)_this)->SetString((unsigned int) n0, wxString(string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, Show)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::Show\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::Show\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&item0, &show0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Show((unsigned int) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Show((unsigned int) item0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Show((unsigned int) item0, show0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Show((unsigned int) item0, show0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	zval* choices1 = 0;
	long majorDimension1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_8 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 6  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|llOs' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &majorDimension1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|llOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &majorDimension1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxRadioBox_php();

				((wxRadioBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_5;
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5)\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5);

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1);
				((wxRadioBox_php*) _this)->references.AddReference(pos1);
				((wxRadioBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1)\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1);

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1);
				((wxRadioBox_php*) _this)->references.AddReference(pos1);
				((wxRadioBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1)\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1);

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1);
				((wxRadioBox_php*) _this)->references.AddReference(pos1);
				((wxRadioBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8)\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8);

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1);
				((wxRadioBox_php*) _this)->references.AddReference(pos1);
				((wxRadioBox_php*) _this)->references.AddReference(size1);
				((wxRadioBox_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 10:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8));

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1);
				((wxRadioBox_php*) _this)->references.AddReference(pos1);
				((wxRadioBox_php*) _this)->references.AddReference(size1);
				((wxRadioBox_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxRadioBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxRadioBox_php*) _this)->evnArray);
		
		array_init(((wxRadioBox_php*) _this)->evnArray);
		
		((wxRadioBox_php*) _this)->phpObj = getThis();
		
		((wxRadioBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxRadioBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxRadioButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxRadioButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxRadioButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioButton){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioButton, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioButton::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioButton::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioButton){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::GetValue())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioButton, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioButton::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioButton::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioButton){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&value0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioButton::SetValue(value0)\n\n");
				#endif
				((wxRadioButton_php*)_this)->SetValue(value0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRadioButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxRadioButton_php();

				((wxRadioButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1);
				((wxRadioButton_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1);
				((wxRadioButton_php*) _this)->references.AddReference(pos1);
				((wxRadioButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1);
				((wxRadioButton_php*) _this)->references.AddReference(pos1);
				((wxRadioButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1);
				((wxRadioButton_php*) _this)->references.AddReference(pos1);
				((wxRadioButton_php*) _this)->references.AddReference(size1);
				((wxRadioButton_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1);
				((wxRadioButton_php*) _this)->references.AddReference(pos1);
				((wxRadioButton_php*) _this)->references.AddReference(size1);
				((wxRadioButton_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxRadioButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxRadioButton_php*) _this)->evnArray);
		
		array_init(((wxRadioButton_php*) _this)->evnArray);
		
		((wxRadioButton_php*) _this)->phpObj = getThis();
		
		((wxRadioButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxRadioButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxRearrangeList_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxRearrangeList_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxRearrangeList, CanMoveCurrentDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::CanMoveCurrentDown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeList::CanMoveCurrentDown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeList){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRearrangeList::CanMoveCurrentDown())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRearrangeList_php*)_this)->CanMoveCurrentDown());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRearrangeList, CanMoveCurrentUp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::CanMoveCurrentUp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeList::CanMoveCurrentUp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeList){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRearrangeList::CanMoveCurrentUp())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRearrangeList_php*)_this)->CanMoveCurrentUp());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRearrangeList, MoveCurrentDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::MoveCurrentDown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeList::MoveCurrentDown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeList){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRearrangeList::MoveCurrentDown())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRearrangeList_php*)_this)->MoveCurrentDown());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRearrangeList, MoveCurrentUp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::MoveCurrentUp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeList::MoveCurrentUp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeList){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRearrangeList::MoveCurrentUp())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRearrangeList_php*)_this)->MoveCurrentUp());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxRearrangeList, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxRearrangeList_php();

				((wxRearrangeList_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxRearrangeList);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxRearrangeList_php*) _this)->evnArray);
		
		array_init(((wxRearrangeList_php*) _this)->evnArray);
		
		((wxRearrangeList_php*) _this)->phpObj = getThis();
		
		((wxRearrangeList_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxRearrangeList_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxRearrangeCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRearrangeCtrl_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxRearrangeCtrl_php* object = static_cast<wxRearrangeCtrl_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRearrangeCtrl done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxRearrangeCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxRearrangeCtrl_php();

				((wxRearrangeCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxRearrangeCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxRearrangeCtrl_php*) _this)->evnArray);
		
		array_init(((wxRearrangeCtrl_php*) _this)->evnArray);
		
		((wxRearrangeCtrl_php*) _this)->phpObj = getThis();
		
		((wxRearrangeCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxRearrangeCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxRearrangeCtrl, GetList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeCtrl::GetList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeCtrl::GetList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeCtrl){
				references = &((wxRearrangeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRearrangeCtrl::GetList() to return object pointer\n\n");
				#endif
				wxRearrangeList_php* value_to_return0;
				value_to_return0 = (wxRearrangeList_php*) ((wxRearrangeCtrl_php*)_this)->GetList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRearrangeList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxRearrangeList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxScrollBar_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxScrollBar_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxScrollBar, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0);
				((wxScrollBar_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0);
				((wxScrollBar_php*) _this)->references.AddReference(pos0);
				((wxScrollBar_php*) _this)->references.AddReference(size0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0);
				((wxScrollBar_php*) _this)->references.AddReference(pos0);
				((wxScrollBar_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0);
				((wxScrollBar_php*) _this)->references.AddReference(pos0);
				((wxScrollBar_php*) _this)->references.AddReference(size0);
				((wxScrollBar_php*) _this)->references.AddReference(validator0);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8));

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0);
				((wxScrollBar_php*) _this)->references.AddReference(pos0);
				((wxScrollBar_php*) _this)->references.AddReference(size0);
				((wxScrollBar_php*) _this)->references.AddReference(validator0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxScrollBar_php();

				((wxScrollBar_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxScrollBar);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxScrollBar_php*) _this)->evnArray);
		
		array_init(((wxScrollBar_php*) _this)->evnArray);
		
		((wxScrollBar_php*) _this)->phpObj = getThis();
		
		((wxScrollBar_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxScrollBar_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxScrollBar, SetThumbPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::SetThumbPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::SetThumbPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long viewStart0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&viewStart0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &viewStart0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxScrollBar::SetThumbPosition((int) viewStart0)\n\n");
				#endif
				((wxScrollBar_php*)_this)->SetThumbPosition((int) viewStart0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxScrollBar, SetScrollbar)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::SetScrollbar\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::SetScrollbar\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long position0;
	long thumbSize0;
	long range0;
	long pageSize0;
	bool refresh0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll|b' (&position0, &thumbSize0, &range0, &pageSize0, &refresh0)\n");
		#endif
		char parse_parameters_string[] = "llll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &position0, &thumbSize0, &range0, &pageSize0, &refresh0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxScrollBar::SetScrollbar((int) position0, (int) thumbSize0, (int) range0, (int) pageSize0)\n\n");
				#endif
				((wxScrollBar_php*)_this)->SetScrollbar((int) position0, (int) thumbSize0, (int) range0, (int) pageSize0);


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxScrollBar::SetScrollbar((int) position0, (int) thumbSize0, (int) range0, (int) pageSize0, refresh0)\n\n");
				#endif
				((wxScrollBar_php*)_this)->SetScrollbar((int) position0, (int) thumbSize0, (int) range0, (int) pageSize0, refresh0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxScrollBar, GetThumbSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::GetThumbSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::GetThumbSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxScrollBar::GetThumbSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxScrollBar_php*)_this)->GetThumbSize());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxScrollBar, GetThumbPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::GetThumbPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::GetThumbPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxScrollBar::GetThumbPosition())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxScrollBar_php*)_this)->GetThumbPosition());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxScrollBar, GetPageSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::GetPageSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::GetPageSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxScrollBar::GetPageSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxScrollBar_php*)_this)->GetPageSize());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxScrollBar, GetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::GetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::GetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxScrollBar::GetRange())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxScrollBar_php*)_this)->GetRange());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxScrollBar, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
void php_wxSlider_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSlider_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxSlider, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	long value1;
	long minValue1;
	long maxValue1;
	zval* pos1 = 0;
	void* object_pointer1_5 = 0;
	zval* size1 = 0;
	void* object_pointer1_6 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_8 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zllll|OOlOs' (&parent1, &id1, &value1, &minValue1, &maxValue1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zllll|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &minValue1, &maxValue1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSlider_php();

				((wxSlider_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1);
				((wxSlider_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1);
				((wxSlider_php*) _this)->references.AddReference(pos1);
				((wxSlider_php*) _this)->references.AddReference(size1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1);
				((wxSlider_php*) _this)->references.AddReference(pos1);
				((wxSlider_php*) _this)->references.AddReference(size1);
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1, *(wxValidator*) object_pointer1_8)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1, *(wxValidator*) object_pointer1_8);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1);
				((wxSlider_php*) _this)->references.AddReference(pos1);
				((wxSlider_php*) _this)->references.AddReference(size1);
				((wxSlider_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8));

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1);
				((wxSlider_php*) _this)->references.AddReference(pos1);
				((wxSlider_php*) _this)->references.AddReference(size1);
				((wxSlider_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSlider);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxSlider_php*) _this)->evnArray);
		
		array_init(((wxSlider_php*) _this)->evnArray);
		
		((wxSlider_php*) _this)->phpObj = getThis();
		
		((wxSlider_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSlider_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxSlider, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&value0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSlider::SetValue((int) value0)\n\n");
				#endif
				((wxSlider_php*)_this)->SetValue((int) value0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long minValue0;
	long maxValue0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&minValue0, &maxValue0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minValue0, &maxValue0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSlider::SetRange((int) minValue0, (int) maxValue0)\n\n");
				#endif
				((wxSlider_php*)_this)->SetRange((int) minValue0, (int) maxValue0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, SetPageSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::SetPageSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::SetPageSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pageSize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pageSize0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pageSize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSlider::SetPageSize((int) pageSize0)\n\n");
				#endif
				((wxSlider_php*)_this)->SetPageSize((int) pageSize0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, SetLineSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::SetLineSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::SetLineSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long lineSize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&lineSize0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lineSize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSlider::SetLineSize((int) lineSize0)\n\n");
				#endif
				((wxSlider_php*)_this)->SetLineSize((int) lineSize0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	long value0;
	long minValue0;
	long maxValue0;
	zval* point0 = 0;
	void* object_pointer0_5 = 0;
	zval* size0 = 0;
	void* object_pointer0_6 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_8 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zllll|OOlOs' (&parent0, &id0, &value0, &minValue0, &maxValue0, &point0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zllll|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &minValue0, &maxValue0, &point0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(point0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(point0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(point0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(point0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(point0);
				references->AddReference(size0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0));

				references->AddReference(parent0);
				references->AddReference(point0);
				references->AddReference(size0);

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0, *(wxValidator*) object_pointer0_8))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0, *(wxValidator*) object_pointer0_8));

				references->AddReference(parent0);
				references->AddReference(point0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0, *(wxValidator*) object_pointer0_8, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0, *(wxValidator*) object_pointer0_8, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(point0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, GetLineSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetLineSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetLineSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetLineSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetLineSize());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, GetMax)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetMax\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetMax\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetMax())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetMax());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, GetMin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetMin\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetMin\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetMin())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetMin());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSlider, GetPageSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetPageSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetPageSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetPageSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetPageSize());


				return;
				break;
			}
		}
	}

		
}
void php_wxSpinButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSpinButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxSpinButton, GetMin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::GetMin\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::GetMin\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinButton::GetMin())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinButton_php*)_this)->GetMin());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinButton, GetMax)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::GetMax\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::GetMax\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinButton::GetMax())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinButton_php*)_this)->GetMax());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinButton, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinButton::GetValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinButton_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinButton, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long min0;
	long max0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&min0, &max0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &min0, &max0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinButton::SetRange((int) min0, (int) max0)\n\n");
				#endif
				((wxSpinButton_php*)_this)->SetRange((int) min0, (int) max0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinButton, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&value0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinButton::SetValue((int) value0)\n\n");
				#endif
				((wxSpinButton_php*)_this)->SetValue((int) value0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSpinButton_php();

				((wxSpinButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1);
				((wxSpinButton_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1);
				((wxSpinButton_php*) _this)->references.AddReference(pos1);
				((wxSpinButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1);
				((wxSpinButton_php*) _this)->references.AddReference(pos1);
				((wxSpinButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1);
				((wxSpinButton_php*) _this)->references.AddReference(pos1);
				((wxSpinButton_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSpinButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxSpinButton_php*) _this)->evnArray);
		
		array_init(((wxSpinButton_php*) _this)->evnArray);
		
		((wxSpinButton_php*) _this)->phpObj = getThis();
		
		((wxSpinButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSpinButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxSpinCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSpinCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxSpinCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	long min0;
	long max0;
	long initial0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlllls' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &min0, &max0, &initial0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlllls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &min0, &max0, &initial0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0, (int) initial0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0, (int) initial0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0, (int) initial0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0, (int) initial0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrl, GetMax)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::GetMax\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::GetMax\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrl::GetMax())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinCtrl_php*)_this)->GetMax());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrl, GetMin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::GetMin\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::GetMin\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrl::GetMin())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinCtrl_php*)_this)->GetMin());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrl, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrl::GetValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinCtrl_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrl, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long minVal0;
	long maxVal0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&minVal0, &maxVal0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minVal0, &maxVal0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrl::SetRange((int) minVal0, (int) maxVal0)\n\n");
				#endif
				((wxSpinCtrl_php*)_this)->SetRange((int) minVal0, (int) maxVal0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrl, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrl::SetSelection((long) from0, (long) to0)\n\n");
				#endif
				((wxSpinCtrl_php*)_this)->SetSelection((long) from0, (long) to0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrl, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&value0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrl::SetValue((int) value0)\n\n");
				#endif
				((wxSpinCtrl_php*)_this)->SetValue((int) value0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	long min1;
	long max1;
	long initial1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlllls' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &min1, &max1, &initial1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlllls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &min1, &max1, &initial1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSpinCtrl_php();

				((wxSpinCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1, (int) initial1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1, (int) initial1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1, (int) initial1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1, (int) initial1, wxString(name1, wxConvUTF8));

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSpinCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxSpinCtrl_php*) _this)->evnArray);
		
		array_init(((wxSpinCtrl_php*) _this)->evnArray);
		
		((wxSpinCtrl_php*) _this)->phpObj = getThis();
		
		((wxSpinCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSpinCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxSpinCtrlDouble_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSpinCtrlDouble_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxSpinCtrlDouble, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	double min0;
	double max0;
	double initial0;
	double inc0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 11)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOldddds' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &min0, &max0, &initial0, &inc0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOldddds";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &min0, &max0, &initial0, &inc0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0, inc0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0, inc0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 11:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0, inc0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0, inc0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, GetDigits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetDigits\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetDigits\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetDigits())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinCtrlDouble_php*)_this)->GetDigits());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, GetIncrement)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetIncrement\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetIncrement\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetIncrement())\n\n");
				#endif
				ZVAL_DOUBLE(return_value, ((wxSpinCtrlDouble_php*)_this)->GetIncrement());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, GetMax)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetMax\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetMax\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetMax())\n\n");
				#endif
				ZVAL_DOUBLE(return_value, ((wxSpinCtrlDouble_php*)_this)->GetMax());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, GetMin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetMin\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetMin\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetMin())\n\n");
				#endif
				ZVAL_DOUBLE(return_value, ((wxSpinCtrlDouble_php*)_this)->GetMin());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetValue())\n\n");
				#endif
				ZVAL_DOUBLE(return_value, ((wxSpinCtrlDouble_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, SetDigits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::SetDigits\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::SetDigits\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long digits0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&digits0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &digits0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrlDouble::SetDigits((unsigned int) digits0)\n\n");
				#endif
				((wxSpinCtrlDouble_php*)_this)->SetDigits((unsigned int) digits0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, SetIncrement)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::SetIncrement\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::SetIncrement\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	double inc0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&inc0)\n");
		#endif
		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &inc0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrlDouble::SetIncrement(inc0)\n\n");
				#endif
				((wxSpinCtrlDouble_php*)_this)->SetIncrement(inc0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	double minVal0;
	double maxVal0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (&minVal0, &maxVal0)\n");
		#endif
		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minVal0, &maxVal0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrlDouble::SetRange(minVal0, maxVal0)\n\n");
				#endif
				((wxSpinCtrlDouble_php*)_this)->SetRange(minVal0, maxVal0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	double value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&value0)\n");
		#endif
		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrlDouble::SetValue(value0)\n\n");
				#endif
				((wxSpinCtrlDouble_php*)_this)->SetValue(value0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSpinCtrlDouble, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	double min1;
	double max1;
	double initial1;
	double inc1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 11)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOldddds' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &min1, &max1, &initial1, &inc1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOldddds";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &min1, &max1, &initial1, &inc1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSpinCtrlDouble_php();

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1);
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1);
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1, inc1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1, inc1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1);
				break;
			}
			case 11:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1, inc1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1, inc1, wxString(name1, wxConvUTF8));

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1);
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSpinCtrlDouble);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxSpinCtrlDouble_php*) _this)->evnArray);
		
		array_init(((wxSpinCtrlDouble_php*) _this)->evnArray);
		
		((wxSpinCtrlDouble_php*) _this)->phpObj = getThis();
		
		((wxSpinCtrlDouble_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSpinCtrlDouble_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxSearchCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSearchCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxSearchCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, GetDescriptiveText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::GetDescriptiveText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::GetDescriptiveText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxSearchCtrl::GetDescriptiveText().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxSearchCtrl_php*)_this)->GetDescriptiveText();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, GetMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::GetMenu\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::GetMenu\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::GetMenu() to return object pointer\n\n");
				#endif
				wxMenu_php* value_to_return0;
				value_to_return0 = (wxMenu_php*) ((wxSearchCtrl_php*)_this)->GetMenu();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxMenu_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxMenu));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, IsCancelButtonVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::IsCancelButtonVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::IsCancelButtonVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::IsCancelButtonVisible())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->IsCancelButtonVisible());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, IsSearchButtonVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::IsSearchButtonVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::IsSearchButtonVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::IsSearchButtonVisible())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->IsSearchButtonVisible());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, SetDescriptiveText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::SetDescriptiveText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::SetDescriptiveText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::SetDescriptiveText(wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxSearchCtrl_php*)_this)->SetDescriptiveText(wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, SetMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::SetMenu\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::SetMenu\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* menu0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&menu0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &menu0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(menu0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(menu0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(menu0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::SetMenu((wxMenu*) object_pointer0_0)\n\n");
				#endif
				((wxSearchCtrl_php*)_this)->SetMenu((wxMenu*) object_pointer0_0);

				references->AddReference(menu0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, ShowCancelButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::ShowCancelButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::ShowCancelButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::ShowCancelButton(show0)\n\n");
				#endif
				((wxSearchCtrl_php*)_this)->ShowCancelButton(show0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, ShowSearchButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::ShowSearchButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::ShowSearchButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::ShowSearchButton(show0)\n\n");
				#endif
				((wxSearchCtrl_php*)_this)->ShowSearchButton(show0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxSearchCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSearchCtrl_php();

				((wxSearchCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1);
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1);
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1);
				((wxSearchCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1);
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1);
				((wxSearchCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1);
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1);
				((wxSearchCtrl_php*) _this)->references.AddReference(size1);
				((wxSearchCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1);
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1);
				((wxSearchCtrl_php*) _this)->references.AddReference(size1);
				((wxSearchCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSearchCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxSearchCtrl_php*) _this)->evnArray);
		
		array_init(((wxSearchCtrl_php*) _this)->evnArray);
		
		((wxSearchCtrl_php*) _this)->phpObj = getThis();
		
		((wxSearchCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSearchCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxStaticBitmap_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxStaticBitmap_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxStaticBitmap, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* label0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOls' (&parent0, &id0, &label0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(label0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(label0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticBitmap, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::GetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticBitmap::GetBitmap() to return new object\n\n");
				#endif
				wxBitmap value_to_return0;
				value_to_return0 = ((wxStaticBitmap_php*)_this)->GetBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticBitmap, GetIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::GetIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::GetIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticBitmap::GetIcon() to return new object\n\n");
				#endif
				wxIcon value_to_return0;
				value_to_return0 = ((wxStaticBitmap_php*)_this)->GetIcon();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxIcon));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticBitmap, SetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::SetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* label0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&label0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticBitmap::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxStaticBitmap_php*)_this)->SetBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(label0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticBitmap, SetIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::SetIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::SetIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* label0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&label0, php_wxIcon_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticBitmap::SetIcon(*(wxIcon*) object_pointer0_0)\n\n");
				#endif
				((wxStaticBitmap_php*)_this)->SetIcon(*(wxIcon*) object_pointer0_0);

				references->AddReference(label0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticBitmap, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* label1 = 0;
	void* object_pointer1_2 = 0;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOls' (&parent1, &id1, &label1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStaticBitmap_php();

				((wxStaticBitmap_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2)\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2);

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1);
				((wxStaticBitmap_php*) _this)->references.AddReference(label1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3);

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1);
				((wxStaticBitmap_php*) _this)->references.AddReference(label1);
				((wxStaticBitmap_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1);
				((wxStaticBitmap_php*) _this)->references.AddReference(label1);
				((wxStaticBitmap_php*) _this)->references.AddReference(pos1);
				((wxStaticBitmap_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1);
				((wxStaticBitmap_php*) _this)->references.AddReference(label1);
				((wxStaticBitmap_php*) _this)->references.AddReference(pos1);
				((wxStaticBitmap_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1);
				((wxStaticBitmap_php*) _this)->references.AddReference(label1);
				((wxStaticBitmap_php*) _this)->references.AddReference(pos1);
				((wxStaticBitmap_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStaticBitmap);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxStaticBitmap_php*) _this)->evnArray);
		
		array_init(((wxStaticBitmap_php*) _this)->evnArray);
		
		((wxStaticBitmap_php*) _this)->phpObj = getThis();
		
		((wxStaticBitmap_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStaticBitmap_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxStaticBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxStaticBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxStaticBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBox){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStaticBox_php();

				((wxStaticBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1);
				((wxStaticBox_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1);
				((wxStaticBox_php*) _this)->references.AddReference(pos1);
				((wxStaticBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1);
				((wxStaticBox_php*) _this)->references.AddReference(pos1);
				((wxStaticBox_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1);
				((wxStaticBox_php*) _this)->references.AddReference(pos1);
				((wxStaticBox_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStaticBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxStaticBox_php*) _this)->evnArray);
		
		array_init(((wxStaticBox_php*) _this)->evnArray);
		
		((wxStaticBox_php*) _this)->phpObj = getThis();
		
		((wxStaticBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStaticBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxStaticLine_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxStaticLine_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxStaticLine, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticLine::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticLine::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticLine){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticLine, GetDefaultSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticLine::GetDefaultSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticLine::GetDefaultSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticLine){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxStaticLine::GetDefaultSize())\n\n");
				#endif
				ZVAL_LONG(return_value, wxStaticLine::GetDefaultSize());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticLine, IsVertical)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticLine::IsVertical\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticLine::IsVertical\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticLine){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::IsVertical())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->IsVertical());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticLine, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticLine::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStaticLine_php();

				((wxStaticLine_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1);
				((wxStaticLine_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1);
				((wxStaticLine_php*) _this)->references.AddReference(pos1);
				((wxStaticLine_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1);
				((wxStaticLine_php*) _this)->references.AddReference(pos1);
				((wxStaticLine_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1);
				((wxStaticLine_php*) _this)->references.AddReference(pos1);
				((wxStaticLine_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStaticLine);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxStaticLine_php*) _this)->evnArray);
		
		array_init(((wxStaticLine_php*) _this)->evnArray);
		
		((wxStaticLine_php*) _this)->phpObj = getThis();
		
		((wxStaticLine_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStaticLine_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxStaticText_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxStaticText_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxStaticText, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticText::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticText::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticText){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticText, IsEllipsized)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticText::IsEllipsized\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticText::IsEllipsized\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticText){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::IsEllipsized())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->IsEllipsized());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticText, Wrap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticText::Wrap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticText::Wrap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticText){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticText::Wrap((int) width0)\n\n");
				#endif
				((wxStaticText_php*)_this)->Wrap((int) width0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStaticText, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticText::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStaticText_php();

				((wxStaticText_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1);
				((wxStaticText_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1);
				((wxStaticText_php*) _this)->references.AddReference(pos1);
				((wxStaticText_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1);
				((wxStaticText_php*) _this)->references.AddReference(pos1);
				((wxStaticText_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1);
				((wxStaticText_php*) _this)->references.AddReference(pos1);
				((wxStaticText_php*) _this)->references.AddReference(size1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStaticText);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxStaticText_php*) _this)->evnArray);
		
		array_init(((wxStaticText_php*) _this)->evnArray);
		
		((wxStaticText_php*) _this)->phpObj = getThis();
		
		((wxStaticText_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStaticText_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxTextCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxTextCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxTextCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxTextCtrl_php();

				((wxTextCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1);
				((wxTextCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1);
				((wxTextCtrl_php*) _this)->references.AddReference(pos1);
				((wxTextCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1);
				((wxTextCtrl_php*) _this)->references.AddReference(pos1);
				((wxTextCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1);
				((wxTextCtrl_php*) _this)->references.AddReference(pos1);
				((wxTextCtrl_php*) _this)->references.AddReference(size1);
				((wxTextCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1);
				((wxTextCtrl_php*) _this)->references.AddReference(pos1);
				((wxTextCtrl_php*) _this)->references.AddReference(size1);
				((wxTextCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxTextCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxTextCtrl_php*) _this)->evnArray);
		
		array_init(((wxTextCtrl_php*) _this)->evnArray);
		
		((wxTextCtrl_php*) _this)->phpObj = getThis();
		
		((wxTextCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxTextCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxTextCtrl, XYToPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::XYToPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::XYToPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextCtrl::XYToPosition((long) x0, (long) y0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->XYToPosition((long) x0, (long) y0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, ShowPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::ShowPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::ShowPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::ShowPosition((long) pos0)\n\n");
				#endif
				((wxTextCtrl_php*)_this)->ShowPosition((long) pos0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, SetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::SetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::SetStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long start0;
	long end0;
	zval* style0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llO' (&start0, &end0, &style0, php_wxTextAttr_entry)\n");
		#endif
		char parse_parameters_string[] = "llO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &start0, &end0, &style0, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(style0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(style0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(style0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SetStyle((long) start0, (long) end0, *(wxTextAttr*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetStyle((long) start0, (long) end0, *(wxTextAttr*) object_pointer0_2));

				references->AddReference(style0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, SetModified)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::SetModified\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::SetModified\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool modified0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&modified0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &modified0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::SetModified(modified0)\n\n");
				#endif
				((wxTextCtrl_php*)_this)->SetModified(modified0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, SetDefaultStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::SetDefaultStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::SetDefaultStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* style0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&style0, php_wxTextAttr_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(style0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(style0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(style0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SetDefaultStyle(*(wxTextAttr*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetDefaultStyle(*(wxTextAttr*) object_pointer0_0));

				references->AddReference(style0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, SaveFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::SaveFile\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::SaveFile\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	long fileType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|sl' (&filename0, &filename_len0, &fileType0)\n");
		#endif
		char parse_parameters_string[] = "|sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0, &fileType0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SaveFile())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SaveFile());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SaveFile(wxString(filename0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SaveFile(wxString(filename0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SaveFile(wxString(filename0, wxConvUTF8), (int) fileType0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SaveFile(wxString(filename0, wxConvUTF8), (int) fileType0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, PositionToXY)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::PositionToXY\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::PositionToXY\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	long* x0;
	zval* x0_ref;
	long* y0;
	zval* y0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&pos0, x0, y0)\n");
		#endif
		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, x0, y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &x0_ref, &y0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::PositionToXY((long) pos0, (long*) x0, (long*) y0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->PositionToXY((long) pos0, (long*) x0, (long*) y0));

				size_t elements_returned0_1 = sizeof(x0)/sizeof(*x0);
				array_init(x0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(x0_ref, x0[i]);
				}
				size_t elements_returned0_2 = sizeof(y0)/sizeof(*y0);
				array_init(y0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(y0_ref, y0[i]);
				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, MarkDirty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::MarkDirty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::MarkDirty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::MarkDirty()\n\n");
				#endif
				((wxTextCtrl_php*)_this)->MarkDirty();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::LoadFile\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	long fileType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&filename0, &filename_len0, &fileType0)\n");
		#endif
		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0, &fileType0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::LoadFile(wxString(filename0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->LoadFile(wxString(filename0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::LoadFile(wxString(filename0, wxConvUTF8), (int) fileType0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->LoadFile(wxString(filename0, wxConvUTF8), (int) fileType0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, IsSingleLine)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::IsSingleLine\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::IsSingleLine\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::IsSingleLine())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->IsSingleLine());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, IsMultiLine)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::IsMultiLine\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::IsMultiLine\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::IsMultiLine())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->IsMultiLine());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, IsModified)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::IsModified\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::IsModified\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::IsModified())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->IsModified());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, GetNumberOfLines)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetNumberOfLines\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetNumberOfLines\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextCtrl::GetNumberOfLines())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->GetNumberOfLines());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, GetLineText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetLineText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetLineText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long lineNo0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&lineNo0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lineNo0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextCtrl::GetLineText((long) lineNo0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxTextCtrl_php*)_this)->GetLineText((long) lineNo0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, GetLineLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetLineLength\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetLineLength\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long lineNo0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&lineNo0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lineNo0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextCtrl::GetLineLength((long) lineNo0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->GetLineLength((long) lineNo0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, EmulateKeyPress)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::EmulateKeyPress\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::EmulateKeyPress\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* event0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&event0, php_wxKeyEvent_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &event0, php_wxKeyEvent_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(event0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(event0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(event0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::EmulateKeyPress(*(wxKeyEvent*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->EmulateKeyPress(*(wxKeyEvent*) object_pointer0_0));

				references->AddReference(event0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, DiscardEdits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::DiscardEdits\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::DiscardEdits\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::DiscardEdits()\n\n");
				#endif
				((wxTextCtrl_php*)_this)->DiscardEdits();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, Cut)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::Cut\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::Cut\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::Cut()\n\n");
				#endif
				((wxTextCtrl_php*)_this)->Cut();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, GetDefaultStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetDefaultStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetDefaultStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::GetDefaultStyle() to return object reference\n\n");
				#endif
				wxTextAttr_php* value_to_return0;
				value_to_return0 = (wxTextAttr_php*) &((wxTextCtrl_php*)_this)->GetDefaultStyle();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextAttr_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTextAttr));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextCtrl, GetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long position0;
	zval* style0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&position0, &style0, php_wxTextAttr_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &position0, &style0, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(style0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(style0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(style0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::GetStyle((long) position0, *(wxTextAttr*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->GetStyle((long) position0, *(wxTextAttr*) object_pointer0_1));

				references->AddReference(style0);

				return;
				break;
			}
		}
	}

		
}
void php_wxTextEntry_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextEntry_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxTextEntry_php* object = static_cast<wxTextEntry_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTextEntry done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxTextEntry, WriteText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::WriteText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::WriteText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::WriteText(wxString(text0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, Undo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Undo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Undo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Undo()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Undo();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Undo();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Undo();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Undo();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Undo();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetValue(wxString(value0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetValue(wxString(value0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetSelection((long) from0, (long) to0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetSelection((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetSelection((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetSelection((long) from0, (long) to0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SetMaxLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetMaxLength\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetMaxLength\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&len0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetMaxLength((unsigned long) len0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetMaxLength((unsigned long) len0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long left0;
	long top0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&left0, &top0)\n");
		#endif
		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &left0, &top0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::SetMargins((wxCoord) left0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetMargins((wxCoord) left0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->SetMargins((wxCoord) left0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetMargins((wxCoord) left0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetMargins((wxCoord) left0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->SetMargins((wxCoord) left0));
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::SetMargins((wxCoord) left0, (wxCoord) top0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::SetMargins(*(wxPoint*) object_pointer1_0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}

				references->AddReference(pt1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SetInsertionPointEnd)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetInsertionPointEnd\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetInsertionPointEnd\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetInsertionPointEnd()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetInsertionPointEnd();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetInsertionPointEnd();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SetInsertionPointEnd();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SetInsertionPointEnd();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetInsertionPointEnd();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetInsertionPoint((long) pos0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetInsertionPoint((long) pos0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetInsertionPoint((long) pos0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SetInsertionPoint((long) pos0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SetInsertionPoint((long) pos0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetInsertionPoint((long) pos0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SetHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* hint0;
	long hint_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&hint0, &hint_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &hint0, &hint_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::SetHint(wxString(hint0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SetEditable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetEditable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetEditable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool editable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&editable0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &editable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetEditable(editable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetEditable(editable0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SelectAll()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SelectAll();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, Replace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Replace\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Replace\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls' (&from0, &to0, &value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "lls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, Remove)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Remove\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Remove\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Remove((long) from0, (long) to0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Remove((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Remove((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Remove((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Remove((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Remove((long) from0, (long) to0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, Redo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Redo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Redo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Redo()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Redo();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, Paste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Paste\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Paste\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Paste()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Paste();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Paste();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Paste();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Paste();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Paste();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, IsEditable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::IsEditable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::IsEditable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::IsEditable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->IsEditable());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextEntry::GetValue().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return0 = ((wxTextCtrl_php*)_this)->GetValue();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return0 = ((wxSearchCtrl_php*)_this)->GetValue();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return0 = ((wxComboBox_php*)_this)->GetValue();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetValue();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return0 = ((wxTextEntry_php*)_this)->GetValue();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, GetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextEntry::GetStringSelection().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return0 = ((wxTextCtrl_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return0 = ((wxSearchCtrl_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					value_to_return0 = ((wxComboCtrl_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return0 = ((wxTextEntry_php*)_this)->GetStringSelection();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long* from0;
	zval* from0_ref;
	long* to0;
	zval* to0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (from0, to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, from0, to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &from0_ref, &to0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::GetSelection((long*) from0, (long*) to0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->GetSelection((long*) from0, (long*) to0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->GetSelection((long*) from0, (long*) to0);
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->GetSelection((long*) from0, (long*) to0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->GetSelection((long*) from0, (long*) to0);
				}

				size_t elements_returned0_0 = sizeof(from0)/sizeof(*from0);
				array_init(from0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(from0_ref, from0[i]);
				}
				size_t elements_returned0_1 = sizeof(to0)/sizeof(*to0);
				array_init(to0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(to0_ref, to0[i]);
				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, GetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextEntry::GetRange((long) from0, (long) to0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return2 = ((wxTextCtrl_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return2 = ((wxSearchCtrl_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return2 = ((wxComboBox_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return2 = ((wxBitmapComboBox_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					value_to_return2 = ((wxComboCtrl_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return2 = ((wxTextEntry_php*)_this)->GetRange((long) from0, (long) to0);
				}
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, GetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::GetMargins() to return new object\n\n");
				#endif
				wxPoint value_to_return0;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return0 = ((wxTextCtrl_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return0 = ((wxSearchCtrl_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return0 = ((wxComboBox_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return0 = ((wxTextEntry_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, GetLastPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetLastPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetLastPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextEntry::GetLastPosition())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->GetLastPosition());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_LONG(return_value, ((wxSearchCtrl_php*)_this)->GetLastPosition());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetLastPosition());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_LONG(return_value, ((wxBitmapComboBox_php*)_this)->GetLastPosition());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_LONG(return_value, ((wxTextEntry_php*)_this)->GetLastPosition());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, GetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextEntry::GetInsertionPoint())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->GetInsertionPoint());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_LONG(return_value, ((wxSearchCtrl_php*)_this)->GetInsertionPoint());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_LONG(return_value, ((wxTextEntry_php*)_this)->GetInsertionPoint());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, GetHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextEntry::GetHint().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return0 = ((wxTextCtrl_php*)_this)->GetHint();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return0 = ((wxSearchCtrl_php*)_this)->GetHint();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return0 = ((wxComboBox_php*)_this)->GetHint();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetHint();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return0 = ((wxTextEntry_php*)_this)->GetHint();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, Copy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Copy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Copy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Copy()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Copy();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Copy();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Copy();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Copy();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Copy();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Clear\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Clear()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Clear();
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, ChangeValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::ChangeValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::ChangeValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::ChangeValue(wxString(value0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, CanUndo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanUndo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanUndo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanUndo())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanUndo());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, CanRedo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanRedo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanRedo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanRedo())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanRedo());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, CanPaste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanPaste\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanPaste\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanPaste())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanPaste());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, CanCut)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanCut\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanCut\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanCut())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanCut());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, CanCopy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanCopy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanCopy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanCopy())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanCopy());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, AutoCompleteFileNames)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::AutoCompleteFileNames\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::AutoCompleteFileNames\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::AutoCompleteFileNames())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->AutoCompleteFileNames());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, AutoCompleteDirectories)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::AutoCompleteDirectories\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::AutoCompleteDirectories\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::AutoCompleteDirectories())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->AutoCompleteDirectories());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, AutoComplete)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::AutoComplete\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::AutoComplete\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* completer0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* choices1 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&completer0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &completer0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(completer0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(completer0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(completer0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&choices1)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &choices1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::AutoComplete((wxTextCompleter*) object_pointer0_0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}

				references->AddReference(completer0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_0;
		bool strings_continue1_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index1_0 = 0;
				zval** temp_array_value1_0 = 0;
				while(strings_continue1_0)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_0, (void**)&temp_array_value1_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_0);
						strings_array1_0.Add(wxString(Z_STRVAL_PP(temp_array_value1_0), wxConvUTF8));
						array_index1_0++;
					}
					else
					{
						strings_continue1_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::AutoComplete(strings_array1_0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->AutoComplete(strings_array1_0));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTextEntry, AppendText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::AppendText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::AppendText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::AppendText(wxString(text0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxToggleButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxToggleButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxToggleButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToggleButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxToggleButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxToggleButton){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* val0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &val0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &val0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(val0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(val0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(val0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(val0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(val0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxToggleButton, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToggleButton::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxToggleButton::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxToggleButton){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::GetValue())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxToggleButton, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToggleButton::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxToggleButton::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxToggleButton){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&state0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToggleButton::SetValue(state0)\n\n");
				#endif
				((wxToggleButton_php*)_this)->SetValue(state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxToggleButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToggleButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* val1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &val1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &val1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(val1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(val1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(val1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxToggleButton_php();

				((wxToggleButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1);
				((wxToggleButton_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1);
				((wxToggleButton_php*) _this)->references.AddReference(pos1);
				((wxToggleButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1);
				((wxToggleButton_php*) _this)->references.AddReference(pos1);
				((wxToggleButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1);
				((wxToggleButton_php*) _this)->references.AddReference(pos1);
				((wxToggleButton_php*) _this)->references.AddReference(size1);
				((wxToggleButton_php*) _this)->references.AddReference(val1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1);
				((wxToggleButton_php*) _this)->references.AddReference(pos1);
				((wxToggleButton_php*) _this)->references.AddReference(size1);
				((wxToggleButton_php*) _this)->references.AddReference(val1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxToggleButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxToggleButton_php*) _this)->evnArray);
		
		array_init(((wxToggleButton_php*) _this)->evnArray);
		
		((wxToggleButton_php*) _this)->phpObj = getThis();
		
		((wxToggleButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxToggleButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxBitmapToggleButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxBitmapToggleButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxBitmapToggleButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapToggleButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapToggleButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapToggleButton){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* label0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* val0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOlOs' (&parent0, &id0, &label0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &val0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &val0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(label0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(val0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(val0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(val0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(label0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(val0);

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(label0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(val0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapToggleButton, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapToggleButton::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapToggleButton::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapToggleButton){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::GetValue())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapToggleButton, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapToggleButton::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapToggleButton::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapToggleButton){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&state0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapToggleButton::SetValue(state0)\n\n");
				#endif
				((wxBitmapToggleButton_php*)_this)->SetValue(state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxBitmapToggleButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapToggleButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* label1 = 0;
	void* object_pointer1_2 = 0;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* val1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOlOs' (&parent1, &id1, &label1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &val1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &val1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(val1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(val1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(val1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxBitmapToggleButton_php();

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(size1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(size1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(val1);
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(size1);
				((wxBitmapToggleButton_php*) _this)->references.AddReference(val1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxBitmapToggleButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxBitmapToggleButton_php*) _this)->evnArray);
		
		array_init(((wxBitmapToggleButton_php*) _this)->evnArray);
		
		((wxBitmapToggleButton_php*) _this)->phpObj = getThis();
		
		((wxBitmapToggleButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxBitmapToggleButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxTreeCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxTreeCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxTreeCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOlOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxTreeCtrl_php();

				((wxTreeCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1);
				((wxTreeCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1);
				((wxTreeCtrl_php*) _this)->references.AddReference(size1);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1);
				((wxTreeCtrl_php*) _this)->references.AddReference(size1);
				((wxTreeCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8));

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1);
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1);
				((wxTreeCtrl_php*) _this)->references.AddReference(size1);
				((wxTreeCtrl_php*) _this)->references.AddReference(validator1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxTreeCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxTreeCtrl_php*) _this)->evnArray);
		
		array_init(((wxTreeCtrl_php*) _this)->evnArray);
		
		((wxTreeCtrl_php*) _this)->phpObj = getThis();
		
		((wxTreeCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxTreeCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxTreeCtrl, AddRoot)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::AddRoot\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::AddRoot\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	long image0;
	long selImage0;
	zval* data0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llz' (&text0, &text_len0, &image0, &selImage0, &data0)\n");
		#endif
		char parse_parameters_string[] = "s|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0, &image0, &selImage0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 4){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AddRoot(wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->AddRoot(wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AddRoot(wxString(text0, wxConvUTF8), (int) image0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return2;
				value_to_return2 = ((wxTreeCtrl_php*)_this)->AddRoot(wxString(text0, wxConvUTF8), (int) image0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AddRoot(wxString(text0, wxConvUTF8), (int) image0, (int) selImage0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->AddRoot(wxString(text0, wxConvUTF8), (int) image0, (int) selImage0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AddRoot(wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_3) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->AddRoot(wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_3);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, AppendItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::AppendItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::AppendItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long image0;
	long selImage0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return2;
				value_to_return2 = ((wxTreeCtrl_php*)_this)->AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return5;
				value_to_return5 = ((wxTreeCtrl_php*)_this)->AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, AssignImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::AssignImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::AssignImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AssignImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->AssignImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, AssignStateImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::AssignStateImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::AssignStateImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AssignStateImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->AssignStateImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, ClearFocusedItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ClearFocusedItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ClearFocusedItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ClearFocusedItem()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ClearFocusedItem();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, Collapse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Collapse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Collapse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Collapse(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Collapse(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, CollapseAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::CollapseAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::CollapseAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::CollapseAll()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->CollapseAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, CollapseAllChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::CollapseAllChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::CollapseAllChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::CollapseAllChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->CollapseAllChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, CollapseAndReset)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::CollapseAndReset\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::CollapseAndReset\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::CollapseAndReset(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->CollapseAndReset(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);
				references->AddReference(validator0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, Delete)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Delete\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Delete\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Delete(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Delete(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::DeleteAllItems()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->DeleteAllItems();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, DeleteChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::DeleteChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::DeleteChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::DeleteChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->DeleteChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, EndEditLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::EndEditLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::EndEditLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool discardChanges0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &discardChanges0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &discardChanges0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::EndEditLabel(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->EndEditLabel(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::EndEditLabel(*(wxTreeItemId*) object_pointer0_0, discardChanges0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->EndEditLabel(*(wxTreeItemId*) object_pointer0_0, discardChanges0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, EnsureVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::EnsureVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::EnsureVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::EnsureVisible(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->EnsureVisible(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, Expand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Expand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Expand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Expand(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Expand(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, ExpandAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ExpandAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ExpandAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ExpandAll()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ExpandAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, ExpandAllChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ExpandAllChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ExpandAllChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ExpandAllChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ExpandAllChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetBoundingRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetBoundingRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetBoundingRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* rect0 = 0;
	void* object_pointer0_1 = 0;
	bool textOnly0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO|b' (&item0, php_wxTreeItemId_entry, &rect0, php_wxRect_entry, &textOnly0)\n");
		#endif
		char parse_parameters_string[] = "OO|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &rect0, php_wxRect_entry, &textOnly0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::GetBoundingRect(*(wxTreeItemId*) object_pointer0_0, *(wxRect*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->GetBoundingRect(*(wxTreeItemId*) object_pointer0_0, *(wxRect*) object_pointer0_1));

				references->AddReference(item0);
				references->AddReference(rect0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::GetBoundingRect(*(wxTreeItemId*) object_pointer0_0, *(wxRect*) object_pointer0_1, textOnly0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->GetBoundingRect(*(wxTreeItemId*) object_pointer0_0, *(wxRect*) object_pointer0_1, textOnly0));

				references->AddReference(item0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetChildrenCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetChildrenCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetChildrenCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool recursively0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &recursively0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &recursively0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetChildrenCount(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetChildrenCount(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetChildrenCount(*(wxTreeItemId*) object_pointer0_0, recursively0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetChildrenCount(*(wxTreeItemId*) object_pointer0_0, recursively0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetEditControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetEditControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetEditControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetEditControl() to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return0;
				value_to_return0 = (wxTextCtrl_php*) ((wxTreeCtrl_php*)_this)->GetEditControl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetFirstVisibleItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetFirstVisibleItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetFirstVisibleItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetFirstVisibleItem() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxTreeCtrl_php*)_this)->GetFirstVisibleItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetFocusedItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetFocusedItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetFocusedItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetFocusedItem() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxTreeCtrl_php*)_this)->GetFocusedItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetImageList() to return object pointer\n\n");
				#endif
				wxImageList_php* value_to_return0;
				value_to_return0 = (wxImageList_php*) ((wxTreeCtrl_php*)_this)->GetImageList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImageList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxImageList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetIndent())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetIndent());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetItemBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemBackgroundColour(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxColour value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemBackgroundColour(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemData(*(wxTreeItemId*) object_pointer0_0) to return object pointer\n\n");
				#endif
				wxTreeItemData_php* value_to_return1;
				value_to_return1 = (wxTreeItemData_php*) ((wxTreeCtrl_php*)_this)->GetItemData(*(wxTreeItemId*) object_pointer0_0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTreeItemData_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxTreeItemData));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetItemFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemFont(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxFont value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemFont(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxFont));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetItemImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&item0, php_wxTreeItemId_entry, &which0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &which0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetItemImage(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetItemImage(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetItemImage(*(wxTreeItemId*) object_pointer0_0, (wxTreeItemIcon) which0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetItemImage(*(wxTreeItemId*) object_pointer0_0, (wxTreeItemIcon) which0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetItemParent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemParent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemParent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemParent(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemParent(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetItemState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetItemState(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetItemState(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTreeCtrl::GetItemText(*(wxTreeItemId*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemText(*(wxTreeItemId*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetItemTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemTextColour(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxColour value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemTextColour(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetLastChild)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetLastChild\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetLastChild\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetLastChild(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetLastChild(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetNextSibling)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetNextSibling\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetNextSibling\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetNextSibling(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetNextSibling(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetNextVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetNextVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetNextVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetNextVisible(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetNextVisible(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetPrevSibling)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetPrevSibling\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetPrevSibling\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetPrevSibling(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetPrevSibling(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetPrevVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetPrevVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetPrevVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetPrevVisible(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetPrevVisible(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetQuickBestSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetQuickBestSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetQuickBestSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::GetQuickBestSize())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->GetQuickBestSize());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetRootItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetRootItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetRootItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetRootItem() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxTreeCtrl_php*)_this)->GetRootItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetSelection() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxTreeCtrl_php*)_this)->GetSelection();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, GetStateImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetStateImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetStateImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetStateImageList() to return object pointer\n\n");
				#endif
				wxImageList_php* value_to_return0;
				value_to_return0 = (wxImageList_php*) ((wxTreeCtrl_php*)_this)->GetStateImageList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImageList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxImageList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, HitTest)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::HitTest\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::HitTest\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* point0 = 0;
	void* object_pointer0_0 = 0;
	long flags0;
	zval* flags0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&point0, php_wxPoint_entry, &flags0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &point0, php_wxPoint_entry, &flags0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(point0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(point0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(point0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &flags0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::HitTest(*(wxPoint*) object_pointer0_0, (int&) flags0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return2;
				value_to_return2 = ((wxTreeCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0, (int&) flags0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(point0);
				ZVAL_LONG(flags0_ref, flags0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, InsertItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::InsertItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::InsertItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	zval* previous0 = 0;
	void* object_pointer0_1 = 0;
	char* text0;
	long text_len0;
	long image0;
	long selImage0;
	zval* data0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long before1;
	char* text1;
	long text_len1;
	long image1;
	long selImage1;
	zval* data1 = 0;
	void* object_pointer1_5 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOs|llz' (&parent0, php_wxTreeItemId_entry, &previous0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0)\n");
		#endif
		char parse_parameters_string[] = "OOs|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeItemId_entry, &previous0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(previous0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(previous0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(previous0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ols|llz' (&parent1, php_wxTreeItemId_entry, &before1, &text1, &text_len1, &image1, &selImage1, &data1)\n");
		#endif
		char parse_parameters_string[] = "Ols|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, php_wxTreeItemId_entry, &before1, &text1, &text_len1, &image1, &selImage1, &data1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(data1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);
				references->AddReference(previous0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);
				references->AddReference(previous0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return5;
				value_to_return5 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);
				references->AddReference(previous0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_5) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return6;
				value_to_return6 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_5);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return6, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);
				references->AddReference(previous0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent1);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent1);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1, (int) selImage1) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return5;
				value_to_return5 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1, (int) selImage1);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent1);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1, (int) selImage1, (wxTreeItemData*) object_pointer1_5) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return6;
				value_to_return6 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1, (int) selImage1, (wxTreeItemData*) object_pointer1_5);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return6, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent1);
				references->AddReference(data1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, IsBold)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsBold\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsBold\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsBold(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsBold(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, IsEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsEmpty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsEmpty())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsEmpty());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, IsExpanded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsExpanded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsExpanded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsExpanded(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsExpanded(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsSelected(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsSelected(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, IsVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsVisible(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsVisible(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, ItemHasChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ItemHasChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ItemHasChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::ItemHasChildren(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->ItemHasChildren(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, PrependItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::PrependItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::PrependItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long image0;
	long selImage0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return2;
				value_to_return2 = ((wxTreeCtrl_php*)_this)->PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return5;
				value_to_return5 = ((wxTreeCtrl_php*)_this)->PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, ScrollTo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ScrollTo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ScrollTo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ScrollTo(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ScrollTo(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SelectChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SelectChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SelectChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&parent0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SelectChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SelectChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(parent0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SelectItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SelectItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SelectItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool select0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &select0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &select0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SelectItem(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SelectItem(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SelectItem(*(wxTreeItemId*) object_pointer0_0, select0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SelectItem(*(wxTreeItemId*) object_pointer0_0, select0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetFocusedItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetFocusedItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetFocusedItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetFocusedItem(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetFocusedItem(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long indent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&indent0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &indent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetIndent((unsigned int) indent0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetIndent((unsigned int) indent0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxTreeItemId_entry, &col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemBackgroundColour(*(wxTreeItemId*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemBackgroundColour(*(wxTreeItemId*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(item0);
				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemBold)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemBold\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemBold\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool bold0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &bold0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &bold0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemBold(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemBold(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemBold(*(wxTreeItemId*) object_pointer0_0, bold0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemBold(*(wxTreeItemId*) object_pointer0_0, bold0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* data0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oz' (&item0, php_wxTreeItemId_entry, &data0)\n");
		#endif
		char parse_parameters_string[] = "Oz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemData(*(wxTreeItemId*) object_pointer0_0, (wxTreeItemData*) object_pointer0_1)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemData(*(wxTreeItemId*) object_pointer0_0, (wxTreeItemData*) object_pointer0_1);

				references->AddReference(item0);
				references->AddReference(data0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemDropHighlight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemDropHighlight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemDropHighlight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool highlight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &highlight0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &highlight0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemDropHighlight(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemDropHighlight(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemDropHighlight(*(wxTreeItemId*) object_pointer0_0, highlight0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemDropHighlight(*(wxTreeItemId*) object_pointer0_0, highlight0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* font0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxTreeItemId_entry, &font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemFont(*(wxTreeItemId*) object_pointer0_0, *(wxFont*) object_pointer0_1)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemFont(*(wxTreeItemId*) object_pointer0_0, *(wxFont*) object_pointer0_1);

				references->AddReference(item0);
				references->AddReference(font0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemHasChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemHasChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemHasChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool hasChildren0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &hasChildren0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &hasChildren0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemHasChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemHasChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemHasChildren(*(wxTreeItemId*) object_pointer0_0, hasChildren0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemHasChildren(*(wxTreeItemId*) object_pointer0_0, hasChildren0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long image0;
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|l' (&item0, php_wxTreeItemId_entry, &image0, &which0)\n");
		#endif
		char parse_parameters_string[] = "Ol|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &image0, &which0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemImage(*(wxTreeItemId*) object_pointer0_0, (int) image0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemImage(*(wxTreeItemId*) object_pointer0_0, (int) image0);

				references->AddReference(item0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemImage(*(wxTreeItemId*) object_pointer0_0, (int) image0, (wxTreeItemIcon) which0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemImage(*(wxTreeItemId*) object_pointer0_0, (int) image0, (wxTreeItemIcon) which0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&item0, php_wxTreeItemId_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemState(*(wxTreeItemId*) object_pointer0_0, (int) state0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemState(*(wxTreeItemId*) object_pointer0_0, (int) state0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os' (&item0, php_wxTreeItemId_entry, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &text0, &text_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemText(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemText(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8));

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetItemTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxTreeItemId_entry, &col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemTextColour(*(wxTreeItemId*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemTextColour(*(wxTreeItemId*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(item0);
				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetQuickBestSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetQuickBestSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetQuickBestSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool quickBestSize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&quickBestSize0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &quickBestSize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetQuickBestSize(quickBestSize0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetQuickBestSize(quickBestSize0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetStateImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetStateImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetStateImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetStateImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetStateImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SetWindowStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetWindowStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetWindowStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long styles0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&styles0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &styles0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetWindowStyle((long) styles0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetWindowStyle((long) styles0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, SortChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SortChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SortChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SortChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SortChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, Toggle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Toggle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Toggle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Toggle(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Toggle(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, ToggleItemSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ToggleItemSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ToggleItemSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ToggleItemSelection(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ToggleItemSelection(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, Unselect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Unselect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Unselect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Unselect()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Unselect();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, UnselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::UnselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::UnselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::UnselectAll()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->UnselectAll();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxTreeCtrl, UnselectItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::UnselectItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::UnselectItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::UnselectItem(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->UnselectItem(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
void php_wxVListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxVListBox_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxVListBox_php* object = static_cast<wxVListBox_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxVListBox done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxVListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0);
				((wxVListBox_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0);
				((wxVListBox_php*) _this)->references.AddReference(pos0);
				((wxVListBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0);
				((wxVListBox_php*) _this)->references.AddReference(pos0);
				((wxVListBox_php*) _this)->references.AddReference(size0);
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8));

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0);
				((wxVListBox_php*) _this)->references.AddReference(pos0);
				((wxVListBox_php*) _this)->references.AddReference(size0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxVListBox_php();

				((wxVListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxVListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxVListBox_php*) _this)->evnArray);
		
		array_init(((wxVListBox_php*) _this)->evnArray);
		
		((wxVListBox_php*) _this)->phpObj = getThis();
		
		((wxVListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxVListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxVListBox, Toggle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::Toggle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::Toggle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::Toggle((size_t) item0)\n\n");
				#endif
				((wxVListBox_php*)_this)->Toggle((size_t) item0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, SetSelectionBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SetSelectionBackground\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SetSelectionBackground\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetSelectionBackground(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetSelectionBackground(*(wxColour*) object_pointer0_0);

				references->AddReference(col0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long selection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&selection0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &selection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetSelection((int) selection0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetSelection((int) selection0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetMargins((wxCoord) x0, (wxCoord) y0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetMargins((wxCoord) x0, (wxCoord) y0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetMargins(*(wxPoint*) object_pointer1_0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0);

				references->AddReference(pt1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, SetItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SetItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SetItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long count0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&count0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &count0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetItemCount((size_t) count0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetItemCount((size_t) count0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, SelectRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SelectRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SelectRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::SelectRange((size_t) from0, (size_t) to0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->SelectRange((size_t) from0, (size_t) to0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::SelectAll())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->SelectAll());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, Select)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::Select\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::Select\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool select0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&item0, &select0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &select0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Select((size_t) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Select((size_t) item0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Select((size_t) item0, select0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Select((size_t) item0, select0));


				return;
				break;
			}
		}
	}

		
}
wxCoord wxVListBox_php::OnMeasureItem(size_t n)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVListBox::OnMeasureItem\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnMeasureItem", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'OnMeasureItem'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (wxCoord) Z_LVAL_P(return_value);
	

}
void wxVListBox_php::OnDrawSeparator(wxDC& dc, wxRect& rect, size_t n)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVListBox::OnDrawSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrawSeparator", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxRect_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[2], n);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxVListBox::OnDrawSeparator(dc, rect, n);

}
void wxVListBox_php::OnDrawItem(wxDC& dc, const wxRect& rect, size_t n)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVListBox::OnDrawItem\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrawItem", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxRect_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[2], n);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'OnDrawItem'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxVListBox_php::OnDrawBackground(wxDC& dc, const wxRect& rect, size_t n)const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVListBox::OnDrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrawBackground", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxRect_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[2], n);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxVListBox::OnDrawBackground(dc, rect, n);

}
PHP_METHOD(php_wxVListBox, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::IsSelected((size_t) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->IsSelected((size_t) item0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, IsCurrent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::IsCurrent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::IsCurrent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::IsCurrent((size_t) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->IsCurrent((size_t) item0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, HasMultipleSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::HasMultipleSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::HasMultipleSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::HasMultipleSelection())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->HasMultipleSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, GetSelectionBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetSelectionBackground\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetSelectionBackground\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::GetSelectionBackground() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxVListBox_php*)_this)->GetSelectionBackground();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, GetSelectedCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetSelectedCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetSelectedCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetSelectedCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetSelectedCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::Clear\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::Clear()\n\n");
				#endif
				((wxVListBox_php*)_this)->Clear();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, DeselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::DeselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::DeselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::DeselectAll())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->DeselectAll());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, GetFirstSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetFirstSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetFirstSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long cookie0;
	zval* cookie0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&cookie0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &cookie0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &cookie0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetFirstSelected((unsigned long&) cookie0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetFirstSelected((unsigned long&) cookie0));

				ZVAL_LONG(cookie0_ref, cookie0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, GetItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetItemCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetItemCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, GetItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::GetItemRect((size_t) item0) to return new object\n\n");
				#endif
				wxRect value_to_return1;
				value_to_return1 = ((wxVListBox_php*)_this)->GetItemRect((size_t) item0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, GetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::GetMargins() to return new object\n\n");
				#endif
				wxPoint value_to_return0;
				value_to_return0 = ((wxVListBox_php*)_this)->GetMargins();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxVListBox, GetNextSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetNextSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetNextSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long cookie0;
	zval* cookie0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&cookie0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &cookie0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &cookie0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetNextSelected((unsigned long&) cookie0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetNextSelected((unsigned long&) cookie0));

				ZVAL_LONG(cookie0_ref, cookie0);

				return;
				break;
			}
		}
	}

		
}
