/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


void php_wxDataOutputStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataOutputStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxDataOutputStream_php* object = static_cast<wxDataOutputStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDataOutputStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxDataOutputStream, BigEndianOrdered)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataOutputStream::BigEndianOrdered\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataOutputStream::BigEndianOrdered\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataOutputStream){
				references = &((wxDataOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool be_order0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&be_order0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &be_order0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::BigEndianOrdered(be_order0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->BigEndianOrdered(be_order0);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataOutputStream, Write16)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataOutputStream::Write16\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataOutputStream::Write16\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataOutputStream){
				references = &((wxDataOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long i160;
	bool overload0_called = false;
	//Parameters for overload 1
	long buffer1;
	long size1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&i160)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &i160 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::Write16((wxUint16) i160)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->Write16((wxUint16) i160);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::Write16((const wxUint16*) buffer1, (size_t) size1)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->Write16((const wxUint16*) buffer1, (size_t) size1);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataOutputStream, Write32)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataOutputStream::Write32\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataOutputStream::Write32\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataOutputStream){
				references = &((wxDataOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long i320;
	bool overload0_called = false;
	//Parameters for overload 1
	long buffer1;
	long size1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&i320)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &i320 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::Write32((wxUint32) i320)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->Write32((wxUint32) i320);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::Write32((const wxUint32*) buffer1, (size_t) size1)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->Write32((const wxUint32*) buffer1, (size_t) size1);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataOutputStream, Write8)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataOutputStream::Write8\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataOutputStream::Write8\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataOutputStream){
				references = &((wxDataOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long i80;
	bool overload0_called = false;
	//Parameters for overload 1
	long buffer1;
	long size1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&i80)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &i80 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::Write8((wxUint8) i80)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->Write8((wxUint8) i80);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::Write8((const wxUint8*) buffer1, (size_t) size1)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->Write8((const wxUint8*) buffer1, (size_t) size1);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataOutputStream, WriteDouble)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataOutputStream::WriteDouble\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataOutputStream::WriteDouble\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataOutputStream){
				references = &((wxDataOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	double f0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* buffer1;
	long size1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&f0)\n");
		#endif
		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &f0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'al' (&buffer1, &size1)\n");
		#endif
		char parse_parameters_string[] = "al";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::WriteDouble(f0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->WriteDouble(f0);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		int array_count1_0 = 1;
		HashTable* arr_hash1_0;
		if(arguments_received > 0)
		{
			arr_hash1_0 = Z_ARRVAL_P(buffer1);
			array_count1_0 = zend_hash_num_elements(arr_hash1_0);
		}
		double* floats_array1_0 = new double[array_count1_0];
		bool floats_continue1_0 = true;

		switch(arguments_received)
		{
			case 2:
			{
				int array_index1_0 = 0;
				zval** temp_array_value1_0 = 0;
				while(floats_continue1_0)
				{
					if(zend_hash_index_find(HASH_OF(buffer1), array_index1_0, (void**)&temp_array_value1_0) == SUCCESS)
					{
						convert_to_double_ex(temp_array_value1_0);
						floats_array1_0[array_index1_0] = (double) Z_DVAL_PP(temp_array_value1_0);
						array_index1_0++;
					}
					else
					{
						floats_continue1_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::WriteDouble((const double*) floats_array1_0, (size_t) size1)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->WriteDouble((const double*) floats_array1_0, (size_t) size1);
				}

				delete[] floats_array1_0;

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataOutputStream, WriteString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataOutputStream::WriteString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataOutputStream::WriteString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataOutputStream){
				references = &((wxDataOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataOutputStream::WriteString(wxString(string0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataOutputStream)
				{
					((wxDataOutputStream_php*)_this)->WriteString(wxString(string0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxDataInputStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataInputStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxDataInputStream_php* object = static_cast<wxDataInputStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDataInputStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxDataInputStream, ReadString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataInputStream::ReadString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataInputStream::ReadString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataInputStream){
				references = &((wxDataInputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxDataInputStream::ReadString().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					value_to_return0 = ((wxDataInputStream_php*)_this)->ReadString();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataInputStream, ReadDouble)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataInputStream::ReadDouble\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataInputStream::ReadDouble\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataInputStream){
				references = &((wxDataInputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	double* buffer0;
	zval* buffer0_ref;
	long size0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dl' (buffer0, &size0)\n");
		#endif
		char parse_parameters_string[] = "dl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, buffer0, &size0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &buffer0_ref, &dummy );
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataInputStream::ReadDouble(buffer0, (size_t) size0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					((wxDataInputStream_php*)_this)->ReadDouble(buffer0, (size_t) size0);
				}

				size_t elements_returned0_0 = sizeof(buffer0)/sizeof(*buffer0);
				array_init(buffer0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(buffer0_ref, buffer0[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataInputStream::ReadDouble())\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					ZVAL_DOUBLE(return_value, ((wxDataInputStream_php*)_this)->ReadDouble());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataInputStream, Read8)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataInputStream::Read8\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataInputStream::Read8\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataInputStream){
				references = &((wxDataInputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long buffer0;
	long size0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&buffer0, &size0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buffer0, &size0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataInputStream::Read8((wxUint8*) buffer0, (size_t) size0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					((wxDataInputStream_php*)_this)->Read8((wxUint8*) buffer0, (size_t) size0);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataInputStream::Read8())\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					ZVAL_LONG(return_value, ((wxDataInputStream_php*)_this)->Read8());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataInputStream, Read32)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataInputStream::Read32\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataInputStream::Read32\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataInputStream){
				references = &((wxDataInputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long buffer0;
	long size0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&buffer0, &size0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buffer0, &size0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataInputStream::Read32((wxUint32*) buffer0, (size_t) size0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					((wxDataInputStream_php*)_this)->Read32((wxUint32*) buffer0, (size_t) size0);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataInputStream::Read32())\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					ZVAL_LONG(return_value, ((wxDataInputStream_php*)_this)->Read32());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataInputStream, Read16)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataInputStream::Read16\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataInputStream::Read16\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataInputStream){
				references = &((wxDataInputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long buffer0;
	long size0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&buffer0, &size0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buffer0, &size0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataInputStream::Read16((wxUint16*) buffer0, (size_t) size0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					((wxDataInputStream_php*)_this)->Read16((wxUint16*) buffer0, (size_t) size0);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataInputStream::Read16())\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					ZVAL_LONG(return_value, ((wxDataInputStream_php*)_this)->Read16());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxDataInputStream, BigEndianOrdered)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataInputStream::BigEndianOrdered\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataInputStream::BigEndianOrdered\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataInputStream){
				references = &((wxDataInputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool be_order0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&be_order0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &be_order0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataInputStream::BigEndianOrdered(be_order0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataInputStream)
				{
					((wxDataInputStream_php*)_this)->BigEndianOrdered(be_order0);
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxStreamBase_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxStreamBase_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxStreamBase_php* object = static_cast<wxStreamBase_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxStreamBase done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxStreamBase, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStreamBase::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStreamBase_php();

				((wxStreamBase_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStreamBase);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxStreamBase_php*) _this)->evnArray);
		
		array_init(((wxStreamBase_php*) _this)->evnArray);
		
		((wxStreamBase_php*) _this)->phpObj = getThis();
		
		((wxStreamBase_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStreamBase_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxStreamBase, Reset)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStreamBase::Reset\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStreamBase::Reset\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStreamBase){
				references = &((wxStreamBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInputStream) && (!reference_type_found)){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxOutputStream) && (!reference_type_found)){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long error0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&error0)\n");
		#endif
		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &error0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStreamBase::Reset()\n\n");
				#endif
				((wxStreamBase_php*)_this)->Reset();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStreamBase::Reset((wxStreamError) error0)\n\n");
				#endif
				((wxStreamBase_php*)_this)->Reset((wxStreamError) error0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStreamBase, IsSeekable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStreamBase::IsSeekable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStreamBase::IsSeekable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStreamBase){
				references = &((wxStreamBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInputStream) && (!reference_type_found)){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxOutputStream) && (!reference_type_found)){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStreamBase::IsSeekable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStreamBase_php*)_this)->IsSeekable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStreamBase, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStreamBase::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStreamBase::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStreamBase){
				references = &((wxStreamBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInputStream) && (!reference_type_found)){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxOutputStream) && (!reference_type_found)){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStreamBase::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStreamBase_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStreamBase, GetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStreamBase::GetSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStreamBase::GetSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStreamBase){
				references = &((wxStreamBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInputStream) && (!reference_type_found)){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxOutputStream) && (!reference_type_found)){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxStreamBase::GetSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxStreamBase_php*)_this)->GetSize());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStreamBase, GetLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStreamBase::GetLength\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStreamBase::GetLength\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStreamBase){
				references = &((wxStreamBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInputStream) && (!reference_type_found)){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxOutputStream) && (!reference_type_found)){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxStreamBase::GetLength())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxStreamBase_php*)_this)->GetLength());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxStreamBase, GetLastError)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStreamBase::GetLastError\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStreamBase::GetLastError\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStreamBase){
				references = &((wxStreamBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInputStream) && (!reference_type_found)){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxOutputStream) && (!reference_type_found)){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxStreamBase::GetLastError())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxStreamBase_php*)_this)->GetLastError());


				return;
				break;
			}
		}
	}

		
}
wxFileOffset wxStreamBase_php::OnSysSeek(wxFileOffset pos, wxSeekMode mode)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxStreamBase::OnSysSeek\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnSysSeek", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], pos);
	ZVAL_LONG(arguments[1], mode);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (wxFileOffset) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxStreamBase::OnSysSeek(pos, mode);

}
wxFileOffset wxStreamBase_php::OnSysTell()const
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxStreamBase::OnSysTell\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnSysTell", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (wxFileOffset) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxStreamBase::OnSysTell();

}
void php_wxOutputStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxOutputStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxOutputStream_php* object = static_cast<wxOutputStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxOutputStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxOutputStream, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxOutputStream::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxOutputStream_php();

				((wxOutputStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxOutputStream);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxOutputStream_php*) _this)->evnArray);
		
		array_init(((wxOutputStream_php*) _this)->evnArray);
		
		((wxOutputStream_php*) _this)->phpObj = getThis();
		
		((wxOutputStream_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxOutputStream_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxOutputStream, Write)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxOutputStream::Write\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxOutputStream::Write\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxOutputStream){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* stream_in0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&stream_in0, php_wxInputStream_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream_in0, php_wxInputStream_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream_in0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(stream_in0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream_in0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxOutputStream::Write(*(wxInputStream*) object_pointer0_0) to return object reference\n\n");
				#endif
				wxOutputStream_php* value_to_return1;
				value_to_return1 = (wxOutputStream_php*) &((wxOutputStream_php*)_this)->Write(*(wxInputStream*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxOutputStream_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxOutputStream));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(stream_in0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxOutputStream, TellO)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxOutputStream::TellO\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxOutputStream::TellO\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxOutputStream){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxOutputStream::TellO())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxOutputStream_php*)_this)->TellO());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxOutputStream, SeekO)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxOutputStream::SeekO\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxOutputStream::SeekO\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxOutputStream){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	long mode0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&pos0, &mode0)\n");
		#endif
		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &mode0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxOutputStream::SeekO((wxFileOffset) pos0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxOutputStream_php*)_this)->SeekO((wxFileOffset) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxOutputStream::SeekO((wxFileOffset) pos0, (wxSeekMode) mode0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxOutputStream_php*)_this)->SeekO((wxFileOffset) pos0, (wxSeekMode) mode0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxOutputStream, PutC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxOutputStream::PutC\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxOutputStream::PutC\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxOutputStream){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long c0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&c0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxOutputStream::PutC((char) c0)\n\n");
				#endif
				((wxOutputStream_php*)_this)->PutC((char) c0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxOutputStream, Close)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxOutputStream::Close\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxOutputStream::Close\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxOutputStream){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxOutputStream::Close())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxOutputStream_php*)_this)->Close());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxOutputStream, LastWrite)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxOutputStream::LastWrite\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxOutputStream::LastWrite\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxOutputStream){
				references = &((wxOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileOutputStream) && (!reference_type_found)){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileOutputStream) && (!reference_type_found)){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxOutputStream::LastWrite())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxOutputStream_php*)_this)->LastWrite());


				return;
				break;
			}
		}
	}

		
}
void php_wxInputStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxInputStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxInputStream_php* object = static_cast<wxInputStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxInputStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxInputStream, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxInputStream_php();

				((wxInputStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxInputStream);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxInputStream_php*) _this)->evnArray);
		
		array_init(((wxInputStream_php*) _this)->evnArray);
		
		((wxInputStream_php*) _this)->phpObj = getThis();
		
		((wxInputStream_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxInputStream_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxInputStream, Ungetch)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::Ungetch\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::Ungetch\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long c0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* buffer1;
	long buffer_len1;
	long size1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&c0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl' (&buffer1, &buffer_len1, &size1)\n");
		#endif
		char parse_parameters_string[] = "sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buffer1, &buffer_len1, &size1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxInputStream::Ungetch((char) c0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxInputStream_php*)_this)->Ungetch((char) c0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxInputStream::Ungetch((const void*) buffer1, (size_t) size1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxInputStream_php*)_this)->Ungetch((const void*) buffer1, (size_t) size1));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxInputStream, TellI)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::TellI\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::TellI\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxInputStream::TellI())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxInputStream_php*)_this)->TellI());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxInputStream, SeekI)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::SeekI\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::SeekI\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	long mode0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&pos0, &mode0)\n");
		#endif
		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &mode0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxInputStream::SeekI((wxFileOffset) pos0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxInputStream_php*)_this)->SeekI((wxFileOffset) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxInputStream::SeekI((wxFileOffset) pos0, (wxSeekMode) mode0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxInputStream_php*)_this)->SeekI((wxFileOffset) pos0, (wxSeekMode) mode0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxInputStream, Read)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::Read\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::Read\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* stream_out0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&stream_out0, php_wxOutputStream_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream_out0, php_wxOutputStream_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream_out0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(stream_out0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream_out0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxInputStream::Read(*(wxOutputStream*) object_pointer0_0) to return object reference\n\n");
				#endif
				wxInputStream_php* value_to_return1;
				value_to_return1 = (wxInputStream_php*) &((wxInputStream_php*)_this)->Read(*(wxOutputStream*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxInputStream_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxInputStream));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(stream_out0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxInputStream, Peek)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::Peek\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::Peek\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxInputStream::Peek().fn_str(), 1)\n\n");
				#endif
				char* value_to_return0;
				char value_to_return_temp0 = ((wxInputStream_php*)_this)->Peek();
				value_to_return0 = &value_to_return_temp0;
				ZVAL_STRING(return_value, value_to_return0, 1);


				return;
				break;
			}
		}
	}

		
}
size_t wxInputStream_php::OnSysRead(void* buffer, size_t bufsize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxInputStream::OnSysRead\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnSysRead", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_STRING(arguments[0], (char*) buffer, 0);
	ZVAL_LONG(arguments[1], bufsize);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'OnSysRead'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (size_t) Z_LVAL_P(return_value);
	

}
PHP_METHOD(php_wxInputStream, LastRead)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::LastRead\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::LastRead\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxInputStream::LastRead())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxInputStream_php*)_this)->LastRead());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxInputStream, GetC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::GetC\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::GetC\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxInputStream::GetC())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxInputStream_php*)_this)->GetC());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxInputStream, Eof)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::Eof\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::Eof\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxInputStream::Eof())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxInputStream_php*)_this)->Eof());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxInputStream, CanRead)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxInputStream::CanRead\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxInputStream::CanRead\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxInputStream){
				references = &((wxInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileInputStream) && (!reference_type_found)){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileInputStream) && (!reference_type_found)){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxInputStream::CanRead())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxInputStream_php*)_this)->CanRead());


				return;
				break;
			}
		}
	}

		
}
void php_wxFFileOutputStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFFileOutputStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxFFileOutputStream_php* object = static_cast<wxFFileOutputStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFFileOutputStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxFFileOutputStream, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFFileOutputStream::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFFileOutputStream::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFFileOutputStream){
				references = &((wxFFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFFileOutputStream::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFFileOutputStream_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFFileOutputStream, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFFileOutputStream::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	char* mode0;
	long mode_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* file1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|s' (&filename0, &filename_len0, &mode0, &mode_len0)\n");
		#endif
		char parse_parameters_string[] = "s|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0, &mode0, &mode_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&file1, php_wxFFile_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file1, php_wxFFile_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(file1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(file1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(file1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(filename0, wxConvUTF8))\n");
				#endif
				_this = new wxFFileOutputStream_php(wxString(filename0, wxConvUTF8));

				((wxFFileOutputStream_php*) _this)->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(filename0, wxConvUTF8), wxString(mode0, wxConvUTF8))\n");
				#endif
				_this = new wxFFileOutputStream_php(wxString(filename0, wxConvUTF8), wxString(mode0, wxConvUTF8));

				((wxFFileOutputStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxFFile*) object_pointer1_0)\n");
				#endif
				_this = new wxFFileOutputStream_php(*(wxFFile*) object_pointer1_0);

				((wxFFileOutputStream_php*) _this)->references.Initialize();
				((wxFFileOutputStream_php*) _this)->references.AddReference(file1);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFFileOutputStream);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFFileOutputStream_php*) _this)->evnArray);
		
		array_init(((wxFFileOutputStream_php*) _this)->evnArray);
		
		((wxFFileOutputStream_php*) _this)->phpObj = getThis();
		
		((wxFFileOutputStream_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFFileOutputStream_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxFileOutputStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileOutputStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxFileOutputStream_php* object = static_cast<wxFileOutputStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileOutputStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxFileOutputStream, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileOutputStream::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileOutputStream::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileOutputStream){
				references = &((wxFileOutputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileOutputStream::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileOutputStream_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileOutputStream, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileOutputStream::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	char* ofileName0;
	long ofileName_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* file1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long fd2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&ofileName0, &ofileName_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &ofileName0, &ofileName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&file1, php_wxFile_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file1, php_wxFile_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(file1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(file1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(file1) != IS_NULL)
				{
						goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&fd2)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &fd2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(ofileName0, wxConvUTF8))\n");
				#endif
				_this = new wxFileOutputStream_php(wxString(ofileName0, wxConvUTF8));

				((wxFileOutputStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxFile*) object_pointer1_0)\n");
				#endif
				_this = new wxFileOutputStream_php(*(wxFile*) object_pointer1_0);

				((wxFileOutputStream_php*) _this)->references.Initialize();
				((wxFileOutputStream_php*) _this)->references.AddReference(file1);
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) fd2)\n");
				#endif
				_this = new wxFileOutputStream_php((int) fd2);

				((wxFileOutputStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFileOutputStream);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFileOutputStream_php*) _this)->evnArray);
		
		array_init(((wxFileOutputStream_php*) _this)->evnArray);
		
		((wxFileOutputStream_php*) _this)->phpObj = getThis();
		
		((wxFileOutputStream_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFileOutputStream_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxFileInputStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileInputStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxFileInputStream_php* object = static_cast<wxFileInputStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileInputStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxFileInputStream, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileInputStream::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileInputStream::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileInputStream){
				references = &((wxFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileStream) && (!reference_type_found)){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileInputStream::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileInputStream_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileInputStream, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileInputStream::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	char* ifileName0;
	long ifileName_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* file1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long fd2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&ifileName0, &ifileName_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &ifileName0, &ifileName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&file1, php_wxFile_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file1, php_wxFile_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(file1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(file1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(file1) != IS_NULL)
				{
						goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&fd2)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &fd2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(ifileName0, wxConvUTF8))\n");
				#endif
				_this = new wxFileInputStream_php(wxString(ifileName0, wxConvUTF8));

				((wxFileInputStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxFile*) object_pointer1_0)\n");
				#endif
				_this = new wxFileInputStream_php(*(wxFile*) object_pointer1_0);

				((wxFileInputStream_php*) _this)->references.Initialize();
				((wxFileInputStream_php*) _this)->references.AddReference(file1);
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) fd2)\n");
				#endif
				_this = new wxFileInputStream_php((int) fd2);

				((wxFileInputStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFileInputStream);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFileInputStream_php*) _this)->evnArray);
		
		array_init(((wxFileInputStream_php*) _this)->evnArray);
		
		((wxFileInputStream_php*) _this)->phpObj = getThis();
		
		((wxFileInputStream_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFileInputStream_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxFFileInputStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFFileInputStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxFFileInputStream_php* object = static_cast<wxFFileInputStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFFileInputStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxFFileInputStream, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFFileInputStream::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* file0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* filename1;
	long filename_len1;
	char* mode1;
	long mode_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&file0, php_wxFFile_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file0, php_wxFFile_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(file0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(file0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(file0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|s' (&filename1, &filename_len1, &mode1, &mode_len1)\n");
		#endif
		char parse_parameters_string[] = "s|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename1, &filename_len1, &mode1, &mode_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxFFile*) object_pointer0_0)\n");
				#endif
				_this = new wxFFileInputStream_php(*(wxFFile*) object_pointer0_0);

				((wxFFileInputStream_php*) _this)->references.Initialize();
				((wxFFileInputStream_php*) _this)->references.AddReference(file0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(filename1, wxConvUTF8))\n");
				#endif
				_this = new wxFFileInputStream_php(wxString(filename1, wxConvUTF8));

				((wxFFileInputStream_php*) _this)->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(filename1, wxConvUTF8), wxString(mode1, wxConvUTF8))\n");
				#endif
				_this = new wxFFileInputStream_php(wxString(filename1, wxConvUTF8), wxString(mode1, wxConvUTF8));

				((wxFFileInputStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFFileInputStream);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFFileInputStream_php*) _this)->evnArray);
		
		array_init(((wxFFileInputStream_php*) _this)->evnArray);
		
		((wxFFileInputStream_php*) _this)->phpObj = getThis();
		
		((wxFFileInputStream_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFFileInputStream_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxFFileInputStream, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFFileInputStream::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFFileInputStream::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFFileInputStream){
				references = &((wxFFileInputStream_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFFileStream) && (!reference_type_found)){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFFileInputStream::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFFileInputStream_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
void php_wxFFileStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFFileStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxFFileStream_php* object = static_cast<wxFFileStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFFileStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxFFileStream, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFFileStream::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFFileStream::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFFileStream){
				references = &((wxFFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFFileStream::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFFileStream_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFFileStream, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFFileStream::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	char* iofileName0;
	long iofileName_len0;
	char* mode0;
	long mode_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|s' (&iofileName0, &iofileName_len0, &mode0, &mode_len0)\n");
		#endif
		char parse_parameters_string[] = "s|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &iofileName0, &iofileName_len0, &mode0, &mode_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(iofileName0, wxConvUTF8))\n");
				#endif
				_this = new wxFFileStream_php(wxString(iofileName0, wxConvUTF8));

				((wxFFileStream_php*) _this)->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(iofileName0, wxConvUTF8), wxString(mode0, wxConvUTF8))\n");
				#endif
				_this = new wxFFileStream_php(wxString(iofileName0, wxConvUTF8), wxString(mode0, wxConvUTF8));

				((wxFFileStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFFileStream);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFFileStream_php*) _this)->evnArray);
		
		array_init(((wxFFileStream_php*) _this)->evnArray);
		
		((wxFFileStream_php*) _this)->phpObj = getThis();
		
		((wxFFileStream_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFFileStream_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxFileStream_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileStream_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxFileStream_php* object = static_cast<wxFileStream_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileStream done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxFileStream, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileStream::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileStream::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileStream){
				references = &((wxFileStream_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileStream::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileStream_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxFileStream, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileStream::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	char* iofileName0;
	long iofileName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&iofileName0, &iofileName_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &iofileName0, &iofileName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(iofileName0, wxConvUTF8))\n");
				#endif
				_this = new wxFileStream_php(wxString(iofileName0, wxConvUTF8));

				((wxFileStream_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFileStream);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxFileStream_php*) _this)->evnArray);
		
		array_init(((wxFileStream_php*) _this)->evnArray);
		
		((wxFileStream_php*) _this)->phpObj = getThis();
		
		((wxFileStream_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFileStream_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
